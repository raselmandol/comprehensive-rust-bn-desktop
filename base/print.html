<!DOCTYPE HTML>
<html lang="bn" class="sidebar-visible no-js light">
    
<meta http-equiv="content-type" content="text/html;charset=utf-8" />
<head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Comprehensive Rust ü¶Ä</title>
        <meta name="robots" content="noindex" />

        <script async src="../../../www.gstatic.com/brandstudio/kato/cookie_choice_component/cookie_consent_bar.v3.js"
                data-autoload-cookie-consent-bar="true"></script>

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZN78TEJMRW"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-ZN78TEJMRW');
        </script>

        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="svgbob.css">
        <link rel="stylesheet" href="speaker-notes.css">
        <link rel="stylesheet" href="language-picker.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index-2.html">Comprehensive Rust ü¶Ä ‡¶è ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ</a></li><li class="chapter-item "><a href="running-the-course.html"><strong aria-hidden="true">1.</strong> ‡¶ï‡ßã‡¶∞‡ßç‡¶∏ ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="running-the-course/course-structure.html"><strong aria-hidden="true">1.1.</strong> ‡¶ï‡ßã‡¶∞‡ßç‡¶∏ ‡¶è‡¶∞ ‡¶ó‡¶†‡¶®</a></li><li class="chapter-item "><a href="running-the-course/keyboard-shortcuts.html"><strong aria-hidden="true">1.2.</strong> ‡¶ï‡¶ø‡¶¨‡ßã‡¶∞‡ßç‡¶° ‡¶∂‡¶∞‡ßç‡¶ü‡¶ï‡¶æ‡¶ü</a></li><li class="chapter-item "><a href="running-the-course/translations.html"><strong aria-hidden="true">1.3.</strong> ‡¶Ö‡¶®‡ßÅ‡¶¨‡¶æ‡¶¶</a></li></ol></li><li class="chapter-item "><a href="cargo.html"><strong aria-hidden="true">2.</strong> Cargo ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cargo/rust-ecosystem.html"><strong aria-hidden="true">2.1.</strong> ‡¶∞‡¶æ‡¶∏‡ßç‡¶ü ‡¶á‡¶ï‡ßã‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ</a></li><li class="chapter-item "><a href="cargo/code-samples.html"><strong aria-hidden="true">2.2.</strong> ‡¶ï‡ßã‡¶° ‡¶®‡¶Æ‡ßÅ‡¶®‡¶æ</a></li><li class="chapter-item "><a href="cargo/running-locally.html"><strong aria-hidden="true">2.3.</strong> Cargo Locally ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã ‡¶π‡¶ö‡ßç‡¶õ‡ßá</a></li></ol></li><li class="chapter-item "><li class="part-title">‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶¶‡¶ø‡¶®‡¶É ‡¶∏‡¶ï‡¶æ‡¶≤</li><li class="spacer"></li><li class="chapter-item "><a href="welcome-day-1.html"><strong aria-hidden="true">3.</strong> ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="welcome-day-1/what-is-rust.html"><strong aria-hidden="true">3.1.</strong> Rust ‡¶ï‡¶ø?</a></li></ol></li><li class="chapter-item "><a href="hello-world.html"><strong aria-hidden="true">4.</strong> Hello World!</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello-world/small-example.html"><strong aria-hidden="true">4.1.</strong> ‡¶õ‡ßã‡¶ü‡ßç‡¶ü ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£</a></li></ol></li><li class="chapter-item "><a href="why-rust.html"><strong aria-hidden="true">5.</strong> Rust ‡¶ï‡ßá‡¶®‡ßã?</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="why-rust/compile-time.html"><strong aria-hidden="true">5.1.</strong> ‡¶ï‡¶Æ‡ßç‡¶™‡¶æ‡¶á‡¶≤ ‡¶∏‡¶Æ‡ßü‡ßá‡¶∞ ‡¶ó‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶®‡ßç‡¶ü‡¶ø</a></li><li class="chapter-item "><a href="why-rust/runtime.html"><strong aria-hidden="true">5.2.</strong> ‡¶∞‡¶æ‡¶®‡¶ü‡¶æ‡¶á‡¶Æ ‡¶ó‡ßç‡¶Ø‡¶∞‡¶æ‡¶®‡ßç‡¶ü‡¶ø</a></li><li class="chapter-item "><a href="why-rust/modern.html"><strong aria-hidden="true">5.3.</strong> ‡¶Ü‡¶ß‡ßÅ‡¶®‡¶ø‡¶ï ‡¶∏‡ßÅ‡¶¨‡¶ø‡¶ß‡¶æ‡¶∏‡¶Æ‡ßÇ‡¶π</a></li></ol></li><li class="chapter-item "><a href="basic-syntax.html"><strong aria-hidden="true">6.</strong> ‡¶Æ‡ßå‡¶≤‡¶ø‡¶ï ‡¶∏‡¶ø‡¶®‡¶ü‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶∏</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/scalar-types.html"><strong aria-hidden="true">6.1.</strong> ‡¶∏‡ßç‡¶ï‡ßá‡¶≤‡¶æ‡¶∞ ‡¶ü‡¶æ‡¶á‡¶™</a></li><li class="chapter-item "><a href="basic-syntax/compound-types.html"><strong aria-hidden="true">6.2.</strong> ‡¶ï‡¶Æ‡ßç‡¶™‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶ü‡¶æ‡¶á‡¶™</a></li><li class="chapter-item "><a href="basic-syntax/references.html"><strong aria-hidden="true">6.3.</strong> ‡¶∞‡ßá‡¶´‡¶æ‡¶∞‡ßá‡¶®‡ßç‡¶∏</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/references-dangling.html"><strong aria-hidden="true">6.3.1.</strong> ‡¶°‡ßç‡¶Ø‡¶æ‡¶ô‡ßç‡¶ó‡¶≤‡¶ø‡¶Ç ‡¶∞‡ßá‡¶´‡¶æ‡¶∞‡ßá‡¶®‡ßç‡¶∏</a></li></ol></li><li class="chapter-item "><a href="basic-syntax/slices.html"><strong aria-hidden="true">6.4.</strong> Slices</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/string-slices.html"><strong aria-hidden="true">6.4.1.</strong> String ‡¶¨‡¶®‡¶æ‡¶Æ str</a></li></ol></li><li class="chapter-item "><a href="basic-syntax/functions.html"><strong aria-hidden="true">6.5.</strong> ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/rustdoc.html"><strong aria-hidden="true">6.5.1.</strong> Rustdoc</a></li><li class="chapter-item "><a href="basic-syntax/methods.html"><strong aria-hidden="true">6.5.2.</strong> ‡¶Æ‡ßá‡¶•‡¶°‡¶∏</a></li><li class="chapter-item "><a href="basic-syntax/functions-interlude.html"><strong aria-hidden="true">6.5.3.</strong> ‡¶Ö‡¶≠‡¶æ‡¶∞‡¶≤‡ßã‡¶°‡¶ø‡¶Ç</a></li></ol></li></ol></li><li class="chapter-item "><a href="exercises/day-1/morning.html"><strong aria-hidden="true">7.</strong> ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-1/implicit-conversions.html"><strong aria-hidden="true">7.1.</strong> ‡¶á‡¶Æ‡¶™‡ßç‡¶≤‡¶ø‡¶∏‡¶ø‡¶ü ‡¶∞‡ßÇ‡¶™‡¶æ‡¶®‡ßç‡¶§‡¶∞</a></li><li class="chapter-item "><a href="exercises/day-1/for-loops.html"><strong aria-hidden="true">7.2.</strong> Arrays ‡¶è‡¶¨‡¶Ç for-Loops</a></li></ol></li><li class="chapter-item "><li class="part-title">‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶¶‡¶ø‡¶®‡¶É ‡¶¨‡¶ø‡¶ï‡¶æ‡¶≤</li><li class="chapter-item "><a href="basic-syntax/variables.html"><strong aria-hidden="true">8.</strong> ‡¶≠‡ßá‡¶∞‡¶ø‡ßü‡ßá‡¶¨‡¶≤</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/type-inference.html"><strong aria-hidden="true">8.1.</strong> ‡¶ü‡¶æ‡¶á‡¶™ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶æ‡¶®</a></li><li class="chapter-item "><a href="basic-syntax/static-and-const.html"><strong aria-hidden="true">8.2.</strong> static & const</a></li><li class="chapter-item "><a href="basic-syntax/scopes-shadowing.html"><strong aria-hidden="true">8.3.</strong> Scopes and Shadowing</a></li></ol></li><li class="chapter-item "><a href="memory-management.html"><strong aria-hidden="true">9.</strong> ‡¶Æ‡ßá‡¶Æ‡ßã‡¶∞‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶™‡¶®‡¶æ</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="memory-management/stack-vs-heap.html"><strong aria-hidden="true">9.1.</strong> Stack ‡¶¨‡¶®‡¶æ‡¶Æ Heap</a></li><li class="chapter-item "><a href="memory-management/stack.html"><strong aria-hidden="true">9.2.</strong> Stack ‡¶Æ‡ßá‡¶Æ‡ßã‡¶∞‡¶ø</a></li><li class="chapter-item "><a href="memory-management/manual.html"><strong aria-hidden="true">9.3.</strong> ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶≤ ‡¶Æ‡ßá‡¶Æ‡ßã‡¶∞‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶™‡¶®‡¶æ</a></li><li class="chapter-item "><a href="memory-management/scope-based.html"><strong aria-hidden="true">9.4.</strong> ‡¶∏‡ßç‡¶ï‡ßã‡¶™ ‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶ï ‡¶Æ‡ßá‡¶Æ‡ßã‡¶∞‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶™‡¶®‡¶æ</a></li><li class="chapter-item "><a href="memory-management/garbage-collection.html"><strong aria-hidden="true">9.5.</strong> Garbage Collection</a></li><li class="chapter-item "><a href="memory-management/rust.html"><strong aria-hidden="true">9.6.</strong> Rust ‡¶Æ‡ßá‡¶Æ‡ßã‡¶∞‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶™‡¶®‡¶æ</a></li><li class="chapter-item "><a href="memory-management/comparison.html"><strong aria-hidden="true">9.7.</strong> ‡¶§‡ßÅ‡¶≤‡¶®‡¶æ</a></li></ol></li><li class="chapter-item "><a href="ownership.html"><strong aria-hidden="true">10.</strong> ‡¶Æ‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ‡¶®‡¶æ</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/move-semantics.html"><strong aria-hidden="true">10.1.</strong> Move Semantics</a></li><li class="chapter-item "><a href="ownership/moved-strings-rust.html"><strong aria-hidden="true">10.2.</strong> Moved Strings in Rust</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/double-free-modern-cpp.html"><strong aria-hidden="true">10.2.1.</strong> ‡¶Ü‡¶ß‡ßÅ‡¶®‡¶ø‡¶ï C++ ‡¶è ‡¶°‡¶¨‡¶≤ ‡¶Æ‡ßÅ‡¶ï‡ßç‡¶§</a></li></ol></li><li class="chapter-item "><a href="ownership/moves-function-calls.html"><strong aria-hidden="true">10.3.</strong> Moves in Function Calls</a></li><li class="chapter-item "><a href="ownership/copy-clone.html"><strong aria-hidden="true">10.4.</strong> ‡¶Ö‡¶®‡ßÅ‡¶≤‡¶ø‡¶™‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶ï‡ßç‡¶≤‡ßã‡¶®‡¶ø‡¶Ç</a></li><li class="chapter-item "><a href="ownership/borrowing.html"><strong aria-hidden="true">10.5.</strong> ‡¶ß‡¶æ‡¶∞ ‡¶®‡ßá‡¶ì‡ßü‡¶æ</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/shared-unique-borrows.html"><strong aria-hidden="true">10.5.1.</strong> ‡¶≠‡¶æ‡¶ó ‡¶ï‡¶∞‡¶æ ‡¶ß‡¶æ‡¶∞ ‡¶è‡¶¨‡¶Ç ‡¶Ö‡¶®‡¶®‡ßç‡¶Ø ‡¶ß‡¶æ‡¶∞</a></li></ol></li><li class="chapter-item "><a href="ownership/lifetimes.html"><strong aria-hidden="true">10.6.</strong> ‡¶ú‡ßÄ‡¶¨‡¶®‡¶ï‡¶æ‡¶≤</a></li><li class="chapter-item "><a href="ownership/lifetimes-function-calls.html"><strong aria-hidden="true">10.7.</strong> ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ‡¶ï‡¶≤ ‡¶è ‡¶ú‡ßÄ‡¶¨‡¶®‡¶ï‡¶æ‡¶≤</a></li><li class="chapter-item "><a href="ownership/lifetimes-data-structures.html"><strong aria-hidden="true">10.8.</strong> ‡¶°‡ßá‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ ‡¶è ‡¶ú‡ßÄ‡¶¨‡¶®‡¶ï‡¶æ‡¶≤</a></li></ol></li><li class="chapter-item "><a href="exercises/day-1/afternoon.html"><strong aria-hidden="true">11.</strong> ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-1/book-library.html"><strong aria-hidden="true">11.1.</strong> Storing Books</a></li><li class="chapter-item "><a href="exercises/day-1/iterators-and-ownership.html"><strong aria-hidden="true">11.2.</strong> Iterators and Ownership</a></li></ol></li><li class="chapter-item "><li class="part-title">‡¶¶‡ßç‡¶¨‡¶ø‡¶§‡ßÄ‡¶Ø‡¶º ‡¶¶‡¶ø‡¶®‡¶É ‡¶∏‡¶ï‡¶æ‡¶≤</li><li class="spacer"></li><li class="chapter-item "><a href="welcome-day-2.html"><strong aria-hidden="true">12.</strong> ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ</a></li><li class="chapter-item "><a href="structs.html"><strong aria-hidden="true">13.</strong> Structs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="structs/tuple-structs.html"><strong aria-hidden="true">13.1.</strong> Tuple Structs</a></li><li class="chapter-item "><a href="structs/field-shorthand.html"><strong aria-hidden="true">13.2.</strong> Field Shorthand Syntax</a></li></ol></li><li class="chapter-item "><a href="enums.html"><strong aria-hidden="true">14.</strong> Enums</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="enums/variant-payloads.html"><strong aria-hidden="true">14.1.</strong> ‡¶≠‡¶ø‡¶®‡ßç‡¶® Payloads</a></li><li class="chapter-item "><a href="enums/sizes.html"><strong aria-hidden="true">14.2.</strong> Enum ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶™</a></li></ol></li><li class="chapter-item "><a href="methods.html"><strong aria-hidden="true">15.</strong> ‡¶Æ‡ßá‡¶•‡¶°‡¶∏</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="methods/receiver.html"><strong aria-hidden="true">15.1.</strong> Method Receiver</a></li><li class="chapter-item "><a href="methods/example.html"><strong aria-hidden="true">15.2.</strong> ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£</a></li></ol></li><li class="chapter-item "><a href="pattern-matching.html"><strong aria-hidden="true">16.</strong> ‡¶™‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶Æ‡¶ø‡¶≤‡¶æ‡¶®‡ßã</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-matching/destructuring-enums.html"><strong aria-hidden="true">16.1.</strong> Enums ‡¶°‡¶ø‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞</a></li><li class="chapter-item "><a href="pattern-matching/destructuring-structs.html"><strong aria-hidden="true">16.2.</strong> Structs ‡¶°‡¶ø‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ </a></li><li class="chapter-item "><a href="pattern-matching/destructuring-arrays.html"><strong aria-hidden="true">16.3.</strong> Arrays ‡¶°‡¶ø‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ </a></li><li class="chapter-item "><a href="pattern-matching/match-guards.html"><strong aria-hidden="true">16.4.</strong> Match Guards</a></li></ol></li><li class="chapter-item "><a href="exercises/day-2/morning.html"><strong aria-hidden="true">17.</strong> ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-2/health-statistics.html"><strong aria-hidden="true">17.1.</strong> ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶™‡¶∞‡¶ø‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶®</a></li><li class="chapter-item "><a href="exercises/day-2/points-polygons.html"><strong aria-hidden="true">17.2.</strong> Points and Polygons</a></li></ol></li><li class="chapter-item "><li class="part-title">‡¶¶‡ßç‡¶¨‡¶ø‡¶§‡ßÄ‡ßü ‡¶¶‡¶ø‡¶®‡¶É ‡¶¨‡¶ø‡¶ï‡¶æ‡¶≤</li><li class="chapter-item "><a href="control-flow.html"><strong aria-hidden="true">18.</strong> ‡¶™‡ßç‡¶∞‡¶¨‡¶æ‡¶π ‡¶®‡¶ø‡ßü‡¶®‡ßç‡¶§‡ßç‡¶∞‡¶£</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow/blocks.html"><strong aria-hidden="true">18.1.</strong> Blocks</a></li><li class="chapter-item "><a href="control-flow/if-expressions.html"><strong aria-hidden="true">18.2.</strong> if ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡ßç‡¶∞‡ßá‡¶∂‡¶®</a></li><li class="chapter-item "><a href="control-flow/if-let-expressions.html"><strong aria-hidden="true">18.3.</strong> if let ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡ßç‡¶∞‡ßá‡¶∂‡¶®</a></li><li class="chapter-item "><a href="control-flow/while-expressions.html"><strong aria-hidden="true">18.4.</strong> while ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡ßç‡¶∞‡ßá‡¶∂‡¶®</a></li><li class="chapter-item "><a href="control-flow/while-let-expressions.html"><strong aria-hidden="true">18.5.</strong> while let ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡ßç‡¶∞‡ßá‡¶∂‡¶®</a></li><li class="chapter-item "><a href="control-flow/for-expressions.html"><strong aria-hidden="true">18.6.</strong> for ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡ßç‡¶∞‡ßá‡¶∂‡¶®</a></li><li class="chapter-item "><a href="control-flow/loop-expressions.html"><strong aria-hidden="true">18.7.</strong> loop ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡ßç‡¶∞‡ßá‡¶∂‡¶®</a></li><li class="chapter-item "><a href="control-flow/match-expressions.html"><strong aria-hidden="true">18.8.</strong> match ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡ßç‡¶∞‡ßá‡¶∂‡¶®</a></li><li class="chapter-item "><a href="control-flow/break-continue.html"><strong aria-hidden="true">18.9.</strong> break & continue</a></li></ol></li><li class="chapter-item "><a href="std.html"><strong aria-hidden="true">19.</strong> ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶æ‡¶∞‡ßç‡¶° ‡¶≤‡¶æ‡¶á‡¶¨‡ßç‡¶∞‡ßá‡¶∞‡¶ø</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/option-result.html"><strong aria-hidden="true">19.1.</strong> Option ‡¶è‡¶¨‡¶Ç Result</a></li><li class="chapter-item "><a href="std/string.html"><strong aria-hidden="true">19.2.</strong> String</a></li><li class="chapter-item "><a href="std/vec.html"><strong aria-hidden="true">19.3.</strong> Vec</a></li><li class="chapter-item "><a href="std/hashmap.html"><strong aria-hidden="true">19.4.</strong> HashMap</a></li><li class="chapter-item "><a href="std/box.html"><strong aria-hidden="true">19.5.</strong> Box</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/box-recursive.html"><strong aria-hidden="true">19.5.1.</strong> ‡¶∞‡¶ø‡¶ï‡¶æ‡¶∞‡ßç‡¶∏‡¶ø‡¶≠ ‡¶°‡ßá‡¶ü‡¶æ ‡¶ü‡¶æ‡¶á‡¶™</a></li><li class="chapter-item "><a href="std/box-niche.html"><strong aria-hidden="true">19.5.2.</strong> Niche ‡¶Ö‡¶™‡¶ü‡¶ø‡¶Æ‡¶æ‡¶á‡¶ú‡ßá‡¶∂‡¶®</a></li></ol></li><li class="chapter-item "><a href="std/rc.html"><strong aria-hidden="true">19.6.</strong> Rc</a></li><li class="chapter-item "><a href="std/cell.html"><strong aria-hidden="true">19.7.</strong> Cell/RefCell</a></li></ol></li><li class="chapter-item "><a href="modules.html"><strong aria-hidden="true">20.</strong> Modules</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="modules/visibility.html"><strong aria-hidden="true">20.1.</strong> ‡¶¶‡ßÉ‡¶∂‡ßç‡¶Ø‡¶Æ‡¶æ‡¶®‡¶§‡¶æ</a></li><li class="chapter-item "><a href="modules/paths.html"><strong aria-hidden="true">20.2.</strong> Paths</a></li><li class="chapter-item "><a href="modules/filesystem.html"><strong aria-hidden="true">20.3.</strong> Filesystem Hierarchy</a></li></ol></li><li class="chapter-item "><a href="exercises/day-2/afternoon.html"><strong aria-hidden="true">21.</strong> ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-2/luhn.html"><strong aria-hidden="true">21.1.</strong> ‡¶≤‡ßÅ‡¶® ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ</a></li><li class="chapter-item "><a href="exercises/day-2/strings-iterators.html"><strong aria-hidden="true">21.2.</strong> Strings ‡¶è‡¶¨‡¶Ç Iterators</a></li></ol></li><li class="chapter-item "><li class="part-title">‡¶§‡ßÉ‡¶§‡ßÄ‡ßü ‡¶¶‡¶ø‡¶®‡¶É ‡¶∏‡¶ï‡¶æ‡¶≤</li><li class="spacer"></li><li class="chapter-item "><a href="welcome-day-3.html"><strong aria-hidden="true">22.</strong> ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ</a></li><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">23.</strong> ‡¶ú‡ßá‡¶®‡ßá‡¶∞‡¶ø‡¶ï‡¶∏</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/data-types.html"><strong aria-hidden="true">23.1.</strong> ‡¶ú‡ßá‡¶®‡ßá‡¶∞‡¶ø‡¶ï ‡¶°‡ßá‡¶ü‡¶æ ‡¶ü‡¶æ‡¶á‡¶™</a></li><li class="chapter-item "><a href="generics/methods.html"><strong aria-hidden="true">23.2.</strong> ‡¶ú‡ßá‡¶®‡ßá‡¶∞‡¶ø‡¶ï ‡¶Æ‡ßá‡¶•‡¶°-‡¶∏‡¶Æ‡ßÇ‡¶π</a></li><li class="chapter-item "><a href="generics/monomorphization.html"><strong aria-hidden="true">23.3.</strong> Monomorphization</a></li></ol></li><li class="chapter-item "><a href="traits.html"><strong aria-hidden="true">24.</strong> Traits</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/trait-objects.html"><strong aria-hidden="true">24.1.</strong> Trait Objects</a></li><li class="chapter-item "><a href="traits/deriving-traits.html"><strong aria-hidden="true">24.2.</strong> Deriving Traits</a></li><li class="chapter-item "><a href="traits/default-methods.html"><strong aria-hidden="true">24.3.</strong> ‡¶°‡¶ø‡¶´‡¶≤‡ßç‡¶ü ‡¶Æ‡ßá‡¶•‡¶°-‡¶∏‡¶Æ‡ßÇ‡¶π</a></li><li class="chapter-item "><a href="traits/trait-bounds.html"><strong aria-hidden="true">24.4.</strong> Trait Bounds</a></li><li class="chapter-item "><a href="traits/impl-trait.html"><strong aria-hidden="true">24.5.</strong> impl Trait</a></li></ol></li><li class="chapter-item "><a href="traits/important-traits.html"><strong aria-hidden="true">25.</strong> ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ Traits</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/iterator.html"><strong aria-hidden="true">25.1.</strong> Iterator</a></li><li class="chapter-item "><a href="traits/from-iterator.html"><strong aria-hidden="true">25.2.</strong> FromIterator</a></li><li class="chapter-item "><a href="traits/from-into.html"><strong aria-hidden="true">25.3.</strong> From ‡¶è‡¶¨‡¶Ç Into</a></li><li class="chapter-item "><a href="traits/read-write.html"><strong aria-hidden="true">25.4.</strong> Read ‡¶è‡¶¨‡¶Ç Write</a></li><li class="chapter-item "><a href="traits/drop.html"><strong aria-hidden="true">25.5.</strong> Drop</a></li><li class="chapter-item "><a href="traits/default.html"><strong aria-hidden="true">25.6.</strong> Default</a></li><li class="chapter-item "><a href="traits/operators.html"><strong aria-hidden="true">25.7.</strong> ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶ü‡¶∞‡¶É Add, Mul, ...</a></li><li class="chapter-item "><a href="traits/closures.html"><strong aria-hidden="true">25.8.</strong> Closures: Fn, FnMut, FnOnce</a></li></ol></li><li class="chapter-item "><a href="exercises/day-3/morning.html"><strong aria-hidden="true">26.</strong> ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-3/simple-gui.html"><strong aria-hidden="true">26.1.</strong> ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ GUI  ‡¶≤‡¶æ‡¶á‡¶¨‡ßç‡¶∞‡ßá‡¶∞‡¶ø</a></li></ol></li><li class="chapter-item "><li class="part-title">‡¶§‡ßÉ‡¶§‡ßÄ‡ßü ‡¶¶‡¶ø‡¶®‡¶É ‡¶¨‡¶ø‡¶ï‡¶æ‡¶≤</li><li class="chapter-item "><a href="error-handling.html"><strong aria-hidden="true">27.</strong> ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶∏‡¶æ‡¶Æ‡¶≤‡¶æ‡¶®‡ßã</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/panics.html"><strong aria-hidden="true">27.1.</strong> Panics-‡¶™‡ßç‡¶Ø‡¶æ‡¶®‡¶ø‡¶ï</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/panic-unwind.html"><strong aria-hidden="true">27.1.1.</strong> Catching Stack Unwinding</a></li></ol></li><li class="chapter-item "><a href="error-handling/result.html"><strong aria-hidden="true">27.2.</strong> ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞‡ßç‡¶° ‡¶è‡¶∞‡¶∞ ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶ø‡¶Ç</a></li><li class="chapter-item "><a href="error-handling/try-operator.html"><strong aria-hidden="true">27.3.</strong> ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø‡ßá ‡¶è‡¶∞‡¶∞/‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶π‡¶∏‡ßç‡¶§‡¶æ‡¶®‡ßç‡¶§‡¶∞ ‡¶ï‡¶∞‡¶æ ?</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/converting-error-types.html"><strong aria-hidden="true">27.3.1.</strong> ‡¶è‡¶∞‡¶∞‡ßá‡¶∞ ‡¶ü‡¶æ‡¶á‡¶™ ‡¶∞‡ßÇ‡¶™‡¶æ‡¶®‡ßç‡¶§‡¶∞</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/converting-error-types-example.html"><strong aria-hidden="true">27.3.1.1.</strong> ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£</a></li></ol></li><li class="chapter-item "><a href="error-handling/deriving-error-enums.html"><strong aria-hidden="true">27.3.2.</strong> ‡¶è‡¶∞‡¶∞‡ßá‡¶∞ ‡¶á‡¶®‡¶æ‡¶Æ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ</a></li><li class="chapter-item "><a href="error-handling/dynamic-errors.html"><strong aria-hidden="true">27.3.3.</strong> ‡¶°‡¶æ‡ßü‡¶®‡¶æ‡¶Æ‡¶ø‡¶ï ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø‡¶∞ ‡¶ß‡¶∞‡¶®</a></li><li class="chapter-item "><a href="error-handling/error-contexts.html"><strong aria-hidden="true">27.3.4.</strong> ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø‡¶§‡ßá ‡¶ï‡¶®‡ßç‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶æ</a></li></ol></li></ol></li><li class="chapter-item "><a href="testing.html"><strong aria-hidden="true">28.</strong> ‡¶ü‡ßá‡¶∏‡ßç‡¶ü‡¶ø‡¶Ç</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/unit-tests.html"><strong aria-hidden="true">28.1.</strong> ‡¶á‡¶â‡¶®‡¶ø‡¶ü ‡¶ü‡ßá‡¶∏‡ßç‡¶ü</a></li><li class="chapter-item "><a href="testing/test-modules.html"><strong aria-hidden="true">28.2.</strong> ‡¶ü‡ßá‡¶∏‡ßç‡¶ü ‡¶Æ‡¶°‡¶ø‡¶â‡¶≤</a></li><li class="chapter-item "><a href="testing/doc-tests.html"><strong aria-hidden="true">28.3.</strong> ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶® ‡¶ü‡ßá‡¶∏‡ßç‡¶ü</a></li><li class="chapter-item "><a href="testing/integration-tests.html"><strong aria-hidden="true">28.4.</strong> ‡¶á‡¶®‡ßç‡¶ü‡¶ø‡¶ó‡ßç‡¶∞‡ßá‡¶∂‡¶® ‡¶ü‡ßá‡¶∏‡ßç‡¶ü</a></li><li class="chapter-item "><a href="testing/useful-crates.html"><strong aria-hidden="true">28.5.</strong> ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶ï‡ßç‡¶∞‡ßá‡¶ü-‡¶∏‡¶Æ‡ßÇ‡¶π</a></li></ol></li><li class="chapter-item "><a href="unsafe.html"><strong aria-hidden="true">29.</strong> ‡¶Ö‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶ ‡¶∞‡¶æ‡¶∏‡ßç‡¶ü</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/raw-pointers.html"><strong aria-hidden="true">29.1.</strong> ‡¶∞ ‡¶™‡ßü‡ßá‡¶®‡ßç‡¶ü‡¶æ‡¶∞ ‡¶°‡¶ø-‡¶∞‡ßá‡¶´‡¶æ‡¶∞‡ßá‡¶®‡ßç‡¶∏ ‡¶ï‡¶∞‡¶æ</a></li><li class="chapter-item "><a href="unsafe/mutable-static-variables.html"><strong aria-hidden="true">29.2.</strong> ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®‡¶Ø‡ßã‡¶ó‡ßç‡¶Ø ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ü‡¶ø‡¶ï ‡¶≠‡ßá‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶¨‡¶≤‡¶∏</a></li><li class="chapter-item "><a href="unsafe/unions.html"><strong aria-hidden="true">29.3.</strong> Unions</a></li><li class="chapter-item "><a href="unsafe/calling-unsafe-functions.html"><strong aria-hidden="true">29.4.</strong> ‡¶Ö‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ‡¶°‡¶æ‡¶ï‡¶æ</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/writing-unsafe-functions.html"><strong aria-hidden="true">29.4.1.</strong> ‡¶Ö‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ‡¶≤‡ßá‡¶ñ‡¶æ</a></li><li class="chapter-item "><a href="unsafe/extern-functions.html"><strong aria-hidden="true">29.4.2.</strong> ‡¶¨‡¶π‡¶ø‡¶∞‡¶æ‡¶ó‡¶§ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®</a></li></ol></li><li class="chapter-item "><a href="unsafe/unsafe-traits.html"><strong aria-hidden="true">29.5.</strong> ‡¶Ö‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶ Traits ‡¶¨‡¶æ‡¶∏‡ßç‡¶§‡¶¨‡¶æ‡¶Ø‡¶º‡¶®</a></li></ol></li><li class="chapter-item "><a href="exercises/day-3/afternoon.html"><strong aria-hidden="true">30.</strong> ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-3/safe-ffi-wrapper.html"><strong aria-hidden="true">30.1.</strong> ‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶ FFI  ‡¶Æ‡ßã‡ßú‡¶ï</a></li></ol></li><li class="chapter-item "><li class="part-title">Android</li><li class="spacer"></li><li class="chapter-item "><a href="android.html"><strong aria-hidden="true">31.</strong> ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ</a></li><li class="chapter-item "><a href="android/setup.html"><strong aria-hidden="true">32.</strong> ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™</a></li><li class="chapter-item "><a href="android/build-rules.html"><strong aria-hidden="true">33.</strong> ‡¶ó‡¶†‡¶®‡ßá‡¶∞ ‡¶®‡¶ø‡ßü‡¶Æ</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/build-rules/binary.html"><strong aria-hidden="true">33.1.</strong> ‡¶¨‡¶æ‡¶á‡¶®‡¶æ‡¶∞‡¶ø</a></li><li class="chapter-item "><a href="android/build-rules/library.html"><strong aria-hidden="true">33.2.</strong> ‡¶≤‡¶æ‡¶á‡¶¨‡ßç‡¶∞‡ßá‡¶∞‡¶ø</a></li></ol></li><li class="chapter-item "><a href="android/aidl.html"><strong aria-hidden="true">34.</strong> AIDL</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/aidl/interface.html"><strong aria-hidden="true">34.1.</strong> ‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡¶´‡ßá‡¶∏</a></li><li class="chapter-item "><a href="android/aidl/implementation.html"><strong aria-hidden="true">34.2.</strong> ‡¶¨‡¶æ‡¶∏‡ßç‡¶§‡¶¨‡¶æ‡¶Ø‡¶º‡¶®</a></li><li class="chapter-item "><a href="android/aidl/server.html"><strong aria-hidden="true">34.3.</strong> ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞</a></li><li class="chapter-item "><a href="android/aidl/deploy.html"><strong aria-hidden="true">34.4.</strong> ‡¶∏‡ßç‡¶•‡¶æ‡¶™‡¶®</a></li><li class="chapter-item "><a href="android/aidl/client.html"><strong aria-hidden="true">34.5.</strong> ‡¶ï‡ßç‡¶≤‡¶æ‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü</a></li><li class="chapter-item "><a href="android/aidl/changing.html"><strong aria-hidden="true">34.6.</strong> API ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®</a></li></ol></li><li class="chapter-item "><a href="android/logging.html"><strong aria-hidden="true">35.</strong> Logging</a></li><li class="chapter-item "><a href="android/interoperability.html"><strong aria-hidden="true">36.</strong> ‡¶Ü‡¶®‡ßç‡¶§‡¶É‡¶ï‡¶æ‡¶∞‡ßç‡¶Ø‡¶ï‡ßç‡¶∑‡¶Æ‡¶§‡¶æ</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/interoperability/with-c.html"><strong aria-hidden="true">36.1.</strong> C ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/interoperability/with-c/bindgen.html"><strong aria-hidden="true">36.1.1.</strong> Bindgen ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá C ‡¶ï‡ßá ‡¶°‡¶æ‡¶ï‡¶æ</a></li><li class="chapter-item "><a href="android/interoperability/with-c/rust.html"><strong aria-hidden="true">36.1.2.</strong> C ‡¶•‡ßá‡¶ï‡ßá Rust ‡¶ï‡ßá ‡¶°‡¶æ‡¶ï‡¶æ  </a></li></ol></li><li class="chapter-item "><a href="android/interoperability/cpp.html"><strong aria-hidden="true">36.2.</strong> C++‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá</a></li><li class="chapter-item "><a href="android/interoperability/java.html"><strong aria-hidden="true">36.3.</strong> Java ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá</a></li></ol></li><li class="chapter-item "><a href="exercises/android/morning.html"><strong aria-hidden="true">37.</strong> ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®</a></li><li class="chapter-item affix "><li class="part-title">Bare Metal: ‡¶∏‡¶ï‡¶æ‡¶≤</li><li class="spacer"></li><li class="chapter-item "><a href="bare-metal.html"><strong aria-hidden="true">38.</strong> ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ</a></li><li class="chapter-item "><a href="bare-metal/no_std.html"><strong aria-hidden="true">39.</strong> no_std</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/minimal.html"><strong aria-hidden="true">39.1.</strong> ‡¶è‡¶ï‡¶ü‡¶ø ‡¶®‡ßç‡¶Ø‡ßÇ‡¶®‡¶§‡¶Æ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£</a></li><li class="chapter-item "><a href="bare-metal/alloc.html"><strong aria-hidden="true">39.2.</strong> alloc</a></li></ol></li><li class="chapter-item "><a href="bare-metal/microcontrollers.html"><strong aria-hidden="true">40.</strong> ‡¶Æ‡¶æ‡¶á‡¶ï‡ßç‡¶∞‡ßã‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤‡¶æ‡¶∞</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/microcontrollers/mmio.html"><strong aria-hidden="true">40.1.</strong> Raw MMIO</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/pacs.html"><strong aria-hidden="true">40.2.</strong> PACs</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/hals.html"><strong aria-hidden="true">40.3.</strong> HAL Crates</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/board-support.html"><strong aria-hidden="true">40.4.</strong> Board Support Crates</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/type-state.html"><strong aria-hidden="true">40.5.</strong> The Type State Pattern</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/embedded-hal.html"><strong aria-hidden="true">40.6.</strong> embedded-hal</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/probe-rs.html"><strong aria-hidden="true">40.7.</strong> probe-rs, cargo-embed</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/microcontrollers/debugging.html"><strong aria-hidden="true">40.7.1.</strong> ‡¶°‡¶ø‡¶¨‡¶æ‡¶ó‡¶ø‡¶Ç</a></li></ol></li><li class="chapter-item "><a href="bare-metal/microcontrollers/other-projects.html"><strong aria-hidden="true">40.8.</strong> Other Projects</a></li></ol></li><li class="chapter-item "><a href="exercises/bare-metal/morning.html"><strong aria-hidden="true">41.</strong> ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/bare-metal/compass.html"><strong aria-hidden="true">41.1.</strong> Compass</a></li></ol></li><li class="chapter-item "><li class="part-title">Bare Metal: Afternoon</li><li class="chapter-item "><a href="bare-metal/aps.html"><strong aria-hidden="true">42.</strong> ‡¶è‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏‡¶∞</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/entry-point.html"><strong aria-hidden="true">42.1.</strong> Getting Ready to Rust</a></li><li class="chapter-item "><a href="bare-metal/aps/inline-assembly.html"><strong aria-hidden="true">42.2.</strong> Inline Assembly</a></li><li class="chapter-item "><a href="bare-metal/aps/mmio.html"><strong aria-hidden="true">42.3.</strong> MMIO</a></li><li class="chapter-item "><a href="bare-metal/aps/uart.html"><strong aria-hidden="true">42.4.</strong> ‡¶ö‡¶≤‡ßÅ‡¶® ‡¶è‡¶ï‡¶ü‡¶ø UART Driver ‡¶≤‡¶ø‡¶ñ‡¶ø</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/uart/traits.html"><strong aria-hidden="true">42.4.1.</strong> ‡¶Ü‡¶∞‡¶ì Traits</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/better-uart.html"><strong aria-hidden="true">42.5.</strong> ‡¶è‡¶ï‡¶ü‡¶ø ‡¶â‡¶®‡ßç‡¶®‡¶§‡¶∞ UART ‡¶°‡ßç‡¶∞‡¶æ‡¶á‡¶≠‡¶æ‡¶∞</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/better-uart/bitflags.html"><strong aria-hidden="true">42.5.1.</strong> Bitflags</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/registers.html"><strong aria-hidden="true">42.5.2.</strong> ‡¶è‡¶ï‡¶æ‡¶ß‡¶ø‡¶ï ‡¶∞‡ßá‡¶ú‡¶ø‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡¶∏</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/driver.html"><strong aria-hidden="true">42.5.3.</strong> Driver</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/using.html"><strong aria-hidden="true">42.5.4.</strong> Using It</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/logging.html"><strong aria-hidden="true">42.6.</strong> Logging</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/logging/using.html"><strong aria-hidden="true">42.6.1.</strong> Using It</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/exceptions.html"><strong aria-hidden="true">42.7.</strong> Exceptions</a></li><li class="chapter-item "><a href="bare-metal/aps/other-projects.html"><strong aria-hidden="true">42.8.</strong> Other Projects</a></li></ol></li><li class="chapter-item "><a href="bare-metal/useful-crates.html"><strong aria-hidden="true">43.</strong> ‡¶â‡¶™‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶ï‡ßç‡¶∞‡ßá‡¶ü‡¶∏‡¶Æ‡ßÇ‡¶π</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/useful-crates/zerocopy.html"><strong aria-hidden="true">43.1.</strong> zerocopy</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/aarch64-paging.html"><strong aria-hidden="true">43.2.</strong> aarch64-paging</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/buddy_system_allocator.html"><strong aria-hidden="true">43.3.</strong> buddy_system_allocator</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/tinyvec.html"><strong aria-hidden="true">43.4.</strong> tinyvec</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/spin.html"><strong aria-hidden="true">43.5.</strong> spin</a></li></ol></li><li class="chapter-item "><a href="bare-metal/android.html"><strong aria-hidden="true">44.</strong> Android</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/android/vmbase.html"><strong aria-hidden="true">44.1.</strong> vmbase</a></li></ol></li><li class="chapter-item "><a href="exercises/bare-metal/afternoon.html"><strong aria-hidden="true">45.</strong> ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/bare-metal/rtc.html"><strong aria-hidden="true">45.1.</strong> RTC Driver</a></li></ol></li><li class="chapter-item "><li class="part-title">Concurrency: ‡¶∏‡¶ï‡¶æ‡¶≤</li><li class="spacer"></li><li class="chapter-item "><a href="concurrency.html"><strong aria-hidden="true">46.</strong> ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ</a></li><li class="chapter-item "><a href="concurrency/threads.html"><strong aria-hidden="true">47.</strong> Threads</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/scoped-threads.html"><strong aria-hidden="true">47.1.</strong> ‡¶∏‡ßç‡¶ï‡ßã‡¶™‡¶° Threads</a></li></ol></li><li class="chapter-item "><a href="concurrency/channels.html"><strong aria-hidden="true">48.</strong> Channels</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/channels/unbounded.html"><strong aria-hidden="true">48.1.</strong> Unbounded Channels</a></li><li class="chapter-item "><a href="concurrency/channels/bounded.html"><strong aria-hidden="true">48.2.</strong> Bounded Channels</a></li></ol></li><li class="chapter-item "><a href="concurrency/send-sync.html"><strong aria-hidden="true">49.</strong> Send ‡¶è‡¶¨‡¶Ç Sync</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/send-sync/send.html"><strong aria-hidden="true">49.1.</strong> Send</a></li><li class="chapter-item "><a href="concurrency/send-sync/sync.html"><strong aria-hidden="true">49.2.</strong> Sync</a></li><li class="chapter-item "><a href="concurrency/send-sync/examples.html"><strong aria-hidden="true">49.3.</strong> ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡¶∏‡¶Æ‡ßÇ‡¶π</a></li></ol></li><li class="chapter-item "><a href="concurrency/shared_state.html"><strong aria-hidden="true">50.</strong> Shared State</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/shared_state/arc.html"><strong aria-hidden="true">50.1.</strong> Arc</a></li><li class="chapter-item "><a href="concurrency/shared_state/mutex.html"><strong aria-hidden="true">50.2.</strong> Mutex</a></li><li class="chapter-item "><a href="concurrency/shared_state/example.html"><strong aria-hidden="true">50.3.</strong> ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£</a></li></ol></li><li class="chapter-item "><a href="exercises/concurrency/morning.html"><strong aria-hidden="true">51.</strong> ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/concurrency/dining-philosophers.html"><strong aria-hidden="true">51.1.</strong> Dining ‡¶¶‡¶æ‡¶∞‡ßç‡¶∂‡¶®‡¶ø‡¶ï</a></li><li class="chapter-item "><a href="exercises/concurrency/link-checker.html"><strong aria-hidden="true">51.2.</strong> ‡¶Æ‡¶æ‡¶≤‡ßç‡¶ü‡¶ø ‡¶•‡ßç‡¶∞‡ßá‡¶°‡ßá‡¶° ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï ‡¶ö‡ßá‡¶ï‡¶æ‡¶∞</a></li></ol></li><li class="chapter-item "><li class="part-title">Concurrency: Afternoon</li><li class="chapter-item "><a href="async.html"><strong aria-hidden="true">52.</strong> Async Basics</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/async-await.html"><strong aria-hidden="true">52.1.</strong> async/await</a></li><li class="chapter-item "><a href="async/futures.html"><strong aria-hidden="true">52.2.</strong> ‡¶≠‡¶¨‡¶ø‡¶∑‡ßç‡¶Ø‡ßé</a></li><li class="chapter-item "><a href="async/runtimes.html"><strong aria-hidden="true">52.3.</strong> Runtimes</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/runtimes/tokio.html"><strong aria-hidden="true">52.3.1.</strong> Tokio</a></li></ol></li><li class="chapter-item "><a href="async/tasks.html"><strong aria-hidden="true">52.4.</strong> Tasks-‡¶ï‡¶∞‡ßç‡¶Æ</a></li><li class="chapter-item "><a href="async/channels.html"><strong aria-hidden="true">52.5.</strong> Async Channels</a></li></ol></li><li class="chapter-item "><a href="async/control-flow.html"><strong aria-hidden="true">53.</strong> ‡¶™‡ßç‡¶∞‡¶¨‡¶æ‡¶π ‡¶®‡¶ø‡ßü‡¶®‡ßç‡¶§‡ßç‡¶∞‡¶£</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/control-flow/join.html"><strong aria-hidden="true">53.1.</strong> Join</a></li><li class="chapter-item "><a href="async/control-flow/select.html"><strong aria-hidden="true">53.2.</strong> Select</a></li></ol></li><li class="chapter-item "><a href="async/pitfalls.html"><strong aria-hidden="true">54.</strong> ‡¶ï‡ßç‡¶∑‡¶§‡¶ø</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/pitfalls/blocking-executor.html"><strong aria-hidden="true">54.1.</strong> ‡¶è‡¶ï‡ßç‡¶∏‡¶ø‡¶ï‡¶ø‡¶â‡¶ü‡¶∞ ‡¶¨‡ßç‡¶≤‡¶ï ‡¶ï‡¶∞‡¶æ</a></li><li class="chapter-item "><a href="async/pitfalls/pin.html"><strong aria-hidden="true">54.2.</strong> Pin</a></li><li class="chapter-item "><a href="async/pitfalls/async-traits.html"><strong aria-hidden="true">54.3.</strong> Async Traits</a></li><li class="chapter-item "><a href="async/pitfalls/cancellation.html"><strong aria-hidden="true">54.4.</strong> Cancellation</a></li></ol></li><li class="chapter-item "><a href="exercises/concurrency/afternoon.html"><strong aria-hidden="true">55.</strong> ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/concurrency/dining-philosophers-async.html"><strong aria-hidden="true">55.1.</strong> Dining ‡¶¶‡¶æ‡¶∞‡ßç‡¶∂‡¶®‡¶ø‡¶ï</a></li><li class="chapter-item "><a href="exercises/concurrency/chat-app.html"><strong aria-hidden="true">55.2.</strong> Broadcast Chat Application</a></li></ol></li><li class="chapter-item "><li class="part-title">‡¶ö‡ßÇ‡¶°‡¶º‡¶æ‡¶®‡ßç‡¶§ ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶ï‡¶•‡¶æ</li><li class="spacer"></li><li class="chapter-item "><a href="thanks.html"><strong aria-hidden="true">56.</strong> ‡¶ß‡¶®‡ßç‡¶Ø‡¶¨‡¶æ‡¶¶!</a></li><li class="chapter-item "><a href="other-resources.html"><strong aria-hidden="true">57.</strong> ‡¶Ö‡¶®‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶Ø ‡¶â‡ßé‡¶∏‡¶∏‡¶Æ‡ßÇ‡¶π</a></li><li class="chapter-item "><a href="credits.html"><strong aria-hidden="true">58.</strong> ‡¶ï‡ßç‡¶∞‡ßá‡¶°‡¶ø‡¶ü‡¶∏</a></li><li class="chapter-item affix "><li class="part-title">‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®‡¶∏‡¶Æ‡ßÇ‡¶π</li><li class="spacer"></li><li class="chapter-item "><a href="exercises/solutions.html"><strong aria-hidden="true">59.</strong> ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®‡¶∏‡¶Æ‡ßÇ‡¶π</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-1/solutions-morning.html"><strong aria-hidden="true">59.1.</strong> ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶¶‡¶ø‡¶®‡¶É ‡¶∏‡¶ï‡¶æ‡¶≤</a></li><li class="chapter-item "><a href="exercises/day-1/solutions-afternoon.html"><strong aria-hidden="true">59.2.</strong> ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶¶‡¶ø‡¶®‡¶É ‡¶¨‡¶ø‡¶ï‡¶æ‡¶≤</a></li><li class="chapter-item "><a href="exercises/day-2/solutions-morning.html"><strong aria-hidden="true">59.3.</strong> ‡¶¶‡ßç‡¶¨‡¶ø‡¶§‡ßÄ‡ßü ‡¶¶‡¶ø‡¶®‡¶É ‡¶∏‡¶ï‡¶æ‡¶≤</a></li><li class="chapter-item "><a href="exercises/day-2/solutions-afternoon.html"><strong aria-hidden="true">59.4.</strong> ‡¶¶‡ßç‡¶¨‡¶ø‡¶§‡ßÄ‡ßü ‡¶¶‡¶ø‡¶®‡¶É ‡¶¨‡¶ø‡¶ï‡¶æ‡¶≤</a></li><li class="chapter-item "><a href="exercises/day-3/solutions-morning.html"><strong aria-hidden="true">59.5.</strong> ‡¶§‡ßÉ‡¶§‡ßÄ‡ßü ‡¶¶‡¶ø‡¶®‡¶É ‡¶∏‡¶ï‡¶æ‡¶≤</a></li><li class="chapter-item "><a href="exercises/day-3/solutions-afternoon.html"><strong aria-hidden="true">59.6.</strong> ‡¶§‡ßÉ‡¶§‡ßÄ‡ßü ‡¶¶‡¶ø‡¶®‡¶É ‡¶¨‡¶ø‡¶ï‡¶æ‡¶≤</a></li><li class="chapter-item "><a href="exercises/bare-metal/solutions-morning.html"><strong aria-hidden="true">59.7.</strong> Bare Metal Rust: ‡¶∏‡¶ï‡¶æ‡¶≤</a></li><li class="chapter-item "><a href="exercises/bare-metal/solutions-afternoon.html"><strong aria-hidden="true">59.8.</strong> Bare Metal Rust: ‡¶¨‡¶ø‡¶ï‡¶æ‡¶≤</a></li><li class="chapter-item "><a href="exercises/concurrency/solutions-morning.html"><strong aria-hidden="true">59.9.</strong> Concurrency: ‡¶¨‡¶ø‡¶ï‡¶æ‡¶≤</a></li><li class="chapter-item "><a href="exercises/concurrency/solutions-afternoon.html"><strong aria-hidden="true">59.10.</strong> Concurrency: ‡¶¨‡¶ø‡¶ï‡¶æ‡¶≤</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Comprehensive Rust ü¶Ä</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="pt-BR">Brazilian Portuguese</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ko">ÌïúÍµ≠Ïñ¥ (Korean)</a>
                          </button></li>
                        </ul>

                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("bn");
                          if (selectedLang) {
                              selectedLang.parentNode.classList.add("theme-selected");
                          }

                          // The path to the root, taking the current
                          // language into account.
                          let full_path_to_root = "https://google.github.io/comprehensive-rust/";
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "print.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                              if (lang.id == "en") {
                                  lang.href = `${full_path_to_root}${path}`;
                              } else {
                                  lang.href = `${full_path_to_root}${lang.id}/${path}`;
                              }
                          }
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/google/comprehensive-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="comprehensive-rust--‡¶è-‡¶∏‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ"><a class="header" href="#comprehensive-rust--‡¶è-‡¶∏‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ">Comprehensive Rust ü¶Ä ‡¶è ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ</a></h1>
<p><a href="https://github.com/google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain"><img src="https://img.shields.io/github/actions/workflow/status/google/comprehensive-rust/build.yml?style=flat-square" alt="Build workflow" /></a>‡¶ï‡¶∞‡ßç‡¶Æ‡¶™‡ßç‡¶∞‡¶¨‡¶æ‡¶π ‡¶§‡ßà‡¶∞‡¶ø<a href="https://github.com/google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain"><img src="https://img.shields.io/github/actions/workflow/status/google/comprehensive-rust/build.yml?style=flat-square" alt="Build workflow" /></a>
<a href="https://github.com/google/comprehensive-rust/graphs/contributors"><img src="https://img.shields.io/github/contributors/google/comprehensive-rust?style=flat-square" alt="GitHub contributors" /></a>GitHub ‡¶Ö‡¶¨‡¶¶‡¶æ‡¶®‡¶ï‡¶æ‡¶∞‡ßÄ<a href="https://github.com/google/comprehensive-rust/graphs/contributors"><img src="https://img.shields.io/github/contributors/google/comprehensive-rust?style=flat-square" alt="GitHub contributors" /></a>
<a href="https://github.com/google/comprehensive-rust/stargazers"><img src="https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-square" alt="GitHub stars" /></a>GitHub stars<a href="https://github.com/google/comprehensive-rust/stargazers"><img src="https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-square" alt="GitHub stars" /></a></p>
<p>This is a free Rust course developed by the Android team at Google. The course covers
the full spectrum of Rust, from basic syntax to advanced topics like generics
and error handling.</p>
<p>‡¶ï‡ßã‡¶∞‡ßç‡¶∏‡ßá‡¶∞ ‡¶≤‡¶ï‡ßç‡¶∑‡ßç‡¶Ø ‡¶π‡¶≤ ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶∞‡¶æ‡¶∏‡ßç‡¶ü ‡¶∂‡ßá‡¶ñ‡¶æ‡¶®‡ßã‡•§ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶ß‡¶∞‡ßá ‡¶®‡¶ø‡¶≤‡¶æ‡¶Æ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø‡¶õ‡ßÅ‡¶á ‡¶ú‡¶æ‡¶®‡ßá‡¶® ‡¶®‡¶æ
‡¶∞‡¶æ‡¶∏‡ßç‡¶ü ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá ‡¶è‡¶¨‡¶Ç ‡¶Ü‡¶∂‡¶æ ‡¶ï‡¶∞‡¶ø‡¶É</p>
<ul>
<li>‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶∞‡¶æ‡¶∏‡ßç‡¶ü ‡¶∏‡¶ø‡¶®‡¶ü‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶∏ ‡¶è‡¶¨‡¶Ç ‡¶≠‡¶æ‡¶∑‡¶æ ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶¨‡ßã‡¶ù‡¶æ‡ßü‡•§</li>
<li>‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶¨‡¶ø‡¶¶‡ßç‡¶Ø‡¶Æ‡¶æ‡¶® ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶∏‡¶Ç‡¶∂‡ßã‡¶ß‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶è‡¶¨‡¶Ç ‡¶∞‡¶æ‡¶∏‡ßç‡¶ü ‡¶è ‡¶®‡¶§‡ßÅ‡¶® ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ ‡¶≤‡¶ø‡¶ñ‡¶§‡ßá ‡¶∏‡¶ï‡ßç‡¶∑‡¶Æ ‡¶ï‡¶∞‡ßá‡•§</li>
<li>‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶∞‡¶æ‡¶∏‡ßç‡¶ü ‡¶á‡¶°‡¶ø‡ßü‡¶Æ‡¶∏ ‡¶¶‡ßá‡¶ñ‡¶æ‡ßü‡•§</li>
</ul>
<p>We call the first three course days Rust Fundamentals.</p>
<p>Building on this, you‚Äôre invited to dive into one or more specialized topics:</p>
<ul>
<li><a href="android.html">Android</a>: a half-day course on using Rust for Android platform
development (AOSP). This includes interoperability with C, C++, and Java.</li>
<li><a href="bare-metal.html">Bare-metal</a>: a whole-day class on using Rust for bare-metal
(embedded) development. Both microcontrollers and application processors are
covered.</li>
<li><a href="concurrency.html">Concurrency</a>: a whole-day class on concurrency in Rust. We
cover both classical concurrency (preemptively scheduling using threads and
mutexes) and async/await concurrency (cooperative multitasking using
futures).</li>
</ul>
<h2 id="non-goals"><a class="header" href="#non-goals">Non-Goals</a></h2>
<p>‡¶∞‡¶æ‡¶∏‡ßç‡¶ü ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡ßÉ‡¶π‡ßé ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ‡¶ø‡¶Ç ‡¶≤‡ßç‡¶Ø‡¶æ‡¶Ç‡¶ó‡ßÅ‡ßü‡ßá‡¶ú ‡¶è‡¶¨‡¶Ç ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶ï‡¶Ø‡¶º‡ßá‡¶ï ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶è‡¶ü‡¶ø‡¶ï‡ßá ‡¶ï‡¶≠‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶ï‡ßç‡¶∑‡¶Æ ‡¶π‡¶¨ ‡¶®‡¶æ‡•§
‡¶è‡¶á ‡¶ï‡ßã‡¶∞‡ßç‡¶∏‡ßá‡¶∞ ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶Ö-‡¶≤‡¶ï‡ßç‡¶∑‡ßç‡¶Ø ‡¶π‡¶≤‡¶É</p>
<ul>
<li>Learning how to develop macros: please see <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Chapter 19.5 in the Rust
Book</a> and <a href="https://doc.rust-lang.org/rust-by-example/macros.html">Rust by
Example</a> instead.</li>
</ul>
<p>##‡¶ß‡ßÉ‡¶∑‡ßç‡¶ü‡¶§‡¶æ‡¶∏‡¶Æ‡ßÇ‡¶π</p>
<p>The course assumes that you already know how to program. Rust is a statically-typed
language and we will sometimes make comparisons with C and C++ to better
explain or contrast the Rust approach.</p>
<p>If you know how to program in a dynamically-typed language such as Python or
JavaScript, then you will be able to follow along just fine too.</p>
<details>
<p>‡¶è‡¶ü‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø  <em>speaker note</em> ‡¶è‡¶∞ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡•§ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶Ö‡¶§‡¶ø‡¶∞‡¶ø‡¶ï‡ßç‡¶§ ‡¶§‡¶•‡ßç‡¶Ø ‡¶∏‡ßç‡¶≤‡¶æ‡¶á‡¶°‡ßá ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶§‡ßá ‡¶è‡¶á‡¶ó‡ßÅ‡¶≤‡ßã
‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßã‡•§ ‡¶è‡¶ü‡¶ø ‡¶™‡ßç‡¶∞‡¶ß‡¶æ‡¶® ‡¶™‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá ‡¶Ø‡¶æ ‡¶™‡ßç‡¶∞‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶ï‡ßá‡¶∞ ‡¶â‡¶ö‡¶ø‡¶§
‡¶ï‡¶≠‡¶æ‡¶∞‡ßá‡¶∞ ‡¶™‡¶æ‡¶∂‡¶æ‡¶™‡¶æ‡¶∂‡¶ø ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏‡ßá ‡¶Ü‡¶∏‡¶æ ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡ßá‡¶ì‡ßü‡¶æ‡•§</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶ï‡ßã‡¶∞‡¶∏-‡¶ö‡¶æ‡¶≤‡ßÅ-‡¶ï‡¶∞‡¶æ-‡¶π‡¶ö‡¶õ‡ßá"><a class="header" href="#‡¶ï‡ßã‡¶∞‡¶∏-‡¶ö‡¶æ‡¶≤‡ßÅ-‡¶ï‡¶∞‡¶æ-‡¶π‡¶ö‡¶õ‡ßá">‡¶ï‡ßã‡¶∞‡ßç‡¶∏ ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá</a></h1>
<blockquote>
<p>‡¶è‡¶á ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ‡¶ü‡¶ø ‡¶ï‡ßã‡¶∞‡ßç‡¶∏ ‡¶™‡ßç‡¶∞‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶ï‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡•§</p>
</blockquote>
<p>‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡ßã‡¶∞‡ßç‡¶∏‡¶ü‡¶ø ‡¶ö‡¶æ‡¶≤‡¶æ‡¶ö‡ßç‡¶õ‡¶ø ‡¶∏‡ßá ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶™‡¶ü‡¶≠‡ßÇ‡¶Æ‡¶ø‡¶∞ ‡¶ó‡ßÅ‡¶ó‡¶≤‡ßá ‡¶Ö‡¶≠‡ßç‡¶Ø‡¶®‡ßç‡¶§‡¶∞‡ßÄ‡¶£‡¶≠‡¶æ‡¶¨‡ßá 
‡¶§‡¶•‡ßç‡¶Ø ‡¶∞‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§</p>
<p>‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡ßã‡¶∞‡ßç‡¶∏ ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã‡¶∞ ‡¶Ü‡¶ó‡ßá, ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ö‡¶æ‡¶á‡¶¨‡ßá‡¶®:</p>
<ol>
<li>
<p>‡¶ï‡ßã‡¶∞‡ßç‡¶∏‡ßá‡¶∞ ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶®‡¶ø‡¶ú‡ßá‡¶ï‡ßá ‡¶™‡¶∞‡¶ø‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶∏‡ßç‡¶™‡¶ø‡¶ï‡¶æ‡¶∞ ‡¶®‡ßã‡¶ü ‡¶Ö‡¶®‡ßç‡¶§‡¶∞‡ßç‡¶≠‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡ßá‡¶õ‡¶ø
‡¶Æ‡ßÇ‡¶≤ ‡¶™‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶π‡¶æ‡¶á‡¶≤‡¶æ‡¶á‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø (‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶∞‡¶ì ‡¶∏‡ßç‡¶™‡¶ø‡¶ï‡¶æ‡¶∞ ‡¶®‡ßã‡¶ü ‡¶Ö‡¶¨‡¶¶‡¶æ‡¶® ‡¶∞‡ßá‡¶ñ‡ßá ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶ï‡¶∞‡ßÅ‡¶®
!)‡•§ ‡¶â‡¶™‡¶∏‡ßç‡¶•‡¶æ‡¶™‡¶® ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º, ‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡ßç‡¶™‡¶ø‡¶ï‡¶æ‡¶∞ ‡¶®‡ßã‡¶ü ‡¶™‡¶™‡¶Ü‡¶™ ‡¶è ‡¶ñ‡ßÅ‡¶≤‡¶§‡ßá ‡¶≠‡ßÅ‡¶≤‡¶¨‡ßá‡¶®
‡¶®‡¶æ (‚Äú‡¶∏‡ßç‡¶™‡ßÄ‡¶ï‡¶æ‡¶∞ ‡¶®‡ßã‡¶ü‡¶∏‚Äù ‡¶è‡¶∞ ‡¶™‡¶æ‡¶∂‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶õ‡ßã‡¶ü ‡¶§‡ßÄ‡¶∞ ‡¶∏‡¶π ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®)‡•§ ‡¶è‡¶á ‡¶™‡¶•‡ßá
‡¶ï‡ßç‡¶≤‡¶æ‡¶∏‡ßá ‡¶â‡¶™‡¶∏‡ßç‡¶•‡¶æ‡¶™‡¶® ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡¶æ‡¶õ‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶™‡¶∞‡¶ø‡¶∑‡ßç‡¶ï‡¶æ‡¶∞ ‡¶™‡¶∞‡ßç‡¶¶‡¶æ ‡¶∞‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§</p>
</li>
<li>
<p>‡¶§‡¶æ‡¶∞‡¶ø‡¶ñ‡ßá‡¶∞ ‡¶â‡¶™‡¶∞ ‡¶∏‡¶ø‡¶¶‡ßç‡¶ß‡¶æ‡¶®‡ßç‡¶§‡•§‡¶Ø‡ßá‡¶π‡ßá‡¶§‡ßÅ ‡¶ï‡ßã‡¶∞‡ßç‡¶∏‡¶ü‡¶ø ‡¶ï‡¶Æ‡¶™‡¶ï‡ßç‡¶∑‡ßá ‡¶§‡¶ø‡¶® ‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¶‡¶ø‡¶® ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶®‡ßá‡¶Ø‡¶º, ‡¶§‡¶æ‡¶á ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶∏‡ßÅ‡¶™‡¶æ‡¶∞‡¶ø‡¶∂ ‡¶ï‡¶∞‡¶õ‡¶ø
‡¶¶‡ßÅ‡¶á ‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π ‡¶â‡¶™‡¶∞ ‡¶¶‡¶ø‡¶® ‡¶®‡¶ø‡¶∞‡ßç‡¶ß‡¶æ‡¶∞‡¶£ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ ‡¶è‡¶Æ‡¶®‡¶ü‡¶æ‡¶á ‡¶ú‡¶æ‡¶®‡¶ø‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡¶® ‡¶ï‡ßã‡¶∞‡ßç‡¶∏‡ßá ‡¶Ö‡¶Ç‡¶∂‡¶ó‡ßç‡¶∞‡¶π‡¶£‡¶ï‡¶æ‡¶∞‡ßÄ‡¶∞‡¶æ ‡¶Ø‡ßá
‡¶§‡¶æ‡¶∞‡¶æ ‡¶ï‡ßã‡¶∞‡ßç‡¶∏‡ßá ‡¶´‡¶æ‡¶Å‡¶ï ‡¶•‡¶æ‡¶ï‡¶æ ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï ‡¶¨‡¶≤‡ßá ‡¶Æ‡¶®‡ßá ‡¶ï‡¶∞‡ßá ‡¶ï‡¶æ‡¶∞‡¶£ ‡¶è‡¶ü‡¶ø ‡¶§‡¶æ‡¶¶‡ßá‡¶∞ ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶§‡¶æ ‡¶ï‡¶∞‡ßá
‡¶Ø‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶§ ‡¶§‡¶•‡ßç‡¶Ø ‡¶§‡¶æ‡¶¶‡ßá‡¶∞ ‡¶¶‡ßá‡¶ì‡ßü‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§</p>
</li>
<li>
<p>‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶ï‡ßç‡¶§‡¶ø‡¶ó‡¶§ ‡¶Ö‡¶Ç‡¶∂‡¶ó‡ßç‡¶∞‡¶π‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ø‡¶•‡ßá‡¶∑‡ßç‡¶ü ‡¶¨‡¶°‡¶º ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∞‡ßÅ‡¶Æ ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßÅ‡¶®‡•§ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶∏‡ßÅ‡¶™‡¶æ‡¶∞‡¶ø‡¶∂ ‡¶ï‡¶∞‡¶ø
15-25 ‡¶ú‡¶®‡ßá‡¶∞ ‡¶∏‡¶æ‡¶á‡¶ú‡ßá‡¶∞ ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏‡•§ ‡¶è‡¶ü‡¶ø ‡¶Ø‡¶•‡ßá‡¶∑‡ßç‡¶ü ‡¶õ‡ßã‡¶ü ‡¶Ø‡ßá ‡¶Æ‡¶æ‡¶®‡ßÅ‡¶∑ ‡¶Ü‡¶∞‡¶æ‡¶Æ‡¶¶‡¶æ‡¶Ø‡¶º‡¶ï ‡¶Ö‡¶®‡ßÅ‡¶≠‡¶¨ ‡¶ï‡¶∞‡ßá
‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶ú‡¶ø‡¶ú‡ßç‡¶û‡¶æ‡¶∏‡¶æ ‡¶ï‡¶∞‡¶§‡ßá‚Äî ‡¶è‡¶ü‡¶ø ‡¶Ø‡¶•‡ßá‡¶∑‡ßç‡¶ü ‡¶õ‡ßã‡¶ü ‡¶Ø‡ßá ‡¶è‡¶ï‡¶ú‡¶® ‡¶™‡ßç‡¶∞‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶ï ‡¶è‡¶∞ ‡¶∏‡¶Æ‡ßü ‡¶•‡¶æ‡¶ï‡¶¨‡ßá
‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡ßá‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡•§ ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶Ø‡ßá ‡¶ò‡¶∞‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶¨‡¶Ç ‡¶õ‡¶æ‡¶§‡ßç‡¶∞‡¶¶‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø <em>desks</em> ‡¶Ü‡¶õ‡ßá
: ‡¶Ü‡¶™‡¶®‡¶æ‡ßç‡¶¶‡ßá‡¶∞ ‡¶∏‡¶ï‡¶≤‡¶ï‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶¶‡ßá‡¶∞ ‡¶≤‡ßç‡¶Ø‡¶æ‡¶™‡¶ü‡¶™‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶¨‡¶∏‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶ï‡ßç‡¶∑‡¶Æ ‡¶π‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§
‡¶¨‡¶ø‡¶∂‡ßá‡¶∑ ‡¶ï‡¶∞‡ßá, ‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶ï‡¶ú‡¶® ‡¶™‡ßç‡¶∞‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶ï ‡¶π‡¶ø‡¶∏‡¶æ‡¶¨‡ßá ‡¶™‡ßç‡¶∞‡¶ö‡ßÅ‡¶∞ ‡¶≤‡¶æ‡¶á‡¶≠-‡¶ï‡ßã‡¶°‡¶ø‡¶Ç ‡¶ï‡¶∞‡¶¨‡ßá‡¶®, ‡¶§‡¶æ‡¶á lecturn
‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶ñ‡ßÅ‡¶¨ ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï ‡¶π‡¶¨‡ßá ‡¶®‡¶æ‡•§</p>
</li>
<li>
<p>‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡ßã‡¶∞‡ßç‡¶∏‡ßá‡¶∞ ‡¶¶‡¶ø‡¶®, ‡¶ú‡¶ø‡¶®‡¶ø‡¶∏‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶è‡¶ï‡¶ü‡ßÅ ‡¶§‡¶æ‡¶°‡¶º‡¶æ‡¶§‡¶æ‡¶°‡¶º‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®
‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶≤‡ßç‡¶Ø‡¶æ‡¶™‡¶ü‡¶™‡ßá ‡¶ö‡¶≤‡¶Æ‡¶æ‡¶® <code>mdbook serve</code> ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø ‡¶â‡¶™‡¶∏‡ßç‡¶•‡¶æ‡¶™‡¶® ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂ ‡¶¶‡¶ø‡¶á
(‡¶¶‡ßá‡¶ñ‡ßÅ‡¶® [‡¶á‡¶®‡¶∏‡ßç‡¶ü‡¶≤‡ßá‡¶∂‡¶® ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶æ‡¶¨‡¶≤‡ßÄ] <a href="https://github.com/google/comprehensive-rust#building">3</a>)‡•§ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶∏‡¶æ‡¶•‡ßá ‡¶è‡¶ü‡¶ø ‡¶ï‡ßã‡¶®‡¶ì ‡¶≤‡ßç‡¶Ø‡¶æ‡¶ó ‡¶õ‡¶æ‡¶°‡¶º‡¶æ‡¶á ‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶§‡ßç‡¶§‡¶Æ ‡¶ï‡¶æ‡¶∞‡ßç‡¶Ø‡¶ï‡ßç‡¶∑‡¶Æ‡¶§‡¶æ ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡ßá‡•§
‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶≤‡ßç‡¶Ø‡¶æ‡¶™‡¶ü‡¶™ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶≤‡ßá ‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¨‡¶æ ‡¶ï‡ßã‡¶∞‡ßç‡¶∏‡ßá‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶ü‡¶æ‡¶á‡¶™ ‡¶≠‡ßÅ‡¶≤ ‡¶†‡¶ø‡¶ï ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá‡¶®
‡¶Ö‡¶Ç‡¶∂‡¶ó‡ßç‡¶∞‡¶π‡¶£‡¶ï‡¶æ‡¶∞‡ßÄ‡¶∞‡¶æ ‡¶§‡¶æ‡¶¶‡ßá‡¶∞ ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡ßá‡•§</p>
</li>
<li>
<p>‡¶§‡¶æ‡¶¶‡ßá‡¶∞‡¶ï‡ßá ‡¶è‡¶ï‡¶æ ‡¶è‡¶ï‡¶æ ‡¶¨‡¶æ ‡¶õ‡ßã‡¶ü ‡¶¶‡¶≤‡ßá ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®‡ßá‡¶∞ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶¶‡¶ø‡¶®‡•§
‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£‡¶§ ‡¶∏‡¶ï‡¶æ‡¶≤‡ßá ‡¶è‡¶¨‡¶Ç ‡¶¨‡¶ø‡¶ï‡ßá‡¶≤‡ßá ‡¶¨‡ßç‡¶Ø‡¶æ‡¶Ø‡¶º‡¶æ‡¶Æ‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø 30-45 ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü ‡¶¨‡ßç‡¶Ø‡¶Ø‡¶º ‡¶ï‡¶∞‡¶ø (‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶™‡¶∞‡ßç‡¶Ø‡¶æ‡¶≤‡ßã‡¶ö‡¶®‡¶æ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶∏‡¶π)‡•§
‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶®
‡¶≤‡ßã‡¶ï‡ßá‡¶¶‡ßá‡¶∞ ‡¶ú‡¶ø‡¶ú‡ßç‡¶û‡¶æ‡¶∏‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶§‡¶æ‡¶∞‡¶æ ‡¶Ü‡¶ü‡¶ï‡ßá ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡¶æ ‡¶¨‡¶æ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶® ‡¶è‡¶Æ‡¶® ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡¶æ‡•§ ‡¶Ø‡¶ñ‡¶®
‡¶Ü‡¶™‡¶®‡¶ø ‡¶¶‡ßá‡¶ñ‡¶§‡ßá ‡¶™‡¶æ‡¶ö‡ßç‡¶õ‡ßá‡¶® ‡¶Ø‡ßá ‡¶¨‡ßá‡¶∂ ‡¶ï‡¶Ø‡¶º‡ßá‡¶ï‡¶ú‡¶®‡ßá‡¶∞ ‡¶è‡¶ï‡¶á ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶∞‡¶Ø‡¶º‡ßá‡¶õ‡ßá, ‡¶è‡¶ü‡¶ø‡¶ï‡ßá ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏‡ßá ‡¶ï‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶®
‡¶è‡¶¨‡¶Ç ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® ‡¶Ö‡¶´‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®, ‡¶Ø‡ßá‡¶Æ‡¶®, ‡¶™‡ßç‡¶∞‡¶æ‡¶∏‡¶ô‡ßç‡¶ó‡¶ø‡¶ï ‡¶§‡¶•‡ßç‡¶Ø‡¶ü‡¶ø  ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶æ‡¶∞‡ßç‡¶° ‡¶≤‡¶æ‡¶á‡¶¨‡ßç‡¶∞‡ßá‡¶∞‡¶ø‡¶§‡ßá  ‡¶ï‡ßã‡¶•‡¶æ‡¶Ø‡¶º ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá ‡¶§‡¶æ ‡¶≤‡ßã‡¶ï‡ßá‡¶¶‡ßá‡¶∞ ‡¶¶‡ßá‡¶ñ‡¶ø‡¶Ø‡¶º‡ßá
‡¶¶‡¶ø‡¶®‡•§</p>
</li>
</ol>
<p>‡¶è‡¶á‡¶∏‡¶¨ ‡¶Ø‡ßá, ‡¶ï‡ßã‡¶∞‡ßç‡¶∏‡¶ü‡¶ø ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶∂‡ßÅ‡¶≠‡¶ï‡¶æ‡¶Æ‡¶®‡¶æ‡•§ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶Ü‡¶∂‡¶æ ‡¶ï‡¶∞‡¶ø ‡¶è‡¶ü‡¶æ ‡¶§‡¶§‡¶ü‡¶æ‡¶á ‡¶Æ‡¶ú‡¶æ‡¶∞ ‡¶π‡¶¨‡ßá
‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ø‡¶§‡¶ü‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡¶ø‡¶≤‡ßã ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶ï‡¶æ‡¶õ‡ßá‡•§</p>
<p>‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá [‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶™‡ßç‡¶∞‡¶¶‡¶æ‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®] <a href="https://github.com/google/comprehensive-rust/discussions/86">1</a> ‡¶™‡¶∞‡ßá ‡¶Ø‡¶æ‡¶§‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶â‡¶®‡ßç‡¶®‡¶§‡¶ø ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø‡ß∑
‡¶Ö‡¶¨‡¶∂‡ßç‡¶Ø‡¶á ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶ï‡ßÄ ‡¶≠‡¶æ‡¶≤ ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá‡¶õ‡ßá ‡¶è‡¶¨‡¶Ç ‡¶â‡¶§‡ßç‡¶§‡¶Æ ‡¶ï‡ßÄ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶Ø‡ßá‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá ‡¶§‡¶æ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶∂‡ßÅ‡¶®‡¶§‡ßá ‡¶ö‡¶æ‡¶á
‡•§‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶õ‡¶æ‡¶§‡ßç‡¶∞‡¶¶‡ßá‡¶∞‡¶ì [‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá] ‡¶ñ‡ßÅ‡¶¨ ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§ ‡¶ú‡¶æ‡¶®‡¶æ‡¶á<a href="https://github.com/google/comprehensive-rust/discussions/100">2</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶ï‡ßã‡¶∞‡¶∏-‡¶è‡¶∞-‡¶ó‡¶†‡¶®"><a class="header" href="#‡¶ï‡ßã‡¶∞‡¶∏-‡¶è‡¶∞-‡¶ó‡¶†‡¶®">‡¶ï‡ßã‡¶∞‡ßç‡¶∏ ‡¶è‡¶∞ ‡¶ó‡¶†‡¶®</a></h1>
<blockquote>
<p>‡¶è‡¶á ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ‡¶ü‡¶ø ‡¶ï‡ßã‡¶∞‡ßç‡¶∏ ‡¶™‡ßç‡¶∞‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶ï‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡•§</p>
</blockquote>
<p>‡¶ï‡ßã‡¶∞‡ßç‡¶∏‡¶ü‡¶ø ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ó‡¶§‡¶ø‡¶∞ ‡¶è‡¶¨‡¶Ç ‡¶Ö‡¶®‡ßá‡¶ï ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶ï‡¶≠‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡¶É</p>
<ul>
<li>‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶¶‡¶ø‡¶®‡¶É ‡¶™‡ßç‡¶∞‡¶æ‡¶•‡¶Æ‡¶ø‡¶ï ‡¶∞‡¶æ‡¶∏‡ßç‡¶ü, ‡¶Æ‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ‡¶®‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶ß‡¶æ‡¶∞ ‡¶™‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶ï‡•§</li>
<li>‡¶¶‡ßç‡¶¨‡¶ø‡¶§‡ßÄ‡ßü ‡¶¶‡¶ø‡¶®‡¶É ‡¶Ø‡ßå‡¶ó‡¶ø‡¶ï ‡¶°‡ßá‡¶ü‡¶æ ‡¶ü‡¶æ‡¶á‡¶™‡¶∏, ‡¶™‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ö‡¶ø‡¶Ç, ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶æ‡¶∞‡ßç‡¶° ‡¶≤‡¶æ‡¶á‡¶¨‡ßç‡¶∞‡ßá‡¶∞‡¶ø‡•§</li>
<li>‡¶§‡ßÉ‡¶§‡ßÄ‡ßü ‡¶¶‡¶ø‡¶®‡¶É Traits ‡¶è‡¶¨‡¶Ç Generics, ‡¶è‡¶∞‡¶∞ ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶ø‡¶Ç, ‡¶ü‡ßá‡¶∏‡ßç‡¶ü‡¶ø‡¶Ç, ‡¶Ö‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶ ‡¶∞‡¶æ‡¶∏‡ßç‡¶ü‡•§</li>
</ul>
<h2 id="‡¶ó‡¶≠‡ßÄ‡¶∞-‡¶°‡ßÅ‡¶¨"><a class="header" href="#‡¶ó‡¶≠‡ßÄ‡¶∞-‡¶°‡ßÅ‡¶¨">‡¶ó‡¶≠‡ßÄ‡¶∞ ‡¶°‡ßÅ‡¶¨</a></h2>
<p>‡¶∞‡¶æ‡¶∏‡ßç‡¶ü ‡¶´‡¶æ‡¶®‡ßç‡¶°‡¶æ‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡¶æ‡¶≤‡ßá‡¶∞ ‡ß© ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏ ‡¶õ‡¶æ‡¶°‡¶º‡¶æ‡¶ì, ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶Ü‡¶∞‡¶ì ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶¨‡¶ø‡¶∂‡ßá‡¶∑ ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º 
‡¶ï‡¶≠‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶ø‡¶É</p>
<h3 id="android"><a class="header" href="#android">Android</a></h3>
<p>The <a href="android.html">Android Deep Dive</a> is a half-day course on using Rust for
Android platform development. This includes interoperability with C, C++, and
Java.</p>
<p>‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø [AOSP ‡¶ö‡ßá‡¶ï‡¶Ü‡¶â‡¶ü] ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶® ‡¶π‡¶¨‡ßá <a href="https://source.android.com/docs/setup/download/downloading">1</a>‡ß∑ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ö‡ßá‡¶ï‡¶Ü‡¶â‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶® [‡¶ï‡ßã‡¶∞‡ßç‡¶∏
‡¶∞‡¶ø‡¶™‡ßã‡¶ú‡¶ø‡¶ü‡¶∞‡¶ø <a href="https://github.com/google/comprehensive-rust">2</a> ‡¶è‡¶ï‡¶á ‡¶Æ‡ßá‡¶∂‡¶ø‡¶®‡ßá ‡¶è‡¶¨‡¶Ç <code>src/android/</code> ‡¶°‡¶ø‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶∞‡¶ø ‡¶∏‡¶∞‡¶æ‡¶®
‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ AOSP ‡¶ö‡ßá‡¶ï‡¶Ü‡¶â‡¶ü‡ßá‡¶∞ ‡¶Æ‡ßÇ‡¶≤ ‡¶°‡¶ø‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶∞‡¶ø‡¶§‡ßá‡•§ ‡¶è‡¶ü‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡ßç‡¶∞‡¶Ø‡¶º‡ßá‡¶° ‡¶¨‡¶ø‡¶≤‡ßç‡¶° ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡¶¨‡ßá
<code>src/android/</code>-‡¶è <code>Android.bp</code> ‡¶´‡¶æ‡¶á‡¶≤‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®‡•§</p>
<p>‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶Ø‡ßá <code>adb ‡¶∏‡¶ø‡¶ô‡ßç‡¶ï</code> ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶è‡¶Æ‡ßÅ‡¶≤‡ßá‡¶ü‡¶∞ ‡¶¨‡¶æ ‡¶¨‡¶æ‡¶∏‡ßç‡¶§‡¶¨ ‡¶°‡¶ø‡¶≠‡¶æ‡¶á‡¶∏‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá ‡¶è‡¶¨‡¶Ç Android ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡¶ó‡ßÅ‡¶≤‡ßã ‡¶™‡ßç‡¶∞‡¶ø-‡¶¨‡¶ø‡¶≤‡ßç‡¶° ‡¶ï‡¶∞‡ßÅ‡¶®
<code>src/android/build_all.sh</code> ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡•§‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡ßç‡¶ü ‡¶™‡¶°‡¶º‡ßÅ‡¶®
‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶¶‡ßá‡¶ñ‡¶§‡ßá ‡¶Ø‡ßá‡¶ó‡ßÅ‡¶≤‡ßã ‡¶è‡¶ü‡¶ø ‡¶ö‡¶æ‡¶≤‡¶æ‡¶Ø‡¶º ‡¶è‡¶¨‡¶Ç ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶Ø‡ßá ‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ø‡¶ñ‡¶® ‡¶§‡¶æ‡¶¶‡ßá‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡¶® ‡¶§‡¶ñ‡¶® ‡¶§‡¶æ‡¶∞‡¶æ ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá‡•§</p>
<h3 id="bare-metal"><a class="header" href="#bare-metal">Bare-Metal</a></h3>
<p><a href="bare-metal.html">Bare-Metal Deep Dive</a>: Rust ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá bare-metal (embedded) ‡¶â‡¶®‡ßç‡¶®‡¶Ø‡¶º‡¶® ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø 
‡¶è‡¶ï‡¶ü‡¶ø ‡¶™‡ßÅ‡¶∞‡ßã ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏‡•§ ‡¶Æ‡¶æ‡¶á‡¶ï‡ßç‡¶∞‡ßã‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤‡¶æ‡¶∞ ‡¶è‡¶¨‡¶Ç ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏‡¶∞ ‡¶â‡¶≠‡¶Ø‡¶º‡¶á 
‡¶ï‡¶≠‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§</p>
<p>‡¶Æ‡¶æ‡¶á‡¶ï‡ßç‡¶∞‡ßã‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤‡¶æ‡¶∞ ‡¶Ö‡¶Ç‡¶∂‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø, ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶∏‡¶Æ‡¶Ø‡¶º‡ßá‡¶∞ ‡¶Ü‡¶ó‡ßá ‡¶ï‡¶ø‡¶®‡¶§‡ßá ‡¶π‡¶¨‡ßá <a href="https://microbit.org/">BBC
micro:bit</a> v2 ‡¶â‡¶®‡ßç‡¶®‡¶Ø‡¶º‡¶® ‡¶¨‡ßã‡¶∞‡ßç‡¶°‡•§ ‡¶∏‡¶¨‡¶æ‡¶á‡¶ï‡ßá <a href="bare-metal.html">welcome
page</a> ‡¶è ‡¶¨‡¶∞‡ßç‡¶£‡¶ø‡¶§ ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ú‡¶ó‡ßÅ‡¶≤‡¶ø‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶á‡¶®‡¶∏‡ßç‡¶ü‡¶≤ ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§</p>
<h3 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h3>
<p>The <a href="concurrency.html">Concurrency Deep Dive</a> ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏‡¶ø‡¶ï‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶∞ ‡¶â‡¶™‡¶∞ ‡¶™‡ßÅ‡¶∞‡ßã ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏
‡¶∏‡ßá‡¶á‡¶∏‡¶æ‡¶•‡ßá <code>async</code>/<code>await</code> concurrency.</p>
<p>‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶® ‡¶π‡¶¨‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶®‡¶§‡ßÅ‡¶® ‡¶ï‡ßç‡¶∞‡ßá‡¶ü ‡¶∏‡ßá‡¶ü ‡¶Ü‡¶™ ‡¶è‡¶¨‡¶Ç ‡¶®‡¶ø‡¶∞‡ßç‡¶≠‡¶∞‡¶§‡¶æ ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§
‡¶π‡¶ì‡ßü‡¶æ‡•§ ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶™‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø <code>src/main.rs</code>-‡¶è ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡¶ó‡ßÅ‡¶≤‡ßã ‡¶ï‡¶™‡¶ø/‡¶™‡ßá‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶®:</p>
<pre><code class="language-shell">cargo init concurrency
cd concurrency
cargo add tokio --features full
cargo run
</code></pre>
<h2 id="‡¶¨‡¶ø‡¶®‡¶Ø‡¶æ‡¶∏"><a class="header" href="#‡¶¨‡¶ø‡¶®‡¶Ø‡¶æ‡¶∏">‡¶¨‡¶ø‡¶®‡ßç‡¶Ø‡¶æ‡¶∏</a></h2>
<p>‡¶ï‡ßã‡¶∞‡ßç‡¶∏‡¶ü‡¶ø ‡¶ñ‡ßÅ‡¶¨ ‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶ø‡¶≠ ‡¶π‡¶§‡ßá ‡¶¨‡ßã‡¶ù‡¶æ‡¶®‡ßã ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá ‡¶è‡¶¨‡¶Ç ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶è‡¶ü‡¶ø ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡ßÅ‡¶™‡¶æ‡¶∞‡¶ø‡¶∂ ‡¶ï‡¶∞‡¶õ‡¶ø ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡¶ó‡ßÅ‡¶≤‡ßã
Rust ‡¶è‡¶∞ ‡¶Ö‡¶®‡ßç‡¶¨‡ßá‡¶∑‡¶£ ‡¶ö‡¶æ‡¶≤‡¶®‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶ï!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶ï‡ßÄ‡¶¨‡ßã‡¶∞‡¶°-‡¶∂‡¶∞‡¶ü‡¶ï‡¶æ‡¶ü"><a class="header" href="#‡¶ï‡ßÄ‡¶¨‡ßã‡¶∞‡¶°-‡¶∂‡¶∞‡¶ü‡¶ï‡¶æ‡¶ü">‡¶ï‡ßÄ‡¶¨‡ßã‡¶∞‡ßç‡¶° ‡¶∂‡¶∞‡ßç‡¶ü‡¶ï‡¶æ‡¶ü</a></h1>
<p>mdBook-‡¶è ‡¶¨‡ßá‡¶∂ ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶ï‡ßÄ‡¶¨‡ßã‡¶∞‡ßç‡¶° ‡¶∂‡¶∞‡ßç‡¶ü‡¶ï‡¶æ‡¶ü ‡¶∞‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡¶É</p>
<ul>
<li><kbd>Arrow-Left</kbd>: Navigate to the previous page.</li>
<li><kbd>Arrow-Right</kbd>: Navigate to the next page.</li>
<li><kbd>Ctrl + Enter</kbd>: Execute the code sample that has focus.</li>
<li><kbd>s</kbd>: Activate the search bar.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>#‡¶Ö‡¶®‡ßÅ‡¶¨‡¶æ‡¶¶</p>
<p>‡¶ï‡ßã‡¶∞‡ßç‡¶∏‡¶ü‡¶ø ‡¶¨‡¶ø‡¶∏‡ßç‡¶Æ‡¶Ø‡¶º‡¶ï‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡ßá‡¶ü ‡¶¶‡ßç‡¶¨‡¶æ‡¶∞‡¶æ ‡¶Ö‡¶®‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶Ø ‡¶≠‡¶æ‡¶∑‡¶æ‡¶Ø‡¶º ‡¶Ö‡¶®‡ßÅ‡¶¨‡¶æ‡¶¶ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá
‡¶∏‡ßç‡¶¨‡ßá‡¶ö‡ßç‡¶õ‡¶æ‡¶∏‡ßá‡¶¨‡¶ï:</p>
<ul>
<li><a href="https://google.github.io/comprehensive-rust/pt-BR/">Brazilian Portuguese</a> by <a href="https://github.com/rastringer">@rastringer</a>, <a href="https://github.com/hugojacob">@hugojacob</a>, <a href="https://github.com/joaovicmendes">@joaovicmendes</a> and <a href="https://github.com/henrif75">@henrif75</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/ko/">Korean</a> by <a href="https://github.com/keispace">@keispace</a>, <a href="https://github.com/jiyongp">@jiyongp</a> and <a href="https://github.com/jooyunghan">@jooyunghan</a>.</li>
</ul>
<p>‡¶≠‡¶æ‡¶∑‡¶æ‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶∏‡ßç‡¶Ø‡ßÅ‡¶á‡¶ö ‡¶ï‡¶∞‡¶§‡ßá ‡¶â‡¶™‡¶∞‡ßá‡¶∞-‡¶°‡¶æ‡¶® ‡¶ï‡ßã‡¶£‡ßá ‡¶≠‡¶æ‡¶∑‡¶æ ‡¶ö‡¶Ø‡¶º‡¶®‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§</p>
<h2 id="incomplete-translations"><a class="header" href="#incomplete-translations">Incomplete Translations</a></h2>
<p>There is a large number of in-progress translations. We link to the most
recently updated translations:</p>
<ul>
<li><a href="index.html">Bengali</a> by <a href="https://github.com/raselmandol">@raselmandol</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/fr/">French</a> by <a href="https://github.com/KookaS">@KookaS</a> and <a href="https://github.com/vcaen">@vcaen</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/de/">German</a> by <a href="https://github.com/Throvn">@Throvn</a> and <a href="https://github.com/ronaldfw">@ronaldfw</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/ja/">Japanese</a> by <a href="https://github.com/CoinEZ">@CoinEZ-JPN</a> and <a href="https://github.com/momotaro1105">@momotaro1105</a>.</li>
</ul>
<p>‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ø‡¶¶‡¶ø ‡¶è‡¶á ‡¶™‡ßç‡¶∞‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ‡¶Ø‡¶º ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶®, ‡¶§‡¶æ‡¶π‡¶≤‡ßá ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡¶¨‡ßá‡¶® ‡¶§‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø [‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡ßá‡¶∂‡¶æ‡¶¨‡¶≤‡ßÄ] ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®
‡•§ ‡¶Ö‡¶®‡ßÅ‡¶¨‡¶æ‡¶¶‡¶ó‡ßÅ‡¶≤‡¶ø [‡¶á‡¶∏‡ßç‡¶Ø‡ßÅ ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï‡¶æ‡¶∞] ‡¶è ‡¶∏‡¶Æ‡¶®‡ßç‡¶¨‡¶ø‡¶§ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-‡¶¨‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞-‡¶ï‡¶∞‡¶æ"><a class="header" href="#cargo-‡¶¨‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞-‡¶ï‡¶∞‡¶æ">Cargo ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ</a></h1>
<p>‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ø‡¶ñ‡¶® Rust ‡¶∏‡¶Æ‡ßç‡¶¨‡¶®‡ßç‡¶ß‡ßá ‡¶™‡¶°‡¶º‡¶æ ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡¶¨‡ßá‡¶®, ‡¶Ü‡¶™‡¶®‡¶ø ‡¶∂‡ßÄ‡¶ò‡ßç‡¶∞‡¶á <a href="https://doc.rust-lang.org/cargo/">‡¶ï‡¶æ‡¶∞‡ßç‡¶ó‡ßã</a> ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶¶‡ßá‡¶ñ‡¶æ ‡¶ï‡¶∞‡¶¨‡ßá‡¶®, ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Ü‡¶¶‡¶∞‡ßç‡¶∂ ‡¶ü‡ßÅ‡¶≤
‡¶Ø‡¶æ Rust ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶§‡ßà‡¶∞‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø Rust ‡¶á‡¶ï‡ßã‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§ ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶ö‡¶æ‡¶á
‡¶ï‡¶æ‡¶∞‡ßç‡¶ó‡ßã ‡¶ï‡ßÄ ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ü‡¶ø ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá ‡¶¨‡ßÉ‡¶π‡¶§‡ßç‡¶§‡¶∞ ‡¶á‡¶ï‡ßã‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ‡ßá ‡¶´‡¶ø‡¶ü ‡¶ï‡¶∞‡ßá ‡¶§‡¶æ‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶¨‡¶ø‡¶¨‡¶∞‡¶£ ‡¶¶‡¶ø‡¶§‡ßá
‡¶è‡¶¨‡¶Ç ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶è‡¶ü‡¶ø ‡¶è‡¶á ‡¶™‡ßç‡¶∞‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶£‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶ñ‡¶æ‡¶™ ‡¶ñ‡¶æ‡¶Ø‡¶º‡•§</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<blockquote>
<p><strong>Please follow the instructions on <a href="https://rustup.rs/">https://rustup.rs/</a>.</strong></p>
</blockquote>
<p>This will give you the Cargo build tool (<code>cargo</code>) and the Rust compiler (<code>rustc</code>). You will also get <code>rustup</code>, a command line utility that you can use to install/switch toolchains, setup cross compilation, etc.</p>
<details>
<ul>
<li>On Debian/Ubuntu, you can also install Cargo, the Rust source and the <a href="https://github.com/rust-lang/rustfmt">Rust formatter</a> via <code>apt</code>. However, this gets you an outdated rust version and may lead to unexpected behavior. The command would be:</li>
</ul>
<pre><code class="language-shell">    sudo apt install cargo rust-src rustfmt
</code></pre>
<ul>
<li>
<p>We suggest using <a href="https://code.visualstudio.com/">VS Code</a> to edit the code (but any LSP compatible editor works with rust-analyzer<a href="https://rust-analyzer.github.io/">3</a>).</p>
</li>
<li>
<p>Some folks also like to use the <a href="https://www.jetbrains.com/clion/">JetBrains</a> family of IDEs, which do their own analysis but have their own tradeoffs. If you prefer them, you can install the <a href="https://www.jetbrains.com/rust/">Rust Plugin</a>. Please take note that as of January 2023 debugging only works on the CLion version of the JetBrains IDEA suite.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-rust-‡¶è‡¶∞-‡¶á‡¶ï‡ßã‡¶∏‡¶ø‡¶∏‡¶ü‡ßá‡¶Æ"><a class="header" href="#the-rust-‡¶è‡¶∞-‡¶á‡¶ï‡ßã‡¶∏‡¶ø‡¶∏‡¶ü‡ßá‡¶Æ">The Rust ‡¶è‡¶∞ ‡¶á‡¶ï‡ßã‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ</a></h1>
<p>The Rust ecosystem ‡¶è ‡¶¨‡ßá‡¶∂ ‡¶ï‡¶Ø‡¶º‡ßá‡¶ï‡¶ü‡¶ø ‡¶∏‡¶∞‡¶û‡ßç‡¶ú‡¶æ‡¶Æ ‡¶∞‡¶Ø‡¶º‡ßá‡¶õ‡ßá, ‡¶Ø‡¶æ‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶™‡ßç‡¶∞‡¶ß‡¶æ‡¶®‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶π‡¶≤:</p>
<ul>
<li>
<p><code>rustc</code>: the Rust compiler which turns <code>.rs</code> files into binaries and other
intermediate formats.</p>
</li>
<li>
<p><code>cargo</code>: the Rust dependency manager and build tool. Cargo knows how to
download dependencies, usually hosted on <a href="https://crates.io/">https://crates.io</a>, and it will pass them to
<code>rustc</code> when building your project. Cargo also comes with a built-in test
runner which is used to execute unit tests.</p>
</li>
<li>
<p><code>rustup</code>: the Rust toolchain installer and updater. This tool is used to
install and update <code>rustc</code> and <code>cargo</code> when new versions of Rust is released.
In addition, <code>rustup</code> can also download documentation for the standard
library. You can have multiple versions of Rust installed at once and <code>rustup</code>
will let you switch between them as needed.</p>
</li>
</ul>
<details>
<p>‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¶‡¶ø‡¶ï:</p>
<ul>
<li>
<p>Rust has a rapid release schedule with a new release coming out
every six weeks. New releases maintain backwards compatibility with
old releases ‚Äî plus they enable new functionality.</p>
</li>
<li>
<p>There are three release channels: ‚Äústable‚Äù, ‚Äúbeta‚Äù, and ‚Äúnightly‚Äù.</p>
</li>
<li>
<p>New features are being tested on ‚Äúnightly‚Äù, ‚Äúbeta‚Äù is what becomes
‚Äústable‚Äù every six weeks.</p>
</li>
<li>
<p>Dependencies can also be resolved from alternative <a href="https://doc.rust-lang.org/cargo/reference/registries.html">registries</a>, git, folders, and more.</p>
</li>
<li>
<p>Rust also has <a href="https://doc.rust-lang.org/edition-guide/">editions</a>: the current edition is Rust 2021. Previous
editions were Rust 2015 and Rust 2018.</p>
<ul>
<li>
<p>The editions are allowed to make backwards incompatible changes to
the language.</p>
</li>
<li>
<p>To prevent breaking code, editions are opt-in: you select the
edition for your crate via the <code>Cargo.toml</code> file.</p>
</li>
<li>
<p>To avoid splitting the ecosystem, Rust compilers can mix code
written for different editions.</p>
</li>
<li>
<p>Mention that it is quite rare to ever use the compiler directly not through <code>cargo</code> (most users never do).</p>
</li>
<li>
<p>It might be worth alluding that Cargo itself is an extremely powerful and comprehensive tool.  It is capable of many advanced features including but not limited to: </p>
<ul>
<li>Project/package structure</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">workspaces</a></li>
<li>Dev Dependencies and Runtime Dependency management/caching</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build scripting</a></li>
<li><a href="https://doc.rust-lang.org/cargo/commands/cargo-install.html">global installation</a></li>
<li>It is also extensible with sub command plugins as well (such as <a href="https://github.com/rust-lang/rust-clippy">cargo clippy</a>).</li>
</ul>
</li>
<li>
<p>Read more from the <a href="https://doc.rust-lang.org/cargo/">official Cargo Book</a></p>
</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶è‡¶á-‡¶™‡¶∞‡¶∂‡¶ø‡¶ï‡¶∑‡¶£‡ßá-‡¶ï‡ßã‡¶°-‡¶®‡¶Æ‡ßÅ‡¶®‡¶æ"><a class="header" href="#‡¶è‡¶á-‡¶™‡¶∞‡¶∂‡¶ø‡¶ï‡¶∑‡¶£‡ßá-‡¶ï‡ßã‡¶°-‡¶®‡¶Æ‡ßÅ‡¶®‡¶æ">‡¶è‡¶á ‡¶™‡ßç‡¶∞‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶£‡ßá ‡¶ï‡ßã‡¶° ‡¶®‡¶Æ‡ßÅ‡¶®‡¶æ</a></h1>
<p>For this training, we will mostly explore the Rust language through examples
which can be executed through your browser. This makes the setup much easier and
ensures a consistent experience for everyone.</p>
<p>Installing Cargo is still encouraged: it will make it easier for you to do the
exercises. On the last day, we will do a larger exercise which shows you how to
work with dependencies and for that you need Cargo.</p>
<p>‡¶è‡¶á ‡¶ï‡ßã‡¶∞‡ßç‡¶∏‡ßá‡¶∞ ‡¶ï‡ßã‡¶° ‡¶¨‡ßç‡¶≤‡¶ï‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶ø‡¶≠:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(&quot;Edit me!&quot;);
}</code></pre></pre>
<p>‡¶Ø‡¶ñ‡¶® ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶¨‡¶ï‡ßç‡¶∏ ‡¶è ‡¶´‡ßã‡¶ï‡¶æ‡¶∏ ‡¶•‡¶æ‡¶ï‡ßá ‡¶§‡¶ñ‡¶® ‡¶ï‡ßã‡¶°‡¶ü‡¶ø ‡¶è‡¶ï‡ßç‡¶∏‡¶ø‡¶ï‡¶ø‡¶â‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶Ü‡¶™‡¶®‡¶ø <kbd>Ctrl + Enter</kbd>  ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ 
‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶®‡•§</p>
<details>
<p>‡¶¨‡ßá‡¶∂‡¶ø‡¶∞‡¶≠‡¶æ‡¶ó ‡¶ï‡ßã‡¶° ‡¶®‡¶Æ‡ßÅ‡¶®‡¶æ ‡¶â‡¶™‡¶∞‡ßá ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶Æ‡¶§ ‡¶∏‡¶Æ‡ßç‡¶™‡¶æ‡¶¶‡¶®‡¶æ‡¶Ø‡ßã‡¶ó‡ßç‡¶Ø‡•§ ‡¶ï‡¶Ø‡¶º‡ßá‡¶ï‡¶ü‡¶ø ‡¶ï‡ßã‡¶° ‡¶®‡¶Æ‡ßÅ‡¶®‡¶æ
‡¶¨‡¶ø‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶ï‡¶æ‡¶∞‡¶£‡ßá ‡¶∏‡¶Æ‡ßç‡¶™‡¶æ‡¶¶‡¶®‡¶æ‡¶Ø‡ßã‡¶ó‡ßç‡¶Ø ‡¶®‡¶Ø‡¶º:</p>
<ul>
<li>
<p>The embedded playgrounds cannot execute unit tests. Copy-paste the
code and open it in the real Playground to demonstrate unit tests.</p>
</li>
<li>
<p>The embedded playgrounds lose their state the moment you navigate
away from the page! This is the reason that the students should
solve the exercises using a local Rust installation or via the
Playground.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-‡¶è‡¶∞-‡¶Æ‡¶æ‡¶ß‡¶Ø‡¶Æ‡ßá-‡¶∏‡¶•‡¶æ‡¶®‡ßÄ‡¶Ø‡¶≠‡¶æ‡¶¨‡ßá-‡¶ï‡ßã‡¶°-‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã"><a class="header" href="#cargo-‡¶è‡¶∞-‡¶Æ‡¶æ‡¶ß‡¶Ø‡¶Æ‡ßá-‡¶∏‡¶•‡¶æ‡¶®‡ßÄ‡¶Ø‡¶≠‡¶æ‡¶¨‡ßá-‡¶ï‡ßã‡¶°-‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã">Cargo ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá ‡¶∏‡ßç‡¶•‡¶æ‡¶®‡ßÄ‡¶Ø‡¶º‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡ßã‡¶° ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã</a></h1>
<p>If you want to experiment with the code on your own system, then you will need
to first install Rust. Do this by following the <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">instructions in the Rust
Book</a>. This should give you a working <code>rustc</code> and <code>cargo</code>. At the time of
writing, the latest stable Rust release has these version numbers:</p>
<pre><code class="language-shell">% rustc --version
rustc 1.69.0 (84c898d65 2023-04-16)
% cargo --version
cargo 1.69.0 (6e9a83356 2023-04-12)
</code></pre>
<p>You can use any later version too since Rust maintains backwards compatibility.</p>
<p>With this in place, follow these steps to build a Rust binary from one
of the examples in this training:</p>
<ol>
<li>
<p>Click the ‚ÄúCopy to clipboard‚Äù button on the example you want to copy.</p>
</li>
<li>
<p>Use <code>cargo new exercise</code> to create a new <code>exercise/</code> directory for your code:</p>
<pre><code class="language-shell">$ cargo new exercise
     Created binary (application) `exercise` package
</code></pre>
</li>
<li>
<p>Navigate into <code>exercise/</code> and use <code>cargo run</code> to build and run your binary:</p>
<pre><code class="language-shell">$ cd exercise
$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.75s
     Running `target/debug/exercise`
Hello, world!
</code></pre>
</li>
<li>
<p>Replace the boiler-plate code in <code>src/main.rs</code> with your own code. For
example, using the example on the previous page, make <code>src/main.rs</code> look like</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;Edit me!&quot;);
}</code></pre></pre>
</li>
<li>
<p>Use <code>cargo run</code> to build and run your updated binary:</p>
<pre><code class="language-shell">$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
     Running `target/debug/exercise`
Edit me!
</code></pre>
</li>
<li>
<p>Use <code>cargo check</code> to quickly check your project for errors, use <code>cargo build</code>
to compile it without running it. You will find the output in <code>target/debug/</code>
for a normal debug build. Use <code>cargo build --release</code> to produce an optimized
release build in <code>target/release/</code>.</p>
</li>
<li>
<p>You can add dependencies for your project by editing <code>Cargo.toml</code>. When you
run <code>cargo</code> commands, it will automatically download and compile missing
dependencies for you.</p>
</li>
</ol>
<details>
<p>‡¶ï‡ßç‡¶≤‡¶æ‡¶∏ ‡¶Ö‡¶Ç‡¶∂‡¶ó‡ßç‡¶∞‡¶π‡¶£‡¶ï‡¶æ‡¶∞‡ßÄ‡¶¶‡ßá‡¶∞ Cargo ‡¶á‡¶®‡¶∏‡ßç‡¶ü‡¶≤ ‡¶ï‡¶∞‡¶§‡ßá ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ï‡¶ü‡¶ø ‡¶≤‡ßã‡¶ï‡¶æ‡¶≤ ‡¶è‡¶°‡¶ø‡¶ü‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶§‡ßá ‡¶â‡ßé‡¶∏‡¶æ‡¶π‡¶ø‡¶§ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®
‡•§ ‡¶è‡¶ü‡¶ø ‡¶§‡¶æ‡¶¶‡ßá‡¶∞ ‡¶ú‡ßÄ‡¶¨‡¶®‡¶ï‡ßá ‡¶∏‡¶π‡¶ú ‡¶ï‡¶∞‡ßá ‡¶§‡ßÅ‡¶≤‡¶¨‡ßá ‡¶Ø‡ßá‡¶π‡ßá‡¶§‡ßÅ ‡¶§‡¶æ‡¶¶‡ßá‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø 
‡¶∏‡ßç‡¶¨‡¶æ‡¶≠‡¶æ‡¶¨‡¶ø‡¶ï ‡¶°‡ßá‡¶≠‡ßá‡¶≤‡¶™‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶è‡¶®‡¶≠‡¶æ‡¶á‡¶∞‡¶®‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶™‡¶∞‡¶•‡¶Æ-‡¶¶‡¶ø‡¶®‡ßá-‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá-‡¶∏‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ"><a class="header" href="#‡¶™‡¶∞‡¶•‡¶Æ-‡¶¶‡¶ø‡¶®‡ßá-‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá-‡¶∏‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ">‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶¶‡¶ø‡¶®‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ</a></h1>
<p>This is the first day of Rust Fundamentals. We will cover a lot of ground
today:</p>
<ul>
<li>
<p>Basic Rust syntax: variables, scalar and compound types, enums, structs,
references, functions, and methods.</p>
</li>
<li>
<p>Memory management: stack vs heap, manual memory management, scope-based memory
management, and garbage collection.</p>
</li>
<li>
<p>Ownership: move semantics, copying and cloning, borrowing, and lifetimes.</p>
</li>
</ul>
<details>
<p>‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶æ‡¶∞‡ßç‡¶•‡ßÄ‡¶¶‡ßá‡¶∞ ‡¶è‡¶ü‡¶ø ‡¶Æ‡¶®‡ßá ‡¶ï‡¶∞‡¶ø‡ßü‡ßá ‡¶¶‡¶ø‡¶® ‡¶Ø‡ßá‡¶É</p>
<ul>
<li>They should ask questions when they get them, don‚Äôt save them to the end.</li>
<li>The class is meant to be interactive and discussions are very much encouraged!
<ul>
<li>As an instructor, you should try to keep the discussions relevant, i.e.,
keep the discussions related to how Rust does things vs some other language. 
It can be hard to find the right balance, but err on the side of allowing 
discussions since they engage people much more than one-way communication.</li>
</ul>
</li>
<li>The questions will likely mean that we talk about things ahead of the slides.
<ul>
<li>This is perfectly okay! Repetition is an important part of learning. Remember
that the slides are just a support and you are free to skip them as you
like.</li>
</ul>
</li>
</ul>
<p>The idea for the first day is to show <em>just enough</em> of Rust to be able to speak
about the famous borrow checker. The way Rust handles memory is a major feature
and we should show students this right away.</p>
<p>‡¶Ø‡¶¶‡¶ø ‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶ü‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∂‡ßç‡¶∞‡ßá‡¶®‡ßÄ‡¶ï‡¶ï‡ßç‡¶∑‡ßá ‡¶™‡ßú‡¶æ‡¶ö‡ßç‡¶õ‡ßá‡¶®, ‡¶è‡¶ü‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶≠‡¶æ‡¶≤‡ßã ‡¶Ø‡¶æ‡ßü‡¶ó‡¶æ ‡¶®‡¶ø‡ßü‡¶Æ‡¶Æ‡¶æ‡¶´‡¶ø‡¶ï 
‡¶ö‡¶≤‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡•§ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂ ‡¶¶‡¶ø‡¶á ‡¶Ø‡ßá ‡¶¶‡¶ø‡¶®‡¶ü‡¶æ‡¶ï‡ßá ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ ‡¶≠‡¶æ‡¶ó‡ßá ‡¶≠‡¶æ‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®(‡¶∏‡ßç‡¶≤‡¶æ‡¶á‡¶°‡¶ó‡ßÅ‡¶≤‡ßã‡¶ï‡ßá ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶∞‡¶® ‡¶ï‡¶∞‡ßá):</p>
<ul>
<li>‡¶∏‡¶ï‡¶æ‡¶≤‡¶É ‡ßØ:‡ß¶‡ß¶ ‡¶•‡ßá‡¶ï‡ßá ‡ßß‡ß®:‡ß¶‡ß¶,</li>
<li>‡¶¨‡¶ø‡¶ï‡¶æ‡¶≤ ‡ßß:‡ß¶‡ß¶ ‡¶•‡ßá‡¶ï‡ßá ‡ß™:‡ß¶‡ß¶.</li>
</ul>
<p>‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ö‡¶¨‡¶∂‡ßç‡¶Ø‡¶á ‡¶è‡¶ü‡¶ø ‡¶™‡ßç‡¶∞‡ßü‡ßã‡¶ú‡¶® ‡¶Ö‡¶®‡ßÅ‡¶∏‡¶æ‡¶∞‡ßá ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶®‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶¨‡¶ø‡¶∞‡¶§‡¶ø ‡¶®‡¶ø‡¶§‡ßá,
‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂ ‡¶¶‡¶ø‡¶á ‡¶™‡ßç‡¶∞‡¶§‡¶ø ‡¶ò‡¶®‡ßç‡¶ü‡¶æ‡ßü ‡¶è‡¶ï‡¶¨‡¶æ‡¶∞ ‡¶¨‡¶ø‡¶∞‡¶§‡¶ø ‡¶®‡¶ø‡¶§‡ßá!</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-‡¶ï‡¶ø"><a class="header" href="#rust-‡¶ï‡¶ø">Rust ‡¶ï‡¶ø?</a></h1>
<p>Rust ‡¶è‡¶ï‡¶ü‡¶ø ‡¶®‡¶§‡ßÅ‡¶® ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ‡¶ø‡¶Ç ‡¶≠‡¶æ‡¶∑‡¶æ ‡¶Ø‡ßá‡¶ü‡¶æ‡¶∞ ‡¶õ‡¶ø‡¶≤‡ßã <a href="https://blog.rust-lang.org/2015/05/15/Rust-1.0.html">1.0 ‡¶™‡ßç‡¶∞‡¶ï‡¶æ‡¶∂ 2015 ‡¶§‡ßá</a>:</p>
<ul>
<li>Rust is a statically compiled language in a similar role as C++
<ul>
<li><code>rustc</code> uses LLVM as its backend.</li>
</ul>
</li>
<li>Rust supports many <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">platforms and
architectures</a>:
<ul>
<li>x86, ARM, WebAssembly, ‚Ä¶</li>
<li>Linux, Mac, Windows, ‚Ä¶</li>
</ul>
</li>
<li>Rust is used for a wide range of devices:
<ul>
<li>firmware and boot loaders,</li>
<li>smart displays,</li>
<li>mobile phones,</li>
<li>desktops,</li>
<li>servers.</li>
</ul>
</li>
</ul>
<details>
<p>Rust ‡¶†‡¶ø‡¶ï C++ ‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶∏‡¶¨‡¶ú‡¶æ‡ßü‡¶ó‡¶æ‡ßü ‡¶ñ‡¶æ‡¶™ ‡¶ñ‡¶æ‡ßü:</p>
<ul>
<li>High flexibility.</li>
<li>High level of control.</li>
<li>Can be scaled down to very constrained devices such as microcontrollers.</li>
<li>Has no runtime or garbage collection.</li>
<li>Focuses on reliability and safety without sacrificing performance.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>Let us jump into the simplest possible Rust program, a classic Hello World
program:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(&quot;Hello üåç!&quot;);
}</code></pre></pre>
<p>‡¶Ø‡¶æ ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶¶‡ßá‡¶ñ‡¶§‡ßá ‡¶™‡¶æ‡¶ì‡¶É</p>
<ul>
<li>Functions are introduced with <code>fn</code>.</li>
<li>Blocks are delimited by curly braces like in C and C++.</li>
<li>The <code>main</code> function is the entry point of the program.</li>
<li>Rust has hygienic macros, <code>println!</code> is an example of this.</li>
<li>Rust strings are UTF-8 encoded and can contain any Unicode character.</li>
</ul>
<details>
<p>This slide tries to make the students comfortable with Rust code. They will see
a ton of it over the next three days so we start small with something familiar.</p>
<p>‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¶‡¶ø‡¶ï:</p>
<ul>
<li>
<p>Rust is very much like other languages in the C/C++/Java tradition. It is
imperative and it doesn‚Äôt try to reinvent things unless
absolutely necessary.</p>
</li>
<li>
<p>Rust is modern with full support for things like Unicode.</p>
</li>
<li>
<p>Rust uses macros for situations where you want to have a variable number of
arguments (no function <a href="basic-syntax/functions-interlude.html">overloading</a>).</p>
</li>
<li>
<p>Macros being ‚Äòhygienic‚Äô means they don‚Äôt accidentally capture identifiers from
the scope they are used in. Rust macros are actually only
<a href="https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html">partially hygienic</a>.</p>
</li>
<li>
<p>Rust is multi-paradigm. For example, it has powerful <a href="https://doc.rust-lang.org/book/ch17-00-oop.html">object-oriented programming features</a>,
and, while it is not a functional language, it includes a range of <a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">functional concepts</a>.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶õ‡ßã‡¶ü‡¶ü-‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£"><a class="header" href="#‡¶õ‡ßã‡¶ü‡¶ü-‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£">‡¶õ‡ßã‡¶ü‡ßç‡¶ü ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£</a></h1>
<p>‡¶è‡¶ü‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶õ‡ßã‡¶ü ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ Rust ‡¶è:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {              // Program entry point
    let mut x: i32 = 6;  // Mutable variable binding
    print!(&quot;{x}&quot;);       // Macro for printing, like printf
    while x != 1 {       // No parenthesis around expression
        if x % 2 == 0 {  // Math like in other languages
            x = x / 2;
        } else {
            x = 3 * x + 1;
        }
        print!(&quot; -&gt; {x}&quot;);
    }
    println!();
}</code></pre></pre>
<details>
<p>The code implements the Collatz conjecture: it is believed that the loop will
always end, but this is not yet proved. Edit the code and play with different
inputs.</p>
<p>‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¶‡¶ø‡¶ï:</p>
<ul>
<li>
<p>Explain that all variables are statically typed. Try removing <code>i32</code> to trigger
type inference. Try with <code>i8</code> instead and trigger a runtime integer overflow.</p>
</li>
<li>
<p>Change <code>let mut x</code> to <code>let x</code>, discuss the compiler error.</p>
</li>
<li>
<p>Show how <code>print!</code> gives a compilation error if the arguments don‚Äôt match the
format string.</p>
</li>
<li>
<p>Show how you need to use <code>{}</code> as a placeholder if you want to print an
expression which is more complex than just a single variable.</p>
</li>
<li>
<p>Show the students the standard library, show them how to search for <code>std::fmt</code>
which has the rules of the formatting mini-language. It‚Äôs important that the
students become familiar with searching in the standard library.</p>
<ul>
<li>In a shell <code>rustup doc std::fmt</code> will open a browser on the local std::fmt documentation</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-‡¶ï‡ßá‡¶®‡ßã"><a class="header" href="#rust-‡¶ï‡ßá‡¶®‡ßã">Rust ‡¶ï‡ßá‡¶®‡ßã?</a></h1>
<p>Rust‡¶è‡¶∞ ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶Ö‡¶®‡¶®‡ßç‡¶Ø ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶Ø‡¶º ‡¶™‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü:</p>
<ul>
<li>Compile time memory safety.</li>
<li>Lack of undefined runtime behavior.</li>
<li>Modern language features.</li>
</ul>
<details>
<p>Make sure to ask the class which languages they have experience with. Depending
on the answer you can highlight different features of Rust:</p>
<ul>
<li>
<p>Experience with C or C++: Rust eliminates a whole class of <em>runtime errors</em>
via the borrow checker. You get performance like in C and C++, but you don‚Äôt
have the memory unsafety issues. In addition, you get a modern language with
constructs like pattern matching and built-in dependency management.</p>
</li>
<li>
<p>Experience with Java, Go, Python, JavaScript‚Ä¶: You get the same memory safety
as in those languages, plus a similar high-level language feeling. In addition
you get fast and predictable performance like C and C++ (no garbage collector)
as well as access to low-level hardware (should you need it)</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶ï‡¶Æ‡¶™‡¶æ‡¶á‡¶≤-‡¶∏‡¶Æ‡ßü‡ßá‡¶∞-‡¶ó‡¶Ø‡¶æ‡¶∞‡¶æ‡¶®‡¶ü‡¶ø"><a class="header" href="#‡¶ï‡¶Æ‡¶™‡¶æ‡¶á‡¶≤-‡¶∏‡¶Æ‡ßü‡ßá‡¶∞-‡¶ó‡¶Ø‡¶æ‡¶∞‡¶æ‡¶®‡¶ü‡¶ø">‡¶ï‡¶Æ‡ßç‡¶™‡¶æ‡¶á‡¶≤ ‡¶∏‡¶Æ‡ßü‡ßá‡¶∞ ‡¶ó‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶®‡ßç‡¶ü‡¶ø</a></h1>
<p>Static memory management at compile time:</p>
<ul>
<li>No uninitialized variables.</li>
<li>No memory leaks (<em>mostly</em>, see notes).</li>
<li>No double-frees.</li>
<li>No use-after-free.</li>
<li>No <code>NULL</code> pointers.</li>
<li>No forgotten locked mutexes.</li>
<li>No data races between threads.</li>
<li>No iterator invalidation.</li>
</ul>
<details>
<p>It is possible to produce memory leaks in (safe) Rust. Some examples
are:</p>
<ul>
<li>You can use <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak"><code>Box::leak</code></a> to leak a pointer. A use of this could
be to get runtime-initialized and runtime-sized static variables</li>
<li>You can use <a href="https://doc.rust-lang.org/std/mem/fn.forget.html"><code>std::mem::forget</code></a> to make the compiler ‚Äúforget‚Äù about
a value (meaning the destructor is never run).</li>
<li>You can also accidentally create a <a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html">reference cycle</a> with <code>Rc</code> or
<code>Arc</code>.</li>
<li>In fact, some will consider infinitely populating a collection a memory
leak and Rust does not protect from those.</li>
</ul>
<p>For the purpose of this course, ‚ÄúNo memory leaks‚Äù should be understood
as ‚ÄúPretty much no <em>accidental</em> memory leaks‚Äù.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶∞‡¶æ‡¶®‡¶ü‡¶æ‡¶á‡¶Æ-‡¶ó‡¶Ø‡¶æ‡¶∞‡¶æ‡¶®‡¶ü‡¶ø"><a class="header" href="#‡¶∞‡¶æ‡¶®‡¶ü‡¶æ‡¶á‡¶Æ-‡¶ó‡¶Ø‡¶æ‡¶∞‡¶æ‡¶®‡¶ü‡¶ø">‡¶∞‡¶æ‡¶®‡¶ü‡¶æ‡¶á‡¶Æ ‡¶ó‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶®‡ßç‡¶ü‡¶ø</a></h1>
<p>‡¶∞‡¶æ‡¶®‡¶ü‡¶æ‡¶á‡¶Æ‡ßá ‡¶ï‡ßã‡¶® ‡¶Ö‡¶®‡¶ø‡¶∞‡ßç‡¶ß‡¶æ‡¶∞‡¶ø‡¶§ ‡¶Ü‡¶ö‡¶∞‡¶£ ‡¶®‡ßá‡¶á:</p>
<ul>
<li>Array access is bounds checked.</li>
<li>Integer overflow is defined (panic or wrap-around).</li>
</ul>
<details>
<p>‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¶‡¶ø‡¶ï:</p>
<ul>
<li>
<p>Integer overflow is defined via the <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#overflow-checks"><code>overflow-checks</code></a>
compile-time flag. If enabled, the program will panic (a controlled
crash of the program), otherwise you get wrap-around
semantics. By default, you get panics in debug mode (<code>cargo build</code>)
and wrap-around in release mode (<code>cargo build --release</code>).</p>
</li>
<li>
<p>Bounds checking cannot be disabled with a compiler flag. It can also
not be disabled directly with the <code>unsafe</code> keyword. However,
<code>unsafe</code> allows you to call functions such as <code>slice::get_unchecked</code>
which does not do bounds checking.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶Ü‡¶ß‡ßÅ‡¶®‡¶ø‡¶ï-‡¶¨‡ßà‡¶∂‡¶ø‡¶∑‡¶ü‡¶Ø‡¶∏‡¶Æ‡ßÇ‡¶π"><a class="header" href="#‡¶Ü‡¶ß‡ßÅ‡¶®‡¶ø‡¶ï-‡¶¨‡ßà‡¶∂‡¶ø‡¶∑‡¶ü‡¶Ø‡¶∏‡¶Æ‡ßÇ‡¶π">‡¶Ü‡¶ß‡ßÅ‡¶®‡¶ø‡¶ï ‡¶¨‡ßà‡¶∂‡¶ø‡¶∑‡ßç‡¶ü‡ßç‡¶Ø‡¶∏‡¶Æ‡ßÇ‡¶π</a></h1>
<p>Rust is built with all the experience gained in the last decades.</p>
<h2 id="‡¶≠‡¶æ‡¶∑‡¶æ‡¶∞-‡¶¨‡ßà‡¶∂‡¶ø‡¶∑‡¶ü‡¶Ø‡¶∏‡¶Æ‡ßÇ‡¶π"><a class="header" href="#‡¶≠‡¶æ‡¶∑‡¶æ‡¶∞-‡¶¨‡ßà‡¶∂‡¶ø‡¶∑‡¶ü‡¶Ø‡¶∏‡¶Æ‡ßÇ‡¶π">‡¶≠‡¶æ‡¶∑‡¶æ‡¶∞ ‡¶¨‡ßà‡¶∂‡¶ø‡¶∑‡ßç‡¶ü‡ßç‡¶Ø‡¶∏‡¶Æ‡ßÇ‡¶π</a></h2>
<ul>
<li>Enums and pattern matching.</li>
<li>Generics.</li>
<li>No overhead FFI.</li>
<li>Zero-cost abstractions.</li>
</ul>
<h2 id="tooling"><a class="header" href="#tooling">Tooling</a></h2>
<ul>
<li>Great compiler errors.</li>
<li>Built-in dependency manager.</li>
<li>Built-in support for testing.</li>
<li>Excellent Language Server Protocol support.</li>
</ul>
<details>
<p>‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¶‡¶ø‡¶ï:</p>
<ul>
<li>
<p>Zero-cost abstractions, similar to C++, means that you don‚Äôt have to ‚Äòpay‚Äô
for higher-level programming constructs with memory or CPU. For example,
writing a loop using <code>for</code> should result in roughly the same low level
instructions as using the <code>.iter().fold()</code> construct.</p>
</li>
<li>
<p>It may be worth mentioning that Rust enums are ‚ÄòAlgebraic Data Types‚Äô, also
known as ‚Äòsum types‚Äô, which allow the type system to express things like
<code>Option&lt;T&gt;</code> and <code>Result&lt;T, E&gt;</code>.</p>
</li>
<li>
<p>Remind people to read the errors ‚Äî many developers have gotten used to
ignore lengthy compiler output. The Rust compiler is significantly more
talkative than other compilers. It will often provide you with <em>actionable</em>
feedback, ready to copy-paste into your code.</p>
</li>
<li>
<p>The Rust standard library is small compared to languages like Java, Python,
and Go. Rust does not come with several things you might consider standard and
essential:</p>
<ul>
<li>a random number generator, but see <a href="https://docs.rs/rand/">rand</a>.</li>
<li>support for SSL or TLS, but see <a href="https://docs.rs/rustls/">rusttls</a>.</li>
<li>support for JSON, but see <a href="https://docs.rs/serde_json/">serde_json</a>.
The reasoning behind this is that functionality in the standard library cannot
go away, so it has to be very stable. For the examples above, the Rust
community is still working on finding the best solution ‚Äî and perhaps there
isn‚Äôt a single ‚Äúbest solution‚Äù for some of these things.</li>
</ul>
<p>Rust comes with a built-in package manager in the form of Cargo and this makes
it trivial to download and compile third-party crates. A consequence of this
is that the standard library can be smaller.</p>
<p>Discovering good third-party crates can be a problem. Sites like
<a href="https://lib.rs/">https://lib.rs/</a> help with this by letting you compare health metrics for
crates to find a good and trusted one.</p>
</li>
<li>
<p><a href="https://rust-analyzer.github.io/">rust-analyzer</a> is a well supported LSP implementation used in major
IDEs and text editors.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h1>
<p>C, C++ or Java ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡ßá‡¶∂‡¶ø‡¶∞‡¶≠‡¶æ‡¶ó ‡¶∞‡¶æ‡¶∏‡ßç‡¶ü ‡¶∏‡¶ø‡¶®‡¶ü‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶∏ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡¶æ‡¶õ‡ßá ‡¶™‡¶∞‡¶ø‡¶ö‡¶ø‡¶§ ‡¶Æ‡¶®‡ßá ‡¶π‡¶¨‡ßá‡¶É</p>
<ul>
<li>Blocks and scopes are delimited by curly braces.</li>
<li>Line comments are started with <code>//</code>, block comments are delimited by <code>/* ... */</code>.</li>
<li>Keywords like <code>if</code> and <code>while</code> work the same.</li>
<li>Variable assignment is done with <code>=</code>, comparison is done with <code>==</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th>Types</th><th>Literals</th></tr></thead><tbody>
<tr><td>Signed integers</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code></td><td><code>-10</code>, <code>0</code>, <code>1_000</code>, <code>123_i64</code></td></tr>
<tr><td>Unsigned integers</td><td><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code></td><td><code>0</code>, <code>123</code>, <code>10_u16</code></td></tr>
<tr><td>Floating point numbers</td><td><code>f32</code>, <code>f64</code></td><td><code>3.14</code>, <code>-10.0e20</code>, <code>2_f32</code></td></tr>
<tr><td>Strings</td><td><code>&amp;str</code></td><td><code>&quot;foo&quot;</code>, <code>&quot;two\nlines&quot;</code></td></tr>
<tr><td>Unicode scalar values</td><td><code>char</code></td><td><code>'a'</code>, <code>'Œ±'</code>, <code>'‚àû'</code></td></tr>
<tr><td>Booleans</td><td><code>bool</code></td><td><code>true</code>, <code>false</code></td></tr>
</tbody></table>
</div>
<p>‡¶ü‡¶æ‡¶á‡¶™‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Ü‡¶ï‡¶æ‡¶∞ ‡¶è ‡¶∞‡¶ï‡¶Æ:</p>
<ul>
<li><code>iN</code>, <code>uN</code>, and <code>fN</code> are <em>N</em> bits wide,</li>
<li><code>isize</code> and <code>usize</code> are the width of a pointer,</li>
<li><code>char</code> is 32 bits wide,</li>
<li><code>bool</code> is 8 bits wide.</li>
</ul>
<details>
<p>‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶∏‡¶ø‡¶®‡¶ü‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶∏ ‡¶Ü‡¶õ‡ßá ‡¶Ø‡¶æ ‡¶â‡¶™‡¶∞‡ßá ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶π‡¶Ø‡¶º‡¶®‡¶ø‡¶É</p>
<ul>
<li>
<p>Raw strings allow you to create a <code>&amp;str</code> value with escapes disabled: <code>r&quot;\n&quot; == &quot;\\n&quot;</code>. You can embed double-quotes by using an equal amount of <code>#</code> on
either side of the quotes:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(r#&quot;&lt;a href=&quot;link.html&quot;&gt;link&lt;/a&gt;&quot;#);
    println!(&quot;&lt;a href=\&quot;link.html\&quot;&gt;link&lt;/a&gt;&quot;);
}</code></pre></pre>
</li>
<li>
<p>Byte strings allow you to create a <code>&amp;[u8]</code> value directly:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(&quot;{:?}&quot;, b&quot;abc&quot;);
    println!(&quot;{:?}&quot;, &amp;[97, 98, 99]);
}</code></pre></pre>
</li>
<li>
<p>All underscores in numbers can be left out, they are for legibility only.
So <code>1_000</code> can be written as <code>1000</code> (or <code>10_00</code>), and <code>123_i64</code> can be written as <code>123i64</code>.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶Ø‡ßå‡¶ó‡¶ø‡¶ï-types"><a class="header" href="#‡¶Ø‡ßå‡¶ó‡¶ø‡¶ï-types">‡¶Ø‡ßå‡¶ó‡¶ø‡¶ï Types</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th>Types</th><th>Literals</th></tr></thead><tbody>
<tr><td>Arrays</td><td><code>[T; N]</code></td><td><code>[20, 30, 40]</code>, <code>[0; 3]</code></td></tr>
<tr><td>Tuples</td><td><code>()</code>, <code>(T,)</code>, <code>(T1, T2)</code>, ‚Ä¶</td><td><code>()</code>, <code>('x',)</code>, <code>('x', 1.2)</code>, ‚Ä¶</td></tr>
</tbody></table>
</div>
<p>‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∏‡¶æ‡¶á‡¶®‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶è‡¶¨‡¶Ç ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶∏‡ßá‡¶∏:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut a: [i8; 10] = [42; 10];
    a[5] = 0;
    println!(&quot;a: {:?}&quot;, a);
}</code></pre></pre>
<p>Tuple assignment and access:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let t: (i8, bool) = (7, true);
    println!(&quot;1st index: {}&quot;, t.0);
    println!(&quot;2nd index: {}&quot;, t.1);
}</code></pre></pre>
<details>
<p>‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¶‡¶ø‡¶ï:</p>
<p>Arrays:</p>
<ul>
<li>
<p>A value of the array type <code>[T; N]</code> holds <code>N</code> (a compile-time constant) elements of the same type <code>T</code>.
Note that the length of the array is <em>part of its type</em>, which means that <code>[u8; 3]</code> and
<code>[u8; 4]</code> are considered two different types.</p>
</li>
<li>
<p>We can use literals to assign values to arrays.</p>
</li>
<li>
<p>In the main function, the print statement asks for the debug implementation with the <code>?</code> format
parameter: <code>{}</code> gives the default output, <code>{:?}</code> gives the debug output. We
could also have used <code>{a}</code> and <code>{a:?}</code> without specifying the value after the
format string.</p>
</li>
<li>
<p>Adding <code>#</code>, eg <code>{a:#?}</code>, invokes a ‚Äúpretty printing‚Äù format, which can be easier to read.</p>
</li>
</ul>
<p>Tuples:</p>
<ul>
<li>
<p>Like arrays, tuples have a fixed length.</p>
</li>
<li>
<p>Tuples group together values of different types into a compound type.</p>
</li>
<li>
<p>Fields of a tuple can be accessed by the period and the index of the value, e.g. <code>t.0</code>, <code>t.1</code>.</p>
</li>
<li>
<p>The empty tuple <code>()</code> is also known as the ‚Äúunit type‚Äù. It is both a type, and
the only valid value of that type - that is to say both the type and its value
are expressed as <code>()</code>. It is used to indicate, for example, that a function or
expression has no return value, as we‚Äôll see in a future slide. </p>
<ul>
<li>You can think of it as <code>void</code> that can be familiar to you from other 
programming languages.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>C++ ‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã, Rust ‡¶è‡¶∞ ‡¶ì references ‡¶Ü‡¶õ‡ßá</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut x: i32 = 10;
    let ref_x: &amp;mut i32 = &amp;mut x;
    *ref_x = 20;
    println!(&quot;x: {x}&quot;);
}</code></pre></pre>
<p>‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶®‡ßã‡¶ü:</p>
<ul>
<li>We must dereference <code>ref_x</code> when assigning to it, similar to C and C++ pointers.</li>
<li>Rust will auto-dereference in some cases, in particular when invoking
methods (try <code>ref_x.count_ones()</code>).</li>
<li>References that are declared as <code>mut</code> can be bound to different values over their lifetime.</li>
</ul>
<details>
<p>‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¶‡¶ø‡¶ï:</p>
<ul>
<li>Be sure to note the difference between <code>let mut ref_x: &amp;i32</code> and <code>let ref_x: &amp;mut i32</code>. The first one represents a mutable reference which can be bound to
different values, while the second represents a reference to a mutable value.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dangling-references"><a class="header" href="#dangling-references">Dangling References</a></h1>
<p>Rust will statically forbid dangling references:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let ref_x: &amp;i32;
    {
        let x: i32 = 10;
        ref_x = &amp;x;
    }
    println!(&quot;ref_x: {ref_x}&quot;);
}</code></pre></pre>
<ul>
<li>A reference is said to ‚Äúborrow‚Äù the value it refers to.</li>
<li>Rust is tracking the lifetimes of all references to ensure they live long
enough.</li>
<li>We will talk more about borrowing when we get to ownership.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slices"><a class="header" href="#slices">Slices</a></h1>
<p>A slice gives you a view into a larger collection:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];
    println!(&quot;a: {a:?}&quot;);

    let s: &amp;[i32] = &amp;a[2..4];

    println!(&quot;s: {s:?}&quot;);
}</code></pre></pre>
<ul>
<li>Slices borrow data from the sliced type.</li>
<li>Question: What happens if you modify <code>a[3]</code> right before printing <code>s</code>?</li>
</ul>
<details>
<ul>
<li>
<p>We create a slice by borrowing <code>a</code> and specifying the starting and ending indexes in brackets.</p>
</li>
<li>
<p>If the slice starts at index 0, Rust‚Äôs range syntax allows us to drop the starting index, meaning that <code>&amp;a[0..a.len()]</code> and <code>&amp;a[..a.len()]</code> are identical.</p>
</li>
<li>
<p>The same is true for the last index, so <code>&amp;a[2..a.len()]</code> and <code>&amp;a[2..]</code> are identical.</p>
</li>
<li>
<p>To easily create a slice of the full array, we can therefore use <code>&amp;a[..]</code>.</p>
</li>
<li>
<p><code>s</code> is a reference to a slice of <code>i32</code>s. Notice that the type of <code>s</code> (<code>&amp;[i32]</code>) no longer mentions the array length. This allows us to perform computation on slices of different sizes.</p>
</li>
<li>
<p>Slices always borrow from another object. In this example, <code>a</code> has to remain ‚Äòalive‚Äô (in scope) for at least as long as our slice. </p>
</li>
<li>
<p>The question about modifying <code>a[3]</code> can spark an interesting discussion, but the answer is that for memory safety reasons
you cannot do it through <code>a</code> at this point in the execution, but you can read the data from both <code>a</code> and <code>s</code> safely.
It works before you created the slice, and again after the <code>println</code>, when the slice is no longer used. More details will be explained in the borrow checker section.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-vs-str"><a class="header" href="#string-vs-str"><code>String</code> vs <code>str</code></a></h1>
<p>We can now understand the two string types in Rust:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1: &amp;str = &quot;World&quot;;
    println!(&quot;s1: {s1}&quot;);

    let mut s2: String = String::from(&quot;Hello &quot;);
    println!(&quot;s2: {s2}&quot;);
    s2.push_str(s1);
    println!(&quot;s2: {s2}&quot;);
    
    let s3: &amp;str = &amp;s2[6..];
    println!(&quot;s3: {s3}&quot;);
}</code></pre></pre>
<p>Rust terminology:</p>
<ul>
<li><code>&amp;str</code> an immutable reference to a string slice.</li>
<li><code>String</code> a mutable string buffer.</li>
</ul>
<details>
<ul>
<li>
<p><code>&amp;str</code> introduces a string slice, which is an immutable reference to UTF-8 encoded string data 
stored in a block of memory. String literals (<code>‚ÄùHello‚Äù</code>), are stored in the program‚Äôs binary.</p>
</li>
<li>
<p>Rust‚Äôs <code>String</code> type is a wrapper around a vector of bytes. As with a <code>Vec&lt;T&gt;</code>, it is owned.</p>
</li>
<li>
<p>As with many other types <code>String::from()</code> creates a string from a string literal; <code>String::new()</code> 
creates a new empty string, to which string data can be added using the <code>push()</code> and <code>push_str()</code> methods.</p>
</li>
<li>
<p>The <code>format!()</code> macro is a convenient way to generate an owned string from dynamic values. It 
accepts the same format specification as <code>println!()</code>.</p>
</li>
<li>
<p>You can borrow <code>&amp;str</code> slices from <code>String</code> via <code>&amp;</code> and optionally range selection.</p>
</li>
<li>
<p>For C++ programmers: think of <code>&amp;str</code> as <code>const char*</code> from C++, but the one that always points 
to a valid string in memory. Rust <code>String</code> is a rough equivalent of <code>std::string</code> from C++ 
(main difference: it can only contain UTF-8 encoded bytes and will never use a small-string optimization).</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>A Rust version of the famous <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a> interview question:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    print_fizzbuzz_to(20);
}

fn is_divisible(n: u32, divisor: u32) -&gt; bool {
    if divisor == 0 {
        return false;
    }
    n % divisor == 0
}

fn fizzbuzz(n: u32) -&gt; String {
    let fizz = if is_divisible(n, 3) { &quot;fizz&quot; } else { &quot;&quot; };
    let buzz = if is_divisible(n, 5) { &quot;buzz&quot; } else { &quot;&quot; };
    if fizz.is_empty() &amp;&amp; buzz.is_empty() {
        return format!(&quot;{n}&quot;);
    }
    format!(&quot;{fizz}{buzz}&quot;)
}

fn print_fizzbuzz_to(n: u32) {
    for i in 1..=n {
        println!(&quot;{}&quot;, fizzbuzz(i));
    }
}</code></pre></pre>
<details>
<ul>
<li>We refer in <code>main</code> to a function written below. Neither forward declarations nor headers are necessary. </li>
<li>Declaration parameters are followed by a type (the reverse of some programming languages), then a return type.</li>
<li>The last expression in a function body (or any block) becomes the return value. Simply omit the <code>;</code> at the end of the expression.</li>
<li>Some functions have no return value, and return the ‚Äòunit type‚Äô, <code>()</code>. The compiler will infer this if the <code>-&gt; ()</code> return type is omitted.</li>
<li>The range expression in the <code>for</code> loop in <code>print_fizzbuzz_to()</code> contains <code>=n</code>, which causes it to include the upper bound.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustdoc"><a class="header" href="#rustdoc">Rustdoc</a></h1>
<p>All language items in Rust can be documented using special <code>///</code> syntax.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">/// Determine whether the first argument is divisible by the second argument.
///
/// If the second argument is zero, the result is false.
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    if rhs == 0 {
        return false;  // Corner case, early return
    }
    lhs % rhs == 0     // The last expression in a block is the return value
}</code></pre></pre>
<p>The contents are treated as Markdown. All published Rust library crates are
automatically documented at <a href="https://docs.rs/"><code>docs.rs</code></a> using the
<a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">rustdoc</a> tool. It is
idiomatic to document all public items in an API using this pattern.</p>
<details>
<ul>
<li>
<p>Show students the generated docs for the <code>rand</code> crate at
<a href="https://docs.rs/rand"><code>docs.rs/rand</code></a>.</p>
</li>
<li>
<p>This course does not include rustdoc on slides, just to save space, but in
real code they should be present.</p>
</li>
<li>
<p>Inner doc comments are discussed later (in the page on modules) and need not
be addressed here.</p>
</li>
<li>
<p>Rustdoc comments can contain code snippets that we can run and test using <code>cargo test</code>.
We will discuss these tests in the <a href="testing/doc-tests.html">Testing section</a>.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<p>Methods are functions associated with a type. The <code>self</code> argument of a method is
an instance of the type it is associated with:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn inc_width(&amp;mut self, delta: u32) {
        self.width += delta;
    }
}

fn main() {
    let mut rect = Rectangle { width: 10, height: 5 };
    println!(&quot;old area: {}&quot;, rect.area());
    rect.inc_width(5);
    println!(&quot;new area: {}&quot;, rect.area());
}</code></pre></pre>
<ul>
<li>We will look much more at methods in today‚Äôs exercise and in tomorrow‚Äôs class.</li>
</ul>
<details>
<ul>
<li>
<p>Add a static method called <code>Rectangle::new</code> and call this from <code>main</code>:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn new(width: u32, height: u32) -&gt; Rectangle {
    Rectangle { width, height }
}</code></pre></pre>
</li>
<li>
<p>While <em>technically</em>, Rust does not have custom constructors, static methods are commonly used to initialize structs (but don‚Äôt have to).
The actual constructor, <code>Rectangle { width, height }</code>, could be called directly. See the <a href="https://doc.rust-lang.org/nomicon/constructors.html">Rustnomicon</a>.</p>
</li>
<li>
<p>Add a <code>Rectangle::square(width: u32)</code> constructor to illustrate that such static methods can take arbitrary parameters.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-overloading"><a class="header" href="#function-overloading">Function Overloading</a></h1>
<p>Overloading is not supported:</p>
<ul>
<li>Each function has a single implementation:
<ul>
<li>Always takes a fixed number of parameters.</li>
<li>Always takes a single set of parameter types.</li>
</ul>
</li>
<li>Default values are not supported:
<ul>
<li>All call sites have the same number of arguments.</li>
<li>Macros are sometimes used as an alternative.</li>
</ul>
</li>
</ul>
<p>However, function parameters can be generic:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn pick_one&lt;T&gt;(a: T, b: T) -&gt; T {
    if std::process::id() % 2 == 0 { a } else { b }
}

fn main() {
    println!(&quot;coin toss: {}&quot;, pick_one(&quot;heads&quot;, &quot;tails&quot;));
    println!(&quot;cash prize: {}&quot;, pick_one(500, 1000));
}</code></pre></pre>
<details>
<ul>
<li>When using generics, the standard library‚Äôs <code>Into&lt;T&gt;</code> can provide a kind of limited
polymorphism on argument types. We will see more details in a later section.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶™‡¶∞‡¶•‡¶Æ-‡¶¶‡¶ø‡¶®‡¶É-‡¶∏‡¶ï‡¶æ‡¶≤‡ßá‡¶∞-‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®"><a class="header" href="#‡¶™‡¶∞‡¶•‡¶Æ-‡¶¶‡¶ø‡¶®‡¶É-‡¶∏‡¶ï‡¶æ‡¶≤‡ßá‡¶∞-‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®">‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶¶‡¶ø‡¶®‡¶É ‡¶∏‡¶ï‡¶æ‡¶≤‡ßá‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®</a></h1>
<p>In these exercises, we will explore two parts of Rust:</p>
<ul>
<li>
<p>Implicit conversions between types.</p>
</li>
<li>
<p>Arrays and <code>for</code> loops.</p>
</li>
</ul>
<details>
<p>A few things to consider while solving the exercises:</p>
<ul>
<li>
<p>Use a local Rust installation, if possible. This way you can get
auto-completion in your editor. See the page about <a href="cargo.html">Using Cargo</a> for details
on installing Rust.</p>
</li>
<li>
<p>Alternatively, use the Rust Playground.</p>
</li>
</ul>
<p>The code snippets are not editable on purpose: the inline code snippets lose
their state if you navigate away from the page.</p>
<p>After looking at the exercises, you can look at the <a href="exercises/day-1/solutions-morning.html">solutions</a> provided.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implicit-conversions"><a class="header" href="#implicit-conversions">Implicit Conversions</a></h1>
<p>Rust will not automatically apply <em>implicit conversions</em> between types (<a href="https://en.cppreference.com/w/cpp/language/implicit_conversion">unlike
C++</a>). You can see this in a program like this:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn multiply(x: i16, y: i16) -&gt; i16 {
    x * y
}

fn main() {
    let x: i8 = 15;
    let y: i16 = 1000;

    println!(&quot;{x} * {y} = {}&quot;, multiply(x, y));
}</code></pre></pre>
<p>The Rust integer types all implement the <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From&lt;T&gt;</code></a> and <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into&lt;T&gt;</code></a>
traits to let us convert between them. The <code>From&lt;T&gt;</code> trait has a single <code>from()</code>
method and similarly, the <code>Into&lt;T&gt;</code> trait has a single <code>into()</code> method.
Implementing these traits is how a type expresses that it can be converted into
another type.</p>
<p>The standard library has an implementation of <code>From&lt;i8&gt; for i16</code>, which means
that we can convert a variable <code>x</code> of type <code>i8</code> to an <code>i16</code> by calling 
<code>i16::from(x)</code>. Or, simpler, with <code>x.into()</code>, because <code>From&lt;i8&gt; for i16</code>
implementation automatically create an implementation of <code>Into&lt;i16&gt; for i8</code>.</p>
<p>The same applies for your own <code>From</code> implementations for your own types, so it is
sufficient to only implement <code>From</code> to get a respective <code>Into</code> implementation automatically.</p>
<ol>
<li>
<p>Execute the above program and look at the compiler error.</p>
</li>
<li>
<p>Update the code above to use <code>into()</code> to do the conversion.</p>
</li>
<li>
<p>Change the types of <code>x</code> and <code>y</code> to other things (such as <code>f32</code>, <code>bool</code>,
<code>i128</code>) to see which types you can convert to which other types. Try
converting small types to big types and the other way around. Check the
<a href="https://doc.rust-lang.org/std/convert/trait.From.html">standard library documentation</a> to see if <code>From&lt;T&gt;</code> is implemented for
the pairs you check.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays-and-for-loops"><a class="header" href="#arrays-and-for-loops">Arrays and <code>for</code> Loops</a></h1>
<p>We saw that an array can be declared like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [10, 20, 30];
<span class="boring">}</span></code></pre></pre>
<p>You can print such an array by asking for its debug representation with <code>{:?}</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let array = [10, 20, 30];
    println!(&quot;array: {array:?}&quot;);
}</code></pre></pre>
<p>Rust lets you iterate over things like arrays and ranges using the <code>for</code>
keyword:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let array = [10, 20, 30];
    print!(&quot;Iterating over array:&quot;);
    for n in &amp;array {
        print!(&quot; {n}&quot;);
    }
    println!();

    print!(&quot;Iterating over range:&quot;);
    for i in 0..3 {
        print!(&quot; {}&quot;, array[i]);
    }
    println!();
}</code></pre></pre>
<p>Use the above to write a function <code>pretty_print</code> which pretty-print a matrix and
a function <code>transpose</code> which will transpose a matrix (turn rows into columns):</p>
<div style='width:100%; height:64px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="272" height="64"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="272" height="64"></rect><text x="122" y="12" >2</text><text x="122" y="28" >5</text><text x="122" y="44" >8</text><text x="234" y="12" >4</text><text x="234" y="28" >5</text><text x="234" y="44" >6</text><text x="250" y="12" >7‚é§</text><text x="250" y="28" >8‚é•</text><text x="250" y="44" >9‚é¶</text><text x="2" y="28" >transpose</text><text x="178" y="28" >==</text><g><text x="90" y="12">‚éõ</text><text x="98" y="12">‚é°</text><text x="106" y="12">1</text></g><g><text x="90" y="28">‚éú</text><text x="98" y="28">‚é¢</text><text x="106" y="28">4</text></g><g><text x="90" y="44">‚éù</text><text x="98" y="44">‚é£</text><text x="106" y="44">7</text></g><g><text x="138" y="12">3‚é§</text><text x="154" y="12">‚éû</text></g><g><text x="138" y="28">6‚é•</text><text x="154" y="28">‚éü</text></g><g><text x="138" y="44">9‚é¶</text><text x="154" y="44">‚é†</text></g><g><text x="210" y="12">‚é°</text><text x="218" y="12">1</text></g><g><text x="210" y="28">‚é¢</text><text x="218" y="28">2</text></g><g><text x="210" y="44">‚é£</text><text x="218" y="44">3</text></g></svg></div>
<p>Hard-code both functions to operate on 3 √ó 3 matrices.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and implement the
functions:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

fn transpose(matrix: [[i32; 3]; 3]) -&gt; [[i32; 3]; 3] {
    unimplemented!()
}

fn pretty_print(matrix: &amp;[[i32; 3]; 3]) {
    unimplemented!()
}

fn main() {
    let matrix = [
        [101, 102, 103], // &lt;-- the comment makes rustfmt add a newline
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!(&quot;matrix:&quot;);
    pretty_print(&amp;matrix);

    let transposed = transpose(matrix);
    println!(&quot;transposed:&quot;);
    pretty_print(&amp;transposed);
}</code></pre></pre>
<h2 id="bonus-question"><a class="header" href="#bonus-question">Bonus Question</a></h2>
<p>Could you use <code>&amp;[i32]</code> slices instead of hard-coded 3 √ó 3 matrices for your
argument and return types? Something like <code>&amp;[&amp;[i32]]</code> for a two-dimensional
slice-of-slices. Why or why not?</p>
<p>See the <a href="https://docs.rs/ndarray/"><code>ndarray</code> crate</a> for a production quality
implementation.</p>
<details>
<p>The solution and the answer to the bonus section are available in the 
<a href="exercises/day-1/solutions-morning.html#arrays-and-for-loops">Solution</a> section.</p>
<p>The use of the reference <code>&amp;array</code> within <code>for n in &amp;array</code> is a subtle
preview of issues of ownership that will come later in the afternoon.</p>
<p>Without the <code>&amp;</code>‚Ä¶</p>
<ul>
<li>The loop would have been one that consumes the array.  This is a
change <a href="https://doc.rust-lang.org/edition-guide/rust-2021/IntoIterator-for-arrays.html">introduced in the 2021
Edition</a>, and ‚Ä¶</li>
<li>since the array is also accessed in the second loop, an implicit
array copy would have occured; since <code>i32</code> is a copy type, then
<code>[i32; 3]</code> is also a copy type.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Rust provides type safety via static typing. Variable bindings are immutable by
default:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x: i32 = 10;
    println!(&quot;x: {x}&quot;);
    // x = 20;
    // println!(&quot;x: {x}&quot;);
}</code></pre></pre>
<details>
<ul>
<li>Due to type inference the <code>i32</code> is optional. We will gradually show the types less and less as the course progresses.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h1>
<p>Rust will look at how the variable is <em>used</em> to determine the type:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn takes_u32(x: u32) {
    println!(&quot;u32: {x}&quot;);
}

fn takes_i8(y: i8) {
    println!(&quot;i8: {y}&quot;);
}

fn main() {
    let x = 10;
    let y = 20;

    takes_u32(x);
    takes_i8(y);
    // takes_u32(y);
}</code></pre></pre>
<details>
<p>This slide demonstrates how the Rust compiler infers types based on constraints given by variable declarations and usages.</p>
<p>It is very important to emphasize that variables declared like this are not of some sort of dynamic ‚Äúany type‚Äù that can
hold any data. The machine code generated by such declaration is identical to the explicit declaration of a type.
The compiler does the job for us and helps us write more concise code.</p>
<p>The following code tells the compiler to copy into a certain generic container without the code ever explicitly specifying the contained type, using <code>_</code> as a placeholder:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut v = Vec::new();
    v.push((10, false));
    v.push((20, true));
    println!(&quot;v: {v:?}&quot;);

    let vv = v.iter().collect::&lt;std::collections::HashSet&lt;_&gt;&gt;();
    println!(&quot;vv: {vv:?}&quot;);
}</code></pre></pre>
<p><a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect"><code>collect</code></a> relies on <a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>FromIterator</code></a>, which <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#impl-FromIterator%3CT%3E-for-HashSet%3CT,+S%3E"><code>HashSet</code></a> implements.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-and-constant-variables"><a class="header" href="#static-and-constant-variables">Static and Constant Variables</a></h1>
<p>Static and constant variables are two different ways to create globally-scoped values that
cannot be moved or reallocated during the execution of the program. </p>
<h2 id="const"><a class="header" href="#const"><code>const</code></a></h2>
<p>Constant variables are evaluated at compile time and their values are inlined
wherever they are used:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">const DIGEST_SIZE: usize = 3;
const ZERO: Option&lt;u8&gt; = Some(42);

fn compute_digest(text: &amp;str) -&gt; [u8; DIGEST_SIZE] {
    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];
    for (idx, &amp;b) in text.as_bytes().iter().enumerate() {
        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE].wrapping_add(b);
    }
    digest
}

fn main() {
    let digest = compute_digest(&quot;Hello&quot;);
    println!(&quot;Digest: {digest:?}&quot;);
}</code></pre></pre>
<p>According to the <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a> these are inlined upon use.</p>
<p>Only functions marked <code>const</code> can be called at compile time to generate <code>const</code> values. <code>const</code> functions can however be called at runtime.</p>
<h2 id="static"><a class="header" href="#static"><code>static</code></a></h2>
<p>Static variables will live during the whole execution of the program, and therefore will not move:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">static BANNER: &amp;str = &quot;Welcome to RustOS 3.14&quot;;

fn main() {
    println!(&quot;{BANNER}&quot;);
}</code></pre></pre>
<p>As noted in the <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a>, these are not inlined upon use and have an actual associated memory location.  This is useful for unsafe and 
embedded code, and the variable lives through the entirety of the program execution.
When a globally-scoped value does not have a reason to need object identity, <code>const</code> is generally preferred.</p>
<p>Because <code>static</code> variables are accessible from any thread, they must be <code>Sync</code>. Interior mutability
is possible through a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, atomic or
similar. It is also possible to have mutable statics, but they require manual synchronisation so any
access to them requires <code>unsafe</code> code. We will look at
<a href="unsafe/mutable-static-variables.html">mutable statics</a> in the chapter on Unsafe Rust.</p>
<details>
<ul>
<li>Mention that <code>const</code> behaves semantically similar to C++‚Äôs <code>constexpr</code>.</li>
<li><code>static</code>, on the other hand, is much more similar to a <code>const</code> or mutable global variable in C++.</li>
<li><code>static</code> provides object identity: an address in memory and state as required by types with interior mutability such as <code>Mutex&lt;T&gt;</code>.</li>
<li>It isn‚Äôt super common that one would need a runtime evaluated constant, but it is helpful and safer than using a static.</li>
<li><code>thread_local</code> data can be created with the macro <code>std::thread_local</code>.</li>
</ul>
<h3 id="properties-table"><a class="header" href="#properties-table">Properties table:</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Property</th><th>Static</th><th>Constant</th></tr></thead><tbody>
<tr><td>Has an address in memory</td><td>Yes</td><td>No (inlined)</td></tr>
<tr><td>Lives for the entire duration of the program</td><td>Yes</td><td>No</td></tr>
<tr><td>Can be mutable</td><td>Yes (unsafe)</td><td>No</td></tr>
<tr><td>Evaluated at compile time</td><td>Yes (initialised at compile time)</td><td>Yes</td></tr>
<tr><td>Inlined wherever it is used</td><td>No</td><td>Yes</td></tr>
</tbody></table>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scopes-and-shadowing"><a class="header" href="#scopes-and-shadowing">Scopes and Shadowing</a></h1>
<p>You can shadow variables, both those from outer scopes and variables from the
same scope:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a = 10;
    println!(&quot;before: {a}&quot;);

    {
        let a = &quot;hello&quot;;
        println!(&quot;inner scope: {a}&quot;);

        let a = true;
        println!(&quot;shadowed in inner scope: {a}&quot;);
    }

    println!(&quot;after: {a}&quot;);
}</code></pre></pre>
<details>
<ul>
<li>Definition: Shadowing is different from mutation, because after shadowing both variable‚Äôs memory locations exist at the same time. Both are available under the same name, depending where you use it in the code. </li>
<li>A shadowing variable can have a different type. </li>
<li>Shadowing looks obscure at first, but is convenient for holding on to values after <code>.unwrap()</code>.</li>
<li>The following code demonstrates why the compiler can‚Äôt simply reuse memory locations when shadowing an immutable variable in a scope, even if the type does not change.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a = 1;
    let b = &amp;a;
    let a = a + 1;
    println!(&quot;{a} {b}&quot;);
}</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<p>Traditionally, languages have fallen into two broad categories:</p>
<ul>
<li>Full control via manual memory management: C, C++, Pascal, ‚Ä¶</li>
<li>Full safety via automatic memory management at runtime: Java, Python, Go, Haskell, ‚Ä¶</li>
</ul>
<p>Rust offers a new mix:</p>
<blockquote>
<p>Full control <em>and</em> safety via compile time enforcement of correct memory
management.</p>
</blockquote>
<p>It does this with an explicit ownership concept.</p>
<p>First, let‚Äôs refresh how memory management works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-stack-vs-the-heap"><a class="header" href="#the-stack-vs-the-heap">The Stack vs The Heap</a></h1>
<ul>
<li>
<p>Stack: Continuous area of memory for local variables.</p>
<ul>
<li>Values have fixed sizes known at compile time.</li>
<li>Extremely fast: just move a stack pointer.</li>
<li>Easy to manage: follows function calls.</li>
<li>Great memory locality.</li>
</ul>
</li>
<li>
<p>Heap: Storage of values outside of function calls.</p>
<ul>
<li>Values have dynamic sizes determined at runtime.</li>
<li>Slightly slower than the stack: some book-keeping needed.</li>
<li>No guarantee of memory locality.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-and-heap-example"><a class="header" href="#stack-and-heap-example">Stack and Heap Example</a></h1>
<p>Creating a <code>String</code> puts fixed-sized metadata on the stack and dynamically sized
data, the actual string, on the heap:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1 = String::from(&quot;Hello&quot;);
}</code></pre></pre>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="544" height="192"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="544" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >H</text><text x="362" y="92" >e</text><text x="402" y="92" >l</text><text x="442" y="92" >l</text><text x="482" y="92" >o</text><text x="50" y="108" >len</text><text x="178" y="108" >5</text><text x="50" y="124" >capacity</text><text x="178" y="124" >5</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="508" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="508" y1="72" x2="508" y2="104" class="solid"></line><line x1="308" y1="104" x2="508" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><path d="M 528,24 A 4,4 0,0,1 532,28" class="nofill"></path><line x1="532" y1="28" x2="532" y2="148" class="broken"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><path d="M 532,148 A 4,4 0,0,1 528,152" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>
<p>Mention that a <code>String</code> is backed by a <code>Vec</code>, so it has a capacity and length and can grow if mutable via reallocation on the heap.</p>
</li>
<li>
<p>If students ask about it, you can mention that the underlying memory is heap allocated using the <a href="https://doc.rust-lang.org/std/alloc/struct.System.html">System Allocator</a> and custom allocators can be implemented using the <a href="https://doc.rust-lang.org/std/alloc/index.html">Allocator API</a></p>
</li>
<li>
<p>We can inspect the memory layout with <code>unsafe</code> code. However, you should point out that this is rightfully unsafe!</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s1 = String::from(&quot;Hello&quot;);
    s1.push(' ');
    s1.push_str(&quot;world&quot;);
    // DON'T DO THIS AT HOME! For educational purposes only.
    // String provides no guarantees about its layout, so this could lead to
    // undefined behavior.
    unsafe {
        let (ptr, capacity, len): (usize, usize, usize) = std::mem::transmute(s1);
        println!(&quot;ptr = {ptr:#x}, len = {len}, capacity = {capacity}&quot;);
    }
}</code></pre></pre>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶Æ‡¶Ø‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶≤-‡¶Æ‡ßá‡¶Æ‡ßã‡¶∞‡¶ø-‡¶¨‡¶Ø‡¶¨‡¶∏‡¶•‡¶æ‡¶™‡¶®‡¶æ"><a class="header" href="#‡¶Æ‡¶Ø‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶≤-‡¶Æ‡ßá‡¶Æ‡ßã‡¶∞‡¶ø-‡¶¨‡¶Ø‡¶¨‡¶∏‡¶•‡¶æ‡¶™‡¶®‡¶æ">‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶≤ ‡¶Æ‡ßá‡¶Æ‡ßã‡¶∞‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶™‡¶®‡¶æ</a></h1>
<p>‡¶Ü‡¶™‡¶®‡¶ø ‡¶®‡¶ø‡¶ú‡ßá‡¶á heap-memory ‡¶è‡¶≤‡ßã‡¶ï‡ßá‡¶ü ‡¶è‡¶¨‡¶Ç ‡¶°‡¶ø-‡¶è‡¶≤‡ßã‡¶ï‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®‡•§</p>
<p>If not done with care, this can lead to crashes, bugs, security vulnerabilities, and memory leaks.</p>
<h2 id="c-‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£"><a class="header" href="#c-‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£">C ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£</a></h2>
<p>You must call <code>free</code> on every pointer you allocate with <code>malloc</code>:</p>
<pre><code class="language-c">void foo(size_t n) {
    int* int_array = malloc(n * sizeof(int));
    //
    // ... lots of code
    //
    free(int_array);
}
</code></pre>
<p>Memory is leaked if the function returns early between <code>malloc</code> and <code>free</code>: the
pointer is lost and we cannot deallocate the memory.
Worse, freeing the pointer twice, or accessing a freed pointer can lead to exploitable security vulnerabilities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope-based-memory-management"><a class="header" href="#scope-based-memory-management">Scope-Based Memory Management</a></h1>
<p>Constructors and destructors let you hook into the lifetime of an object.</p>
<p>By wrapping a pointer in an object, you can free memory when the object is
destroyed. The compiler guarantees that this happens, even if an exception is
raised.</p>
<p>This is often called <em>resource acquisition is initialization</em> (RAII) and gives
you smart pointers.</p>
<h2 id="c-example"><a class="header" href="#c-example">C++ Example</a></h2>
<pre><code class="language-c++">void say_hello(std::unique_ptr&lt;Person&gt; person) {
  std::cout &lt;&lt; &quot;Hello &quot; &lt;&lt; person-&gt;name &lt;&lt; std::endl;
}
</code></pre>
<ul>
<li>The <code>std::unique_ptr</code> object is allocated on the stack, and points to
memory allocated on the heap.</li>
<li>At the end of <code>say_hello</code>, the <code>std::unique_ptr</code> destructor will run.</li>
<li>The destructor frees the <code>Person</code> object it points to.</li>
</ul>
<p>Special move constructors are used when passing ownership to a function:</p>
<pre><code class="language-c++">std::unique_ptr&lt;Person&gt; person = find_person(&quot;Carla&quot;);
say_hello(std::move(person));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automatic-memory-management"><a class="header" href="#automatic-memory-management">Automatic Memory Management</a></h1>
<p>An alternative to manual and scope-based memory management is automatic memory
management:</p>
<ul>
<li>The programmer never allocates or deallocates memory explicitly.</li>
<li>A garbage collector finds unused memory and deallocates it for the programmer.</li>
</ul>
<h2 id="java-example"><a class="header" href="#java-example">Java Example</a></h2>
<p>The <code>person</code> object is not deallocated after <code>sayHello</code> returns:</p>
<pre><code class="language-java">void sayHello(Person person) {
  System.out.println(&quot;Hello &quot; + person.getName());
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management-in-rust"><a class="header" href="#memory-management-in-rust">Memory Management in Rust</a></h1>
<p>Memory management in Rust is a mix:</p>
<ul>
<li>Safe and correct like Java, but without a garbage collector.</li>
<li>Depending on which abstraction (or combination of abstractions) you choose, can be a single unique pointer, reference counted, or atomically reference counted.</li>
<li>Scope-based like C++, but the compiler enforces full adherence.</li>
<li>A Rust user can choose the right abstraction for the situation, some even have no cost at runtime like C.</li>
</ul>
<p>Rust achieves this by modeling <em>ownership</em> explicitly.</p>
<details>
<ul>
<li>
<p>If asked how at this point, you can mention that in Rust this is usually handled by RAII wrapper types such as <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">Box</a>, <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec</a>, <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a>, or <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc</a>. These encapsulate ownership and memory allocation via various means, and prevent the potential errors in C.</p>
</li>
<li>
<p>You may be asked about destructors here, the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop</a> trait is the Rust equivalent.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparison"><a class="header" href="#comparison">Comparison</a></h1>
<p>Here is a rough comparison of the memory management techniques.</p>
<h2 id="pros-of-different-memory-management-techniques"><a class="header" href="#pros-of-different-memory-management-techniques">Pros of Different Memory Management Techniques</a></h2>
<ul>
<li>Manual like C:
<ul>
<li>No runtime overhead.</li>
</ul>
</li>
<li>Automatic like Java:
<ul>
<li>Fully automatic.</li>
<li>Safe and correct.</li>
</ul>
</li>
<li>Scope-based like C++:
<ul>
<li>Partially automatic.</li>
<li>No runtime overhead.</li>
</ul>
</li>
<li>Compiler-enforced scope-based like Rust:
<ul>
<li>Enforced by compiler.</li>
<li>No runtime overhead.</li>
<li>Safe and correct.</li>
</ul>
</li>
</ul>
<h2 id="cons-of-different-memory-management-techniques"><a class="header" href="#cons-of-different-memory-management-techniques">Cons of Different Memory Management Techniques</a></h2>
<ul>
<li>Manual like C:
<ul>
<li>Use-after-free.</li>
<li>Double-frees.</li>
<li>Memory leaks.</li>
</ul>
</li>
<li>Automatic like Java:
<ul>
<li>Garbage collection pauses.</li>
<li>Destructor delays.</li>
</ul>
</li>
<li>Scope-based like C++:
<ul>
<li>Complex, opt-in by programmer (on C++).</li>
<li>Circular references can lead to memory leaks</li>
<li>Potential runtime overhead</li>
</ul>
</li>
<li>Compiler-enforced and scope-based like Rust:
<ul>
<li>Some upfront complexity.</li>
<li>Can reject valid programs.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<p>All variable bindings have a <em>scope</em> where they are valid and it is an error to
use a variable outside its scope:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">struct Point(i32, i32);

fn main() {
    {
        let p = Point(3, 4);
        println!(&quot;x: {}&quot;, p.0);
    }
    println!(&quot;y: {}&quot;, p.1);
}</code></pre></pre>
<ul>
<li>At the end of the scope, the variable is <em>dropped</em> and the data is freed.</li>
<li>A destructor can run here to free up resources.</li>
<li>We say that the variable <em>owns</em> the value.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-semantics"><a class="header" href="#move-semantics">Move Semantics</a></h1>
<p>An assignment will transfer <em>ownership</em> between variables:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1: String = String::from(&quot;Hello!&quot;);
    let s2: String = s1;
    println!(&quot;s2: {s2}&quot;);
    // println!(&quot;s1: {s1}&quot;);
}</code></pre></pre>
<ul>
<li>The assignment of <code>s1</code> to <code>s2</code> transfers ownership.</li>
<li>When <code>s1</code> goes out of scope, nothing happens: it does not own anything.</li>
<li>When <code>s2</code> goes out of scope, the string data is freed.</li>
<li>There is always <em>exactly</em> one variable binding which owns a value.</li>
</ul>
<details>
<ul>
<li>
<p>Mention that this is the opposite of the defaults in C++, which copies by value unless you use <code>std::move</code> (and the move constructor is defined!).</p>
</li>
<li>
<p>It is only the ownership that moves. Whether any machine code is generated to manipulate the data itself is a matter of optimization, and such copies are aggressively optimized away.</p>
</li>
<li>
<p>Simple values (such as integers) can be marked <code>Copy</code> (see later slides).</p>
</li>
<li>
<p>In Rust, clones are explicit (by using <code>clone</code>).</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="moved-strings-in-rust"><a class="header" href="#moved-strings-in-rust">Moved Strings in Rust</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s1: String = String::from(&quot;Rust&quot;);
    let s2: String = s1;
}</code></pre></pre>
<ul>
<li>The heap data from <code>s1</code> is reused for <code>s2</code>.</li>
<li>When <code>s1</code> goes out of scope, nothing happens (it has been moved from).</li>
</ul>
<p>Before move to <code>s2</code>:</p>
<div style='width:100%; height:208px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="512" height="208"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="512" height="208"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >R</text><text x="362" y="92" >u</text><text x="402" y="92" >s</text><text x="442" y="92" >t</text><text x="50" y="108" >len</text><text x="178" y="108" >4</text><text x="50" y="124" >capacity</text><text x="178" y="124" >4</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><line x1="168" y1="184" x2="176" y2="184" class="solid"></line><line x1="184" y1="184" x2="192" y2="184" class="solid"></line><line x1="200" y1="184" x2="208" y2="184" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="180" class="broken"></line><line x1="216" y1="184" x2="224" y2="184" class="solid"></line><path d="M 228,180 A 4,4 0,0,1 224,184" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="468" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="308" y1="104" x2="468" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><path d="M 496,24 A 4,4 0,0,1 500,28" class="nofill"></path><line x1="500" y1="28" x2="500" y2="148" class="broken"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><path d="M 500,148 A 4,4 0,0,1 496,152" class="nofill"></path></g></svg></div>
<p>After move to <code>s2</code>:</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="512" height="304"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="512" height="304"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >R</text><text x="362" y="92" >u</text><text x="402" y="92" >s</text><text x="442" y="92" >t</text><text x="50" y="108" >len</text><text x="178" y="108" >4</text><text x="50" y="124" >capacity</text><text x="178" y="124" >4</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><circle cx="164" cy="200" r="3" class="nofill"></circle><text x="50" y="220" >len</text><text x="178" y="220" >4</text><text x="50" y="236" >capacity</text><text x="178" y="236" >4</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><text x="66" y="60" >(inaccessible)</text><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="468" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="308" y1="104" x2="468" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><line x1="252" y1="88" x2="252" y2="196" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon><line x1="168" y1="200" x2="248" y2="200" class="solid"></line><path d="M 252,196 A 4,4 0,0,1 248,200" class="nofill"></path></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><path d="M 496,24 A 4,4 0,0,1 500,28" class="nofill"></path><line x1="500" y1="28" x2="500" y2="148" class="broken"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><path d="M 500,148 A 4,4 0,0,1 496,152" class="nofill"></path></g></svg></div><div style="break-before: page; page-break-before: always;"></div><h1 id="extra-work-in-modern-c"><a class="header" href="#extra-work-in-modern-c">Extra Work in Modern C++</a></h1>
<p>Modern C++ solves this differently:</p>
<pre><code class="language-c++">std::string s1 = &quot;Cpp&quot;;
std::string s2 = s1;  // Duplicate the data in s1.
</code></pre>
<ul>
<li>The heap data from <code>s1</code> is duplicated and <code>s2</code> gets its own independent copy.</li>
<li>When <code>s1</code> and <code>s2</code> go out of scope, they each free their own memory.</li>
</ul>
<p>Before copy-assignment:</p>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="192"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="148" class="broken"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><path d="M 468,148 A 4,4 0,0,1 464,152" class="nofill"></path></g></svg></div>
<p>After copy-assignment:</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="304"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="304"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><circle cx="164" cy="200" r="3" class="nofill"></circle><text x="322" y="204" >C</text><text x="362" y="204" >p</text><text x="402" y="204" >p</text><text x="50" y="220" >len</text><text x="178" y="220" >3</text><text x="50" y="236" >capacity</text><text x="178" y="236" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="264" x2="304" y2="264" class="solid"></line><line x1="312" y1="264" x2="320" y2="264" class="solid"></line><line x1="328" y1="264" x2="336" y2="264" class="solid"></line><line x1="344" y1="264" x2="352" y2="264" class="solid"></line><line x1="360" y1="264" x2="368" y2="264" class="solid"></line><line x1="376" y1="264" x2="384" y2="264" class="solid"></line><line x1="392" y1="264" x2="400" y2="264" class="solid"></line><line x1="408" y1="264" x2="416" y2="264" class="solid"></line><line x1="424" y1="264" x2="432" y2="264" class="solid"></line><line x1="440" y1="264" x2="448" y2="264" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="260" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,260 A 4,4 0,0,0 280,264" class="nofill"></path><line x1="280" y1="264" x2="288" y2="264" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="308" y1="184" x2="428" y2="184" class="solid"></line><line x1="308" y1="184" x2="308" y2="216" class="solid"></line><line x1="348" y1="184" x2="348" y2="216" class="solid"></line><line x1="388" y1="184" x2="388" y2="216" class="solid"></line><line x1="428" y1="184" x2="428" y2="216" class="solid"></line><line x1="308" y1="216" x2="428" y2="216" class="solid"></line></g><g><line x1="168" y1="200" x2="296" y2="200" class="solid"></line><polygon points="296,196 304,200 296,204" class="filled"></polygon></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="260" class="broken"></line><line x1="456" y1="264" x2="464" y2="264" class="solid"></line><path d="M 468,260 A 4,4 0,0,1 464,264" class="nofill"></path></g></svg></div><div style="break-before: page; page-break-before: always;"></div><h1 id="moves-in-function-calls"><a class="header" href="#moves-in-function-calls">Moves in Function Calls</a></h1>
<p>When you pass a value to a function, the value is assigned to the function
parameter. This transfers ownership:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn say_hello(name: String) {
    println!(&quot;Hello {name}&quot;)
}

fn main() {
    let name = String::from(&quot;Alice&quot;);
    say_hello(name);
    // say_hello(name);
}</code></pre></pre>
<details>
<ul>
<li>With the first call to <code>say_hello</code>, <code>main</code> gives up ownership of <code>name</code>. Afterwards, <code>name</code> cannot be used anymore within <code>main</code>.</li>
<li>The heap memory allocated for <code>name</code> will be freed at the end of the <code>say_hello</code> function.</li>
<li><code>main</code> can retain ownership if it passes <code>name</code> as a reference (<code>&amp;name</code>) and if <code>say_hello</code> accepts a reference as a parameter.</li>
<li>Alternatively, <code>main</code> can pass a clone of <code>name</code> in the first call (<code>name.clone()</code>).</li>
<li>Rust makes it harder than C++ to inadvertently create copies by making move semantics the default, and by forcing programmers to make clones explicit.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copying-and-cloning"><a class="header" href="#copying-and-cloning">Copying and Cloning</a></h1>
<p>While move semantics are the default, certain types are copied by default:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 42;
    let y = x;
    println!(&quot;x: {x}&quot;);
    println!(&quot;y: {y}&quot;);
}</code></pre></pre>
<p>These types implement the <code>Copy</code> trait.</p>
<p>You can opt-in your own types to use copy semantics:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Copy, Clone, Debug)]
struct Point(i32, i32);

fn main() {
    let p1 = Point(3, 4);
    let p2 = p1;
    println!(&quot;p1: {p1:?}&quot;);
    println!(&quot;p2: {p2:?}&quot;);
}</code></pre></pre>
<ul>
<li>After the assignment, both <code>p1</code> and <code>p2</code> own their own data.</li>
<li>We can also use <code>p1.clone()</code> to explicitly copy the data.</li>
</ul>
<details>
<p>Copying and cloning are not the same thing:</p>
<ul>
<li>Copying refers to bitwise copies of memory regions and does not work on arbitrary objects.</li>
<li>Copying does not allow for custom logic (unlike copy constructors in C++).</li>
<li>Cloning is a more general operation and also allows for custom behavior by implementing the <code>Clone</code> trait.</li>
<li>Copying does not work on types that implement the <code>Drop</code> trait.</li>
</ul>
<p>In the above example, try the following:</p>
<ul>
<li>Add a <code>String</code> field to <code>struct Point</code>. It will not compile because <code>String</code> is not a <code>Copy</code> type.</li>
<li>Remove <code>Copy</code> from the <code>derive</code> attribute. The compiler error is now in the <code>println!</code> for  <code>p1</code>.</li>
<li>Show that it works if you clone <code>p1</code> instead.</li>
</ul>
<p>If students ask about <code>derive</code>, it is sufficient to say that this is a way to generate code in Rust
at compile time. In this case the default implementations of <code>Copy</code> and <code>Clone</code> traits are generated.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h1>
<p>Instead of transferring ownership when calling a function, you can let a
function <em>borrow</em> the value:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    Point(p1.0 + p2.0, p1.1 + p2.1)
}

fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!(&quot;{p1:?} + {p2:?} = {p3:?}&quot;);
}</code></pre></pre>
<ul>
<li>The <code>add</code> function <em>borrows</em> two points and returns a new point.</li>
<li>The caller retains ownership of the inputs.</li>
</ul>
<details>
<p>Notes on stack returns:</p>
<ul>
<li>
<p>Demonstrate that the return from <code>add</code> is cheap because the compiler can eliminate the copy operation. Change the above code to print stack addresses and run it on the <a href="https://play.rust-lang.org/">Playground</a> or look at the assembly in <a href="https://rust.godbolt.org/">Godbolt</a>. In the ‚ÄúDEBUG‚Äù optimization level, the addresses should change, while they stay the same when changing to the ‚ÄúRELEASE‚Äù setting:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    let p = Point(p1.0 + p2.0, p1.1 + p2.1);
    println!(&quot;&amp;p.0: {:p}&quot;, &amp;p.0);
    p
}

pub fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!(&quot;&amp;p3.0: {:p}&quot;, &amp;p3.0);
    println!(&quot;{p1:?} + {p2:?} = {p3:?}&quot;);
}</code></pre></pre>
</li>
<li>
<p>The Rust compiler can do return value optimization (RVO).</p>
</li>
<li>
<p>In C++, copy elision has to be defined in the language specification because constructors can have side effects. In Rust, this is not an issue at all. If RVO did not happen, Rust will always perform a simple and efficient <code>memcpy</code> copy.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-and-unique-borrows"><a class="header" href="#shared-and-unique-borrows">Shared and Unique Borrows</a></h1>
<p>Rust puts constraints on the ways you can borrow values:</p>
<ul>
<li>You can have one or more <code>&amp;T</code> values at any given time, <em>or</em></li>
<li>You can have exactly one <code>&amp;mut T</code> value.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let mut a: i32 = 10;
    let b: &amp;i32 = &amp;a;

    {
        let c: &amp;mut i32 = &amp;mut a;
        *c = 20;
    }

    println!(&quot;a: {a}&quot;);
    println!(&quot;b: {b}&quot;);
}</code></pre></pre>
<details>
<ul>
<li>The above code does not compile because <code>a</code> is borrowed as mutable (through <code>c</code>) and as immutable (through <code>b</code>) at the same time.</li>
<li>Move the <code>println!</code> statement for <code>b</code> before the scope that introduces <code>c</code> to make the code compile.</li>
<li>After that change, the compiler realizes that <code>b</code> is only ever used before the new mutable borrow of <code>a</code> through <code>c</code>. This is a feature of the borrow checker called ‚Äúnon-lexical lifetimes‚Äù.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>A borrowed value has a <em>lifetime</em>:</p>
<ul>
<li>The lifetime can be implicit: <code>add(p1: &amp;Point, p2: &amp;Point) -&gt; Point</code>.</li>
<li>Lifetimes can also be explicit: <code>&amp;'a Point</code>, <code>&amp;'document str</code>.</li>
<li>Read <code>&amp;'a Point</code> as ‚Äúa borrowed <code>Point</code> which is valid for at least the
lifetime <code>a</code>‚Äù.</li>
<li>Lifetimes are always inferred by the compiler: you cannot assign a lifetime
yourself.
<ul>
<li>Lifetime annotations create constraints; the compiler verifies that there is
a valid solution.</li>
</ul>
</li>
<li>Lifetimes for function arguments and return values must be fully specified,
but Rust allows lifetimes to be elided in most cases with <a href="https://doc.rust-lang.org/nomicon/lifetime-elision.html">a few simple
rules</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes-in-function-calls"><a class="header" href="#lifetimes-in-function-calls">Lifetimes in Function Calls</a></h1>
<p>In addition to borrowing its arguments, a function can return a borrowed value:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point(i32, i32);

fn left_most&lt;'a&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'a Point {
    if p1.0 &lt; p2.0 { p1 } else { p2 }
}

fn main() {
    let p1: Point = Point(10, 10);
    let p2: Point = Point(20, 20);
    let p3: &amp;Point = left_most(&amp;p1, &amp;p2);
    println!(&quot;left-most point: {:?}&quot;, p3);
}</code></pre></pre>
<ul>
<li><code>'a</code> is a generic parameter, it is inferred by the compiler.</li>
<li>Lifetimes start with <code>'</code> and <code>'a</code> is a typical default name.</li>
<li>Read <code>&amp;'a Point</code> as ‚Äúa borrowed <code>Point</code> which is valid for at least the
lifetime <code>a</code>‚Äù.
<ul>
<li>The <em>at least</em> part is important when parameters are in different scopes.</li>
</ul>
</li>
</ul>
<details>
<p>In the above example, try the following:</p>
<ul>
<li>
<p>Move the declaration of <code>p2</code> and <code>p3</code> into a new scope (<code>{ ... }</code>), resulting in the following code:</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
struct Point(i32, i32);

fn left_most&lt;'a&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'a Point {
    if p1.0 &lt; p2.0 { p1 } else { p2 }
}

fn main() {
    let p1: Point = Point(10, 10);
    let p3: &amp;Point;
    {
        let p2: Point = Point(20, 20);
        p3 = left_most(&amp;p1, &amp;p2);
    }
    println!(&quot;left-most point: {:?}&quot;, p3);
}</code></pre>
<p>Note how this does not compile since <code>p3</code> outlives <code>p2</code>.</p>
</li>
<li>
<p>Reset the workspace and change the function signature to <code>fn left_most&lt;'a, 'b&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'b Point</code>. This will not compile because the relationship between the lifetimes <code>'a</code> and <code>'b</code> is unclear.</p>
</li>
<li>
<p>Another way to explain it:</p>
<ul>
<li>Two references to two values are borrowed by a function and the function returns
another reference.</li>
<li>It must have come from one of those two inputs (or from a global variable).</li>
<li>Which one is it? The compiler needs to know, so at the call site the returned reference is not used
for longer than a variable from where the reference came from.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes-in-data-structures"><a class="header" href="#lifetimes-in-data-structures">Lifetimes in Data Structures</a></h1>
<p>If a data type stores borrowed data, it must be annotated with a lifetime:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Highlight&lt;'doc&gt;(&amp;'doc str);

fn erase(text: String) {
    println!(&quot;Bye {text}!&quot;);
}

fn main() {
    let text = String::from(&quot;The quick brown fox jumps over the lazy dog.&quot;);
    let fox = Highlight(&amp;text[4..19]);
    let dog = Highlight(&amp;text[35..43]);
    // erase(text);
    println!(&quot;{fox:?}&quot;);
    println!(&quot;{dog:?}&quot;);
}</code></pre></pre>
<details>
<ul>
<li>In the above example, the annotation on <code>Highlight</code> enforces that the data underlying the contained <code>&amp;str</code> lives at least as long as any instance of <code>Highlight</code> that uses that data.</li>
<li>If <code>text</code> is consumed before the end of the lifetime of <code>fox</code> (or <code>dog</code>), the borrow checker throws an error.</li>
<li>Types with borrowed data force users to hold on to the original data. This can be useful for creating lightweight views, but it generally makes them somewhat harder to use.</li>
<li>When possible, make data structures own their data directly.</li>
<li>Some structs with multiple references inside can have more than one lifetime annotation. This can be necessary if there is a need to describe lifetime relationships between the references themselves, in addition to the lifetime of the struct itself. Those are very advanced use cases.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-1-afternoon-exercises"><a class="header" href="#day-1-afternoon-exercises">Day 1: Afternoon Exercises</a></h1>
<p>We will look at two things:</p>
<ul>
<li>
<p>A small book library,</p>
</li>
<li>
<p>Iterators and ownership (hard).</p>
</li>
</ul>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/day-1/solutions-afternoon.html">solutions</a> provided.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storing-books"><a class="header" href="#storing-books">Storing Books</a></h1>
<p>We will learn much more about structs and the <code>Vec&lt;T&gt;</code> type tomorrow. For now,
you just need to know part of its API:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut vec = vec![10, 20];
    vec.push(30);
    let midpoint = vec.len() / 2;
    println!(&quot;middle value: {}&quot;, vec[midpoint]);
    for item in &amp;vec {
        println!(&quot;item: {item}&quot;);
    }
}</code></pre></pre>
<p>Use this to model a library‚Äôs book collection. Copy the code below to
<a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and update the types to make it compile:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">struct Library {
    books: Vec&lt;Book&gt;,
}

struct Book {
    title: String,
    year: u16,
}

impl Book {
    // This is a constructor, used below.
    fn new(title: &amp;str, year: u16) -&gt; Book {
        Book {
            title: String::from(title),
            year,
        }
    }
}

// Implement the methods below. Update the `self` parameter to
// indicate the method's required level of ownership over the object:
//
// - `&amp;self` for shared read-only access,
// - `&amp;mut self` for unique and mutable access,
// - `self` for unique access by value.
impl Library {
    fn new() -&gt; Library {
        todo!(&quot;Initialize and return a `Library` value&quot;)
    }

    //fn len(self) -&gt; usize {
    //    todo!(&quot;Return the length of `self.books`&quot;)
    //}

    //fn is_empty(self) -&gt; bool {
    //    todo!(&quot;Return `true` if `self.books` is empty&quot;)
    //}

    //fn add_book(self, book: Book) {
    //    todo!(&quot;Add a new book to `self.books`&quot;)
    //}

    //fn print_books(self) {
    //    todo!(&quot;Iterate over `self.books` and each book's title and year&quot;)
    //}

    //fn oldest_book(self) -&gt; Option&lt;&amp;Book&gt; {
    //    todo!(&quot;Return a reference to the oldest book (if any)&quot;)
    //}
}

// This shows the desired behavior. Uncomment the code below and
// implement the missing methods. You will need to update the
// method signatures, including the &quot;self&quot; parameter! You may
// also need to update the variable bindings within main.
fn main() {
    let library = Library::new();

    //println!(&quot;The library is empty: library.is_empty() -&gt; {}&quot;, library.is_empty());
    //
    //library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    //library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));
    //
    //println!(&quot;The library is no longer empty: library.is_empty() -&gt; {}&quot;, library.is_empty());
    //
    //
    //library.print_books();
    //
    //match library.oldest_book() {
    //    Some(book) =&gt; println!(&quot;The oldest book is {}&quot;, book.title),
    //    None =&gt; println!(&quot;The library is empty!&quot;),
    //}
    //
    //println!(&quot;The library has {} books&quot;, library.len());
    //library.print_books();
}</code></pre></pre>
<details>
<p><a href="exercises/day-1/solutions-afternoon.html#designing-a-library">Solution</a></p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators-and-ownership"><a class="header" href="#iterators-and-ownership">Iterators and Ownership</a></h1>
<p>The ownership model of Rust affects many APIs. An example of this is the
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> and
<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>
traits.</p>
<h2 id="iterator"><a class="header" href="#iterator"><code>Iterator</code></a></h2>
<p>Traits are like interfaces: they describe behavior (methods) for a type. The
<code>Iterator</code> trait simply says that you can call <code>next</code> until you get <code>None</code> back:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>You use this trait like this:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v: Vec&lt;i8&gt; = vec![10, 20, 30];
    let mut iter = v.iter();

    println!(&quot;v[0]: {:?}&quot;, iter.next());
    println!(&quot;v[1]: {:?}&quot;, iter.next());
    println!(&quot;v[2]: {:?}&quot;, iter.next());
    println!(&quot;No more items: {:?}&quot;, iter.next());
}</code></pre></pre>
<p>What is the type returned by the iterator? Test your answer here:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let v: Vec&lt;i8&gt; = vec![10, 20, 30];
    let mut iter = v.iter();

    let v0: Option&lt;..&gt; = iter.next();
    println!(&quot;v0: {v0:?}&quot;);
}</code></pre></pre>
<p>Why is this type used?</p>
<h2 id="intoiterator"><a class="header" href="#intoiterator"><code>IntoIterator</code></a></h2>
<p>The <code>Iterator</code> trait tells you how to <em>iterate</em> once you have created an
iterator. The related trait <code>IntoIterator</code> tells you how to create the iterator:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IntoIterator {
    type Item;
    type IntoIter: Iterator&lt;Item = Self::Item&gt;;

    fn into_iter(self) -&gt; Self::IntoIter;
}
<span class="boring">}</span></code></pre></pre>
<p>The syntax here means that every implementation of <code>IntoIterator</code> must
declare two types:</p>
<ul>
<li><code>Item</code>: the type we iterate over, such as <code>i8</code>,</li>
<li><code>IntoIter</code>: the <code>Iterator</code> type returned by the <code>into_iter</code> method.</li>
</ul>
<p>Note that <code>IntoIter</code> and <code>Item</code> are linked: the iterator must have the same
<code>Item</code> type, which means that it returns <code>Option&lt;Item&gt;</code></p>
<p>Like before, what  is the type returned by the iterator?</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
    let v: Vec&lt;String&gt; = vec![String::from(&quot;foo&quot;), String::from(&quot;bar&quot;)];
    let mut iter = v.into_iter();

    let v0: Option&lt;..&gt; = iter.next();
    println!(&quot;v0: {v0:?}&quot;);
}</code></pre></pre>
<h2 id="for-loops"><a class="header" href="#for-loops"><code>for</code> Loops</a></h2>
<p>Now that we know both <code>Iterator</code> and <code>IntoIterator</code>, we can build <code>for</code> loops.
They call <code>into_iter()</code> on an expression and iterates over the resulting
iterator:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v: Vec&lt;String&gt; = vec![String::from(&quot;foo&quot;), String::from(&quot;bar&quot;)];

    for word in &amp;v {
        println!(&quot;word: {word}&quot;);
    }

    for word in v {
        println!(&quot;word: {word}&quot;);
    }
}</code></pre></pre>
<p>What is the type of <code>word</code> in each loop?</p>
<p>Experiment with the code above and then consult the documentation for <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-%26&#x27;a+Vec%3CT,+A%3E"><code>impl IntoIterator for &amp;Vec&lt;T&gt;</code></a>
and <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-Vec%3CT,+A%3E"><code>impl IntoIterator for Vec&lt;T&gt;</code></a>
to check your answers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-day-2"><a class="header" href="#welcome-to-day-2">Welcome to Day 2</a></h1>
<p>Now that we have seen a fair amount of Rust, we will continue with:</p>
<ul>
<li>
<p>Structs, enums, methods.</p>
</li>
<li>
<p>Pattern matching: destructuring enums, structs, and arrays.</p>
</li>
<li>
<p>Control flow constructs: <code>if</code>, <code>if let</code>, <code>while</code>, <code>while let</code>, <code>break</code>, and
<code>continue</code>.</p>
</li>
<li>
<p>The Standard Library: <code>String</code>, <code>Option</code> and <code>Result</code>, <code>Vec</code>, <code>HashMap</code>, <code>Rc</code>
and <code>Arc</code>.</p>
</li>
<li>
<p>Modules: visibility, paths, and filesystem hierarchy.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Like C and C++, Rust has support for custom structs:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Person {
    name: String,
    age: u8,
}

fn main() {
    let mut peter = Person {
        name: String::from(&quot;Peter&quot;),
        age: 27,
    };
    println!(&quot;{} is {} years old&quot;, peter.name, peter.age);
    
    peter.age = 28;
    println!(&quot;{} is {} years old&quot;, peter.name, peter.age);
    
    let jackie = Person {
        name: String::from(&quot;Jackie&quot;),
        ..peter
    };
    println!(&quot;{} is {} years old&quot;, jackie.name, jackie.age);
}</code></pre></pre>
<details>
<p>Key Points:</p>
<ul>
<li>Structs work like in C or C++.
<ul>
<li>Like in C++, and unlike in C, no typedef is needed to define a type.</li>
<li>Unlike in C++, there is no inheritance between structs.</li>
</ul>
</li>
<li>Methods are defined in an <code>impl</code> block, which we will see in following slides.</li>
<li>This may be a good time to let people know there are different types of structs. 
<ul>
<li>Zero-sized structs <code>e.g., struct Foo;</code> might be used when implementing a trait on some type but don‚Äôt have any data that you want to store in the value itself. </li>
<li>The next slide will introduce Tuple structs, used when the field names are not important.</li>
</ul>
</li>
<li>The syntax <code>..peter</code> allows us to copy the majority of the fields from the old struct without having to explicitly type it all out. It must always be the last element.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuple-structs"><a class="header" href="#tuple-structs">Tuple Structs</a></h1>
<p>If the field names are unimportant, you can use a tuple struct:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point(i32, i32);

fn main() {
    let p = Point(17, 23);
    println!(&quot;({}, {})&quot;, p.0, p.1);
}</code></pre></pre>
<p>This is often used for single-field wrappers (called newtypes):</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">struct PoundsOfForce(f64);
struct Newtons(f64);

fn compute_thruster_force() -&gt; PoundsOfForce {
    todo!(&quot;Ask a rocket scientist at NASA&quot;)
}

fn set_thruster_force(force: Newtons) {
    // ...
}

fn main() {
    let force = compute_thruster_force();
    set_thruster_force(force);
}
</code></pre></pre>
<details>
<ul>
<li>Newtypes are a great way to encode additional information about the value in a primitive type, for example:
<ul>
<li>The number is measured in some units: <code>Newtons</code> in the example above.</li>
<li>The value passed some validation when it was created, so you no longer have to validate it again at every use: ‚ÄôPhoneNumber(String)<code>or</code>OddNumber(u32)`.</li>
</ul>
</li>
<li>Demonstrate how to add a <code>f64</code> value to a <code>Newtons</code> type by accessing the single field in the newtype.
<ul>
<li>Rust generally doesn‚Äôt like inexplicit things, like automatic unwrapping or for instance using booleans as integers.</li>
<li>Operator overloading is discussed on Day 3 (generics).</li>
</ul>
</li>
<li>The example is a subtle reference to the <a href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter">Mars Climate Orbiter</a> failure.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-shorthand-syntax"><a class="header" href="#field-shorthand-syntax">Field Shorthand Syntax</a></h1>
<p>If you already have variables with the right names, then you can create the
struct using a shorthand:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

impl Person {
    fn new(name: String, age: u8) -&gt; Person {
        Person { name, age }
    }
}

fn main() {
    let peter = Person::new(String::from(&quot;Peter&quot;), 27);
    println!(&quot;{peter:?}&quot;);
}</code></pre></pre>
<details>
<ul>
<li>
<p>The <code>new</code> function could be written using <code>Self</code> as a type, as it is interchangeable with the struct type name</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}
impl Person {
    fn new(name: String, age: u8) -&gt; Self {
        Self { name, age }
    }
}</code></pre></pre>
</li>
<li>
<p>Implement the <code>Default</code> trait for the struct. Define some fields and use the default values for the other fields.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}
impl Default for Person {
    fn default() -&gt; Person {
        Person {
            name: &quot;Bot&quot;.to_string(),
            age: 0,
        }
    }
}
fn create_default() {
    let tmp = Person {
        ..Person::default()
    };
    let tmp = Person {
        name: &quot;Sam&quot;.to_string(),
        ..Person::default()
    };
}</code></pre></pre>
</li>
<li>
<p>Methods are defined in the <code>impl</code> block.</p>
</li>
<li>
<p>Use struct update syntax to define a new structure using <code>peter</code>. Note that the variable <code>peter</code> will no longer be accessible afterwards.</p>
</li>
<li>
<p>Use <code>{:#?}</code> when printing structs to request the <code>Debug</code> representation.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>The <code>enum</code> keyword allows the creation of a type which has a few
different variants:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn generate_random_number() -&gt; i32 {
    // Implementation based on https://xkcd.com/221/
    4  // Chosen by fair dice roll. Guaranteed to be random.
}

#[derive(Debug)]
enum CoinFlip {
    Heads,
    Tails,
}

fn flip_coin() -&gt; CoinFlip {
    let random_number = generate_random_number();
    if random_number % 2 == 0 {
        return CoinFlip::Heads;
    } else {
        return CoinFlip::Tails;
    }
}

fn main() {
    println!(&quot;You got: {:?}&quot;, flip_coin());
}</code></pre></pre>
<details>
<p>Key Points:</p>
<ul>
<li>Enumerations allow you to collect a set of values under one type</li>
<li>This page offers an enum type <code>CoinFlip</code> with two variants <code>Heads</code> and <code>Tails</code>. You might note the namespace when using variants.</li>
<li>This might be a good time to compare Structs and Enums:
<ul>
<li>In both, you can have a simple version without fields (unit struct) or one with different types of fields (variant payloads). </li>
<li>In both, associated functions are defined within an <code>impl</code> block.</li>
<li>You could even implement the different variants of an enum with separate structs but then they wouldn‚Äôt be the same type as they would if they were all defined in an enum. </li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variant-payloads"><a class="header" href="#variant-payloads">Variant Payloads</a></h1>
<p>You can define richer enums where the variants carry data. You can then use the
<code>match</code> statement to extract the data from each variant:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum WebEvent {
    PageLoad,                 // Variant without payload
    KeyPress(char),           // Tuple struct variant
    Click { x: i64, y: i64 }, // Full struct variant
}

#[rustfmt::skip]
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad       =&gt; println!(&quot;page loaded&quot;),
        WebEvent::KeyPress(c)    =&gt; println!(&quot;pressed '{c}'&quot;),
        WebEvent::Click { x, y } =&gt; println!(&quot;clicked at x={x}, y={y}&quot;),
    }
}

fn main() {
    let load = WebEvent::PageLoad;
    let press = WebEvent::KeyPress('x');
    let click = WebEvent::Click { x: 20, y: 80 };

    inspect(load);
    inspect(press);
    inspect(click);
}</code></pre></pre>
<details>
<ul>
<li>The values in the enum variants can only be accessed after being pattern matched. The pattern binds references to the fields in the ‚Äúmatch arm‚Äù after the <code>=&gt;</code>.
<ul>
<li>The expression is matched against the patterns from top to bottom. There is no fall-through like in C or C++.</li>
<li>The match expression has a value. The value is the last expression in the match arm which was executed.</li>
<li>Starting from the top we look for what pattern matches the value then run the code following the arrow. Once we find a match, we stop. </li>
</ul>
</li>
<li>Demonstrate what happens when the search is inexhaustive. Note the advantage the Rust compiler provides by confirming when all cases are handled. </li>
<li><code>match</code> inspects a hidden discriminant field in the <code>enum</code>.</li>
<li>It is possible to retrieve the discriminant by calling <code>std::mem::discriminant()</code>
<ul>
<li>This is useful, for example, if implementing <code>PartialEq</code> for structs where comparing field values doesn‚Äôt affect equality.</li>
</ul>
</li>
<li><code>WebEvent::Click { ... }</code> is not exactly the same as <code>WebEvent::Click(Click)</code> with a top level <code>struct Click { ... }</code>. The inlined version cannot implement traits, for example.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-sizes"><a class="header" href="#enum-sizes">Enum Sizes</a></h1>
<p>Rust enums are packed tightly, taking constraints due to alignment into account:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::any::type_name;
use std::mem::{align_of, size_of};

fn dbg_size&lt;T&gt;() {
    println!(&quot;{}: size {} bytes, align: {} bytes&quot;,
        type_name::&lt;T&gt;(), size_of::&lt;T&gt;(), align_of::&lt;T&gt;());
}

enum Foo {
    A,
    B,
}

fn main() {
    dbg_size::&lt;Foo&gt;();
}</code></pre></pre>
<ul>
<li>See the <a href="https://doc.rust-lang.org/reference/type-layout.html">Rust Reference</a>.</li>
</ul>
<details>
<p>Key Points:</p>
<ul>
<li>
<p>Internally Rust is using a field (discriminant) to keep track of the enum variant.</p>
</li>
<li>
<p>You can control the discriminant if needed (e.g., for compatibility with C):</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[repr(u32)]
enum Bar {
    A,  // 0
    B = 10000,
    C,  // 10001
}

fn main() {
    println!(&quot;A: {}&quot;, Bar::A as u32);
    println!(&quot;B: {}&quot;, Bar::B as u32);
    println!(&quot;C: {}&quot;, Bar::C as u32);
}</code></pre></pre>
<p>Without <code>repr</code>, the discriminant type takes 2 bytes, because 10001 fits 2
bytes.</p>
</li>
<li>
<p>Try out other types such as</p>
<ul>
<li><code>dbg_size!(bool)</code>: size 1 bytes, align: 1 bytes,</li>
<li><code>dbg_size!(Option&lt;bool&gt;)</code>: size 1 bytes, align: 1 bytes (niche optimization, see below),</li>
<li><code>dbg_size!(&amp;i32)</code>: size 8 bytes, align: 8 bytes (on a 64-bit machine),</li>
<li><code>dbg_size!(Option&lt;&amp;i32&gt;)</code>: size 8 bytes, align: 8 bytes (null pointer optimization, see below).</li>
</ul>
</li>
<li>
<p>Niche optimization: Rust will merge unused bit patterns for the enum
discriminant.</p>
</li>
<li>
<p>Null pointer optimization: For <a href="https://doc.rust-lang.org/std/option/#representation">some
types</a>, Rust guarantees
that <code>size_of::&lt;T&gt;()</code> equals <code>size_of::&lt;Option&lt;T&gt;&gt;()</code>.</p>
<p>Example code if you want to show how the bitwise representation <em>may</em> look like in practice.
It‚Äôs important to note that the compiler provides no guarantees regarding this representation, therefore this is totally unsafe.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::mem::transmute;

macro_rules! dbg_bits {
    ($e:expr, $bit_type:ty) =&gt; {
        println!(&quot;- {}: {:#x}&quot;, stringify!($e), transmute::&lt;_, $bit_type&gt;($e));
    };
}

fn main() {
    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise
    // representation of types.
    unsafe {
        println!(&quot;Bitwise representation of bool&quot;);
        dbg_bits!(false, u8);
        dbg_bits!(true, u8);

        println!(&quot;Bitwise representation of Option&lt;bool&gt;&quot;);
        dbg_bits!(None::&lt;bool&gt;, u8);
        dbg_bits!(Some(false), u8);
        dbg_bits!(Some(true), u8);

        println!(&quot;Bitwise representation of Option&lt;Option&lt;bool&gt;&gt;&quot;);
        dbg_bits!(Some(Some(false)), u8);
        dbg_bits!(Some(Some(true)), u8);
        dbg_bits!(Some(None::&lt;bool&gt;), u8);
        dbg_bits!(None::&lt;Option&lt;bool&gt;&gt;, u8);

        println!(&quot;Bitwise representation of Option&lt;&amp;i32&gt;&quot;);
        dbg_bits!(None::&lt;&amp;i32&gt;, usize);
        dbg_bits!(Some(&amp;0i32), usize);
    }
}</code></pre></pre>
<p>More complex example if you want to discuss what happens when we chain more than 256 <code>Option</code>s together.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#![recursion_limit = &quot;1000&quot;]

use std::mem::transmute;

macro_rules! dbg_bits {
    ($e:expr, $bit_type:ty) =&gt; {
        println!(&quot;- {}: {:#x}&quot;, stringify!($e), transmute::&lt;_, $bit_type&gt;($e));
    };
}

// Macro to wrap a value in 2^n Some() where n is the number of &quot;@&quot; signs.
// Increasing the recursion limit is required to evaluate this macro.
macro_rules! many_options {
    ($value:expr) =&gt; { Some($value) };
    ($value:expr, @) =&gt; {
        Some(Some($value))
    };
    ($value:expr, @ $($more:tt)+) =&gt; {
        many_options!(many_options!($value, $($more)+), $($more)+)
    };
}

fn main() {
    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise
    // representation of types.
    unsafe {
        assert_eq!(many_options!(false), Some(false));
        assert_eq!(many_options!(false, @), Some(Some(false)));
        assert_eq!(many_options!(false, @@), Some(Some(Some(Some(false)))));

        println!(&quot;Bitwise representation of a chain of 128 Option's.&quot;);
        dbg_bits!(many_options!(false, @@@@@@@), u8);
        dbg_bits!(many_options!(true, @@@@@@@), u8);

        println!(&quot;Bitwise representation of a chain of 256 Option's.&quot;);
        dbg_bits!(many_options!(false, @@@@@@@@), u16);
        dbg_bits!(many_options!(true, @@@@@@@@), u16);

        println!(&quot;Bitwise representation of a chain of 257 Option's.&quot;);
        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);
        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);
        dbg_bits!(many_options!(None::&lt;bool&gt;, @@@@@@@@), u16);
    }
}</code></pre></pre>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods-1"><a class="header" href="#methods-1">Methods</a></h1>
<p>Rust allows you to associate functions with your new types. You do this with an
<code>impl</code> block:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

impl Person {
    fn say_hello(&amp;self) {
        println!(&quot;Hello, my name is {}&quot;, self.name);
    }
}

fn main() {
    let peter = Person {
        name: String::from(&quot;Peter&quot;),
        age: 27,
    };
    peter.say_hello();
}</code></pre></pre>
<details>
<p>Key Points:</p>
<ul>
<li>It can be helpful to introduce methods by comparing them to functions.
<ul>
<li>Methods are called on an instance of a type (such as a struct or enum), the first parameter represents the instance as <code>self</code>.</li>
<li>Developers may choose to use methods to take advantage of method receiver syntax and to help keep them more organized. By using methods we can keep all the implementation code in one predictable place.</li>
</ul>
</li>
<li>Point out the use of the keyword <code>self</code>, a method receiver.
<ul>
<li>Show that it is an abbreviated term for <code>self: Self</code> and perhaps show how the struct name could also be used.</li>
<li>Explain that <code>Self</code> is a type alias for the type the <code>impl</code> block is in and can be used elsewhere in the block.</li>
<li>Note how <code>self</code> is used like other structs and dot notation can be used to refer to individual fields.</li>
<li>This might be a good time to demonstrate how the <code>&amp;self</code> differs from <code>self</code> by modifying the code and trying to run say_hello twice.</li>
</ul>
</li>
<li>We describe the distinction between method receivers next.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="method-receiver"><a class="header" href="#method-receiver">Method Receiver</a></h1>
<p>The <code>&amp;self</code> above indicates that the method borrows the object immutably. There
are other possible receivers for a method:</p>
<ul>
<li><code>&amp;self</code>: borrows the object from the caller using a shared and immutable
reference. The object can be used again afterwards.</li>
<li><code>&amp;mut self</code>: borrows the object from the caller using a unique and mutable
reference. The object can be used again afterwards.</li>
<li><code>self</code>: takes ownership of the object and moves it away from the caller. The
method becomes the owner of the object. The object will be dropped (deallocated)
when the method returns, unless its ownership is explicitly
transmitted. Complete ownership does not automatically mean mutability.</li>
<li><code>mut self</code>: same as above, but the method can mutate the object. </li>
<li>No receiver: this becomes a static method on the struct. Typically used to
create constructors which are called <code>new</code> by convention.</li>
</ul>
<p>Beyond variants on <code>self</code>, there are also
<a href="https://doc.rust-lang.org/reference/special-types-and-traits.html">special wrapper types</a>
allowed to be receiver types, such as <code>Box&lt;Self&gt;</code>.</p>
<details>
<p>Consider emphasizing ‚Äúshared and immutable‚Äù and ‚Äúunique and mutable‚Äù. These constraints always come
together in Rust due to borrow checker rules, and <code>self</code> is no exception. It isn‚Äôt possible to
reference a struct from multiple locations and call a mutating (<code>&amp;mut self</code>) method on it.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example"><a class="header" href="#example">Example</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Race {
    name: String,
    laps: Vec&lt;i32&gt;,
}

impl Race {
    fn new(name: &amp;str) -&gt; Race {  // No receiver, a static method
        Race { name: String::from(name), laps: Vec::new() }
    }

    fn add_lap(&amp;mut self, lap: i32) {  // Exclusive borrowed read-write access to self
        self.laps.push(lap);
    }

    fn print_laps(&amp;self) {  // Shared and read-only borrowed access to self
        println!(&quot;Recorded {} laps for {}:&quot;, self.laps.len(), self.name);
        for (idx, lap) in self.laps.iter().enumerate() {
            println!(&quot;Lap {idx}: {lap} sec&quot;);
        }
    }

    fn finish(self) {  // Exclusive ownership of self
        let total = self.laps.iter().sum::&lt;i32&gt;();
        println!(&quot;Race {} is finished, total lap time: {}&quot;, self.name, total);
    }
}

fn main() {
    let mut race = Race::new(&quot;Monaco Grand Prix&quot;);
    race.add_lap(70);
    race.add_lap(68);
    race.print_laps();
    race.add_lap(71);
    race.print_laps();
    race.finish();
    // race.add_lap(42);
}</code></pre></pre>
<details>
<p>Key Points:</p>
<ul>
<li>All four methods here use a different method receiver.
<ul>
<li>You can point out how that changes what the function can do with the variable values and if/how it can be used again in <code>main</code>.</li>
<li>You can showcase the error that appears when trying to call <code>finish</code> twice.</li>
</ul>
</li>
<li>Note that although the method receivers are different, the non-static functions are called the same way in the main body. Rust enables automatic referencing and dereferencing when calling methods. Rust automatically adds in the <code>&amp;</code>, <code>*</code>, <code>muts</code> so that that object matches the method signature.</li>
<li>You might point out that <code>print_laps</code> is using a vector that is iterated over. We describe vectors in more detail in the afternoon. </li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<p>The <code>match</code> keyword let you match a value against one or more <em>patterns</em>. The
comparisons are done from top to bottom and the first match wins.</p>
<p>The patterns can be simple values, similarly to <code>switch</code> in C and C++:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let input = 'x';

    match input {
        'q'                   =&gt; println!(&quot;Quitting&quot;),
        'a' | 's' | 'w' | 'd' =&gt; println!(&quot;Moving around&quot;),
        '0'..='9'             =&gt; println!(&quot;Number input&quot;),
        _                     =&gt; println!(&quot;Something else&quot;),
    }
}</code></pre></pre>
<p>The <code>_</code> pattern is a wildcard pattern which matches any value.</p>
<details>
<p>Key Points:</p>
<ul>
<li>You might point out how some specific characters are being used when in a pattern
<ul>
<li><code>|</code> as an <code>or</code></li>
<li><code>..</code> can expand as much as it needs to be</li>
<li><code>1..=5</code> represents an inclusive range</li>
<li><code>_</code> is a wild card</li>
</ul>
</li>
<li>It can be useful to show how binding works, by for instance replacing a wildcard character with a variable, or removing the quotes around <code>q</code>.</li>
<li>You can demonstrate matching on a reference.</li>
<li>This might be a good time to bring up the concept of irrefutable patterns, as the term can show up in error messages.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructuring-enums"><a class="header" href="#destructuring-enums">Destructuring Enums</a></h1>
<p>Patterns can also be used to bind variables to parts of your values. This is how
you inspect the structure of your types. Let us start with a simple <code>enum</code> type:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Result {
    Ok(i32),
    Err(String),
}

fn divide_in_two(n: i32) -&gt; Result {
    if n % 2 == 0 {
        Result::Ok(n / 2)
    } else {
        Result::Err(format!(&quot;cannot divide {n} into two equal parts&quot;))
    }
}

fn main() {
    let n = 100;
    match divide_in_two(n) {
        Result::Ok(half) =&gt; println!(&quot;{n} divided in two is {half}&quot;),
        Result::Err(msg) =&gt; println!(&quot;sorry, an error happened: {msg}&quot;),
    }
}</code></pre></pre>
<p>Here we have used the arms to <em>destructure</em> the <code>Result</code> value. In the first
arm, <code>half</code> is bound to the value inside the <code>Ok</code> variant. In the second arm,
<code>msg</code> is bound to the error message.</p>
<details>
<p>‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¶‡¶ø‡¶ï:</p>
<ul>
<li>The <code>if</code>/<code>else</code> expression is returning an enum that is later unpacked with a <code>match</code>.</li>
<li>You can try adding a third variant to the enum definition and displaying the errors when running the code. Point out the places where your code is now inexhaustive and how the compiler tries to give you hints.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructuring-structs"><a class="header" href="#destructuring-structs">Destructuring Structs</a></h1>
<p>You can also destructure <code>structs</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Foo {
    x: (u32, u32),
    y: u32,
}

#[rustfmt::skip]
fn main() {
    let foo = Foo { x: (1, 2), y: 3 };
    match foo {
        Foo { x: (1, b), y } =&gt; println!(&quot;x.0 = 1, b = {b}, y = {y}&quot;),
        Foo { y: 2, x: i }   =&gt; println!(&quot;y = 2, x = {i:?}&quot;),
        Foo { y, .. }        =&gt; println!(&quot;y = {y}, other fields were ignored&quot;),
    }
}</code></pre></pre>
<details>
<ul>
<li>Change the literal values in <code>foo</code> to match with the other patterns.</li>
<li>Add a new field to <code>Foo</code> and make changes to the pattern as needed.</li>
<li>The distinction between a capture and a constant expression can be hard to
spot. Try changing the <code>2</code> in the second arm to a variable, and see that it subtly
doesn‚Äôt work. Change it to a <code>const</code> and see it working again.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructuring-arrays"><a class="header" href="#destructuring-arrays">Destructuring Arrays</a></h1>
<p>You can destructure arrays, tuples, and slices by matching on their elements:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[rustfmt::skip]
fn main() {
    let triple = [0, -2, 3];
    println!(&quot;Tell me about {triple:?}&quot;);
    match triple {
        [0, y, z] =&gt; println!(&quot;First is 0, y = {y}, and z = {z}&quot;),
        [1, ..]   =&gt; println!(&quot;First is 1 and the rest were ignored&quot;),
        _         =&gt; println!(&quot;All elements were ignored&quot;),
    }
}</code></pre></pre>
<details>
<ul>
<li>
<p>Destructuring of slices of unknown length also works with patterns of fixed length.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    inspect(&amp;[0, -2, 3]);
    inspect(&amp;[0, -2, 3, 4]);
}

#[rustfmt::skip]
fn inspect(slice: &amp;[i32]) {
    println!(&quot;Tell me about {slice:?}&quot;);
    match slice {
        &amp;[0, y, z] =&gt; println!(&quot;First is 0, y = {y}, and z = {z}&quot;),
        &amp;[1, ..]   =&gt; println!(&quot;First is 1 and the rest were ignored&quot;),
        _          =&gt; println!(&quot;All elements were ignored&quot;),
    }
}</code></pre></pre>
</li>
<li>
<p>Create a new pattern using <code>_</code> to represent an element. </p>
</li>
<li>
<p>Add more values to the array.</p>
</li>
<li>
<p>Point out that how <code>..</code> will expand to account for different number of elements.</p>
</li>
<li>
<p>Show matching against the tail with patterns <code>[.., b]</code> and <code>[a@..,b]</code></p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-guards"><a class="header" href="#match-guards">Match Guards</a></h1>
<p>When matching, you can add a <em>guard</em> to a pattern. This is an arbitrary Boolean
expression which will be executed if the pattern matches:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[rustfmt::skip]
fn main() {
    let pair = (2, -2);
    println!(&quot;Tell me about {pair:?}&quot;);
    match pair {
        (x, y) if x == y     =&gt; println!(&quot;These are twins&quot;),
        (x, y) if x + y == 0 =&gt; println!(&quot;Antimatter, kaboom!&quot;),
        (x, _) if x % 2 == 1 =&gt; println!(&quot;The first one is odd&quot;),
        _                    =&gt; println!(&quot;No correlation...&quot;),
    }
}</code></pre></pre>
<details>
<p>Key Points:</p>
<ul>
<li>Match guards as a separate syntax feature are important and necessary when we wish to concisely express more complex ideas than patterns alone would allow.</li>
<li>They are not the same as separate <code>if</code> expression inside of the match arm. An <code>if</code> expression inside of the branch block (after <code>=&gt;</code>) happens after the match arm is selected. Failing the <code>if</code> condition inside of that block won‚Äôt result in other arms
of the original <code>match</code> expression being considered.</li>
<li>You can use the variables defined in the pattern in your if expression.</li>
<li>The condition defined in the guard applies to every expression in a pattern with an <code>|</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶¶‡¶¨‡¶ø‡¶§‡ßÄ‡ßü-‡¶¶‡¶ø‡¶®‡¶É-‡¶∏‡¶ï‡¶æ‡¶≤‡ßá‡¶∞-‡¶Ö‡¶®‡ßÅ‡¶∂‡¶ø‡¶≤‡¶®"><a class="header" href="#‡¶¶‡¶¨‡¶ø‡¶§‡ßÄ‡ßü-‡¶¶‡¶ø‡¶®‡¶É-‡¶∏‡¶ï‡¶æ‡¶≤‡ßá‡¶∞-‡¶Ö‡¶®‡ßÅ‡¶∂‡¶ø‡¶≤‡¶®">‡¶¶‡ßç‡¶¨‡¶ø‡¶§‡ßÄ‡ßü ‡¶¶‡¶ø‡¶®‡¶É ‡¶∏‡¶ï‡¶æ‡¶≤‡ßá‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶∂‡¶ø‡¶≤‡¶®</a></h1>
<p>We will look at implementing methods in two contexts:</p>
<ul>
<li>
<p>Simple struct which tracks health statistics.</p>
</li>
<li>
<p>Multiple structs and enums for a drawing library.</p>
</li>
</ul>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/day-2/solutions-morning.html">solutions</a> provided.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="health-statistics"><a class="header" href="#health-statistics">Health Statistics</a></h1>
<p>You‚Äôre working on implementing a health-monitoring system. As part of that, you
need to keep track of users‚Äô health statistics.</p>
<p>You‚Äôll start with some stubbed functions in an <code>impl</code> block as well as a <code>User</code>
struct definition. Your goal is to implement the stubbed out methods on the
<code>User</code> <code>struct</code> defined in the <code>impl</code> block.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing
methods:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub struct User {
    name: String,
    age: u32,
    height: f32,
    visit_count: usize,
    last_blood_pressure: Option&lt;(u32, u32)&gt;,
}

pub struct Measurements {
    height: f32,
    blood_pressure: (u32, u32),
}

pub struct HealthReport&lt;'a&gt; {
    patient_name: &amp;'a str,
    visit_count: u32,
    height_change: f32,
    blood_pressure_change: Option&lt;(i32, i32)&gt;,
}

impl User {
    pub fn new(name: String, age: u32, height: f32) -&gt; Self {
        unimplemented!()
    }

    pub fn name(&amp;self) -&gt; &amp;str {
        unimplemented!()
    }

    pub fn age(&amp;self) -&gt; u32 {
        unimplemented!()
    }

    pub fn height(&amp;self) -&gt; f32 {
        unimplemented!()
    }

    pub fn doctor_visits(&amp;self) -&gt; u32 {
        unimplemented!()
    }

    pub fn set_age(&amp;mut self, new_age: u32) {
        unimplemented!()
    }

    pub fn set_height(&amp;mut self, new_height: f32) {
        unimplemented!()
    }

    pub fn visit_doctor(&amp;mut self, measurements: Measurements) -&gt; HealthReport {
        unimplemented!()
    }
}

fn main() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    println!(&quot;I'm {} and my age is {}&quot;, bob.name(), bob.age());
}

#[test]
fn test_height() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.height(), 155.2);
}

#[test]
fn test_set_age() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.age(), 32);
    bob.set_age(33);
    assert_eq!(bob.age(), 33);
}

#[test]
fn test_visit() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.doctor_visits(), 0);
    let report = bob.visit_doctor(Measurements {
        height: 156.1,
        blood_pressure: (120, 80),
    });
    assert_eq!(report.patient_name, &quot;Bob&quot;);
    assert_eq!(report.visit_count, 1);
    assert_eq!(report.blood_pressure_change, None);

    let report = bob.visit_doctor(Measurements {
        height: 156.1,
        blood_pressure: (115, 76),
    });

    assert_eq!(report.visit_count, 2);
    assert_eq!(report.blood_pressure_change, Some((-5, -4)));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polygon-struct"><a class="header" href="#polygon-struct">Polygon Struct</a></h1>
<p>We will create a <code>Polygon</code> struct which contain some points. Copy the code below
to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing methods to make the
tests pass:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub struct Point {
    // add fields
}

impl Point {
    // add methods
}

pub struct Polygon {
    // add fields
}

impl Polygon {
    // add methods
}

pub struct Circle {
    // add fields
}

impl Circle {
    // add methods
}

pub enum Shape {
    Polygon(Polygon),
    Circle(Circle),
}

#[cfg(test)]
mod tests {
    use super::*;

    fn round_two_digits(x: f64) -&gt; f64 {
        (x * 100.0).round() / 100.0
    }

    #[test]
    fn test_point_magnitude() {
        let p1 = Point::new(12, 13);
        assert_eq!(round_two_digits(p1.magnitude()), 17.69);
    }

    #[test]
    fn test_point_dist() {
        let p1 = Point::new(10, 10);
        let p2 = Point::new(14, 13);
        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);
    }

    #[test]
    fn test_point_add() {
        let p1 = Point::new(16, 16);
        let p2 = p1 + Point::new(-4, 3);
        assert_eq!(p2, Point::new(12, 19));
    }

    #[test]
    fn test_polygon_left_most_point() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);
        assert_eq!(poly.left_most_point(), Some(p1));
    }

    #[test]
    fn test_polygon_iter() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);

        let points = poly.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);
    }

    #[test]
    fn test_shape_perimeters() {
        let mut poly = Polygon::new();
        poly.add_point(Point::new(12, 13));
        poly.add_point(Point::new(17, 11));
        poly.add_point(Point::new(16, 16));
        let shapes = vec![
            Shape::from(poly),
            Shape::from(Circle::new(Point::new(10, 20), 5)),
        ];
        let perimeters = shapes
            .iter()
            .map(Shape::perimeter)
            .map(round_two_digits)
            .collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(perimeters, vec![15.48, 31.42]);
    }
}

#[allow(dead_code)]
fn main() {}</code></pre></pre>
<details>
<p>Since the method signatures are missing from the problem statements, the key part
of the exercise is to specify those correctly. You don‚Äôt have to modify the tests.</p>
<p>Other interesting parts of the exercise:</p>
<ul>
<li>Derive a <code>Copy</code> trait for some structs, as in tests the methods sometimes don‚Äôt borrow their arguments.</li>
<li>Discover that <code>Add</code> trait must be implemented for two objects to be addable via ‚Äú+‚Äù. Note that we do not discuss generics until Day 3.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>As we have seen, <code>if</code> is an expression in Rust. It is used to conditionally
evaluate one of two blocks, but the blocks can have a value which then becomes
the value of the <code>if</code> expression. Other control flow expressions work similarly
in Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks"><a class="header" href="#blocks">Blocks</a></h1>
<p>A block in Rust contains a sequence of expressions.
Each block has a value and a type,
which are those of the last expression of the block:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = {
        let y = 10;
        println!(&quot;y: {y}&quot;);
        let z = {
            let w = {
                3 + 4
            };
            println!(&quot;w: {w}&quot;);
            y * w
        };
        println!(&quot;z: {z}&quot;);
        z - y
    };
    println!(&quot;x: {x}&quot;);
}</code></pre></pre>
<p>If the last expression ends with <code>;</code>, then the resulting value and type is <code>()</code>.</p>
<p>The same rule is used for functions: the value of the function body is the
return value:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn double(x: i32) -&gt; i32 {
    x + x
}

fn main() {
    println!(&quot;doubled: {}&quot;, double(7));
}</code></pre></pre>
<details>
<p>Key Points:</p>
<ul>
<li>The point of this slide is to show that blocks have a type and value in Rust. </li>
<li>You can show how the value of the block changes by changing the last line in the block. For instance, adding/removing a semicolon or using a <code>return</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-expressions"><a class="header" href="#if-expressions"><code>if</code> expressions</a></h1>
<p>You use <a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions"><code>if</code>
expressions</a>
exactly like <code>if</code> statements in other languages:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut x = 10;
    if x % 2 == 0 {
        x = x / 2;
    } else {
        x = 3 * x + 1;
    }
}</code></pre></pre>
<p>In addition, you can use <code>if</code> as an expression. The last expression of each
block becomes the value of the <code>if</code> expression:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut x = 10;
    x = if x % 2 == 0 {
        x / 2
    } else {
        3 * x + 1
    };
}</code></pre></pre>
<details>
<p>Because <code>if</code> is an expression and must have a particular type, both of its branch blocks must have the same type. Consider showing what happens if you add <code>;</code> after <code>x / 2</code> in the second example.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-let-expressions"><a class="header" href="#if-let-expressions"><code>if let</code> expressions</a></h1>
<p>The <a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions"><code>if let</code>
expression</a>
lets you execute different code depending on whether a value matches a pattern:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arg = std::env::args().next();
    if let Some(value) = arg {
        println!(&quot;Program name: {value}&quot;);
    } else {
        println!(&quot;Missing name?&quot;);
    }
}</code></pre></pre>
<p>See <a href="pattern-matching.html">pattern matching</a> for more details on patterns in
Rust.</p>
<details>
<ul>
<li>
<p>Unlike <code>match</code>, <code>if let</code> does not have to cover all branches. This can make it more concise than <code>match</code>.</p>
</li>
<li>
<p>A common usage is handling <code>Some</code> values when working with <code>Option</code>.</p>
</li>
<li>
<p>Unlike <code>match</code>, <code>if let</code> does not support guard clauses for pattern matching.</p>
</li>
<li>
<p>Since 1.65, a similar <a href="https://doc.rust-lang.org/rust-by-example/flow_control/let_else.html">let-else</a> construct allows to do a destructuring assignment, or if it fails, execute a block which is required to abort normal control flow (with <code>panic</code>/<code>return</code>/<code>break</code>/<code>continue</code>):</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!(&quot;{:?}&quot;, second_word_to_upper(&quot;foo bar&quot;));
}
 
fn second_word_to_upper(s: &amp;str) -&gt; Option&lt;String&gt; {
    let mut it = s.split(' ');
    let (Some(_), Some(item)) = (it.next(), it.next()) else {
        return None;
    };
    Some(item.to_uppercase())
}
</code></pre></pre>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-loops"><a class="header" href="#while-loops"><code>while</code> loops</a></h1>
<p>The <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops"><code>while</code> keyword</a>
works very similar to other languages:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut x = 10;
    while x != 1 {
        x = if x % 2 == 0 {
            x / 2
        } else {
            3 * x + 1
        };
    }
    println!(&quot;Final x: {x}&quot;);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-let-loops"><a class="header" href="#while-let-loops"><code>while let</code> loops</a></h1>
<p>Like with <code>if let</code>, there is a <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a>
variant which repeatedly tests a value against a pattern:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v = vec![10, 20, 30];
    let mut iter = v.into_iter();

    while let Some(x) = iter.next() {
        println!(&quot;x: {x}&quot;);
    }
}</code></pre></pre>
<p>Here the iterator returned by <code>v.into_iter()</code> will return a <code>Option&lt;i32&gt;</code> on every
call to <code>next()</code>. It returns <code>Some(x)</code> until it is done, after which it will
return <code>None</code>. The <code>while let</code> lets us keep iterating through all items.</p>
<p>See <a href="pattern-matching.html">pattern matching</a> for more details on patterns in
Rust.</p>
<details>
<ul>
<li>Point out that the <code>while let</code> loop will keep going as long as the value matches the pattern.</li>
<li>You could rewrite the <code>while let</code> loop as an infinite loop with an if statement that breaks when there is no value to unwrap for <code>iter.next()</code>. The <code>while let</code> provides syntactic sugar for the above scenario.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-loops-1"><a class="header" href="#for-loops-1"><code>for</code> loops</a></h1>
<p>The <a href="https://doc.rust-lang.org/std/keyword.for.html"><code>for</code> loop</a> is closely
related to the <a href="control-flow/while-let-expressions.html"><code>while let</code> loop</a>. It will
automatically call <code>into_iter()</code> on the expression and then iterate over it:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v = vec![10, 20, 30];

    for x in v {
        println!(&quot;x: {x}&quot;);
    }
    
    for i in (0..10).step_by(2) {
        println!(&quot;i: {i}&quot;);
    }
}</code></pre></pre>
<p>You can use <code>break</code> and <code>continue</code> here as usual.</p>
<details>
<ul>
<li>Index iteration is not a special syntax in Rust for just that case.</li>
<li><code>(0..10)</code> is a range that implements an <code>Iterator</code> trait. </li>
<li><code>step_by</code> is a method that returns another <code>Iterator</code> that skips every other element. </li>
<li>Modify the elements in the vector and explain the compiler errors. Change vector <code>v</code> to be mutable and the for loop to <code>for x in v.iter_mut()</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loop-expressions"><a class="header" href="#loop-expressions"><code>loop</code> expressions</a></h1>
<p>Finally, there is a <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#infinite-loops"><code>loop</code> keyword</a>
which creates an endless loop.</p>
<p>Here you must either <code>break</code> or <code>return</code> to stop the loop:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut x = 10;
    loop {
        x = if x % 2 == 0 {
            x / 2
        } else {
            3 * x + 1
        };
        if x == 1 {
            break;
        }
    }
    println!(&quot;Final x: {x}&quot;);
}</code></pre></pre>
<details>
<ul>
<li>Break the <code>loop</code> with a value (e.g. <code>break 8</code>) and print it out.</li>
<li>Note that <code>loop</code> is the only looping construct which returns a non-trivial
value. This is because it‚Äôs guaranteed to be entered at least once (unlike
<code>while</code> and <code>for</code> loops).</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-expressions"><a class="header" href="#match-expressions"><code>match</code> expressions</a></h1>
<p>The <a href="https://doc.rust-lang.org/reference/expressions/match-expr.html"><code>match</code> keyword</a>
is used to match a value against one or more patterns. In that sense, it works
like a series of <code>if let</code> expressions:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    match std::env::args().next().as_deref() {
        Some(&quot;cat&quot;) =&gt; println!(&quot;Will do cat things&quot;),
        Some(&quot;ls&quot;)  =&gt; println!(&quot;Will ls some files&quot;),
        Some(&quot;mv&quot;)  =&gt; println!(&quot;Let's move some files&quot;),
        Some(&quot;rm&quot;)  =&gt; println!(&quot;Uh, dangerous!&quot;),
        None        =&gt; println!(&quot;Hmm, no program name?&quot;),
        _           =&gt; println!(&quot;Unknown program name!&quot;),
    }
}</code></pre></pre>
<p>Like <code>if let</code>, each match arm must have the same type. The type is the last
expression of the block, if any. In the example above, the type is <code>()</code>.</p>
<p>See <a href="pattern-matching.html">pattern matching</a> for more details on patterns in
Rust.</p>
<details>
<ul>
<li>Save the match expression to a variable and print it out.</li>
<li>Remove <code>.as_deref()</code> and explain the error.
<ul>
<li><code>std::env::args().next()</code> returns an <code>Option&lt;String&gt;</code>, but we cannot match against <code>String</code>.</li>
<li><code>as_deref()</code> transforms an <code>Option&lt;T&gt;</code> to <code>Option&lt;&amp;T::Target&gt;</code>. In our case, this turns <code>Option&lt;String&gt;</code> into <code>Option&lt;&amp;str&gt;</code>.</li>
<li>We can now use pattern matching to match against the <code>&amp;str</code> inside <code>Option</code>.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="break-and-continue"><a class="header" href="#break-and-continue"><code>break</code> and <code>continue</code></a></h1>
<ul>
<li>If you want to exit a loop early, use <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions"><code>break</code></a>,</li>
<li>If you want to immediately start
the next iteration use <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions"><code>continue</code></a>.</li>
</ul>
<p>Both <code>continue</code> and <code>break</code> can optionally take a label argument which is used
to break out of nested loops:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let v = vec![10, 20, 30];
    let mut iter = v.into_iter();
    'outer: while let Some(x) = iter.next() {
        println!(&quot;x: {x}&quot;);
        let mut i = 0;
        while i &lt; x {
            println!(&quot;x: {x}, i: {i}&quot;);
            i += 1;
            if i == 3 {
                break 'outer;
            }
        }
    }
}</code></pre></pre>
<p>In this case we break the outer loop after 3 iterations of the inner loop.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<p>Rust comes with a standard library which helps establish a set of common types
used by Rust library and programs. This way, two libraries can work together
smoothly because they both use the same <code>String</code> type.</p>
<p>The common vocabulary types include:</p>
<ul>
<li>
<p><a href="std/option-result.html"><code>Option</code> and <code>Result</code></a> types: used for optional values
and <a href="error-handling.html">error handling</a>.</p>
</li>
<li>
<p><a href="std/string.html"><code>String</code></a>: the default string type used for owned data.</p>
</li>
<li>
<p><a href="std/vec.html"><code>Vec</code></a>: a standard extensible vector.</p>
</li>
<li>
<p><a href="std/hashmap.html"><code>HashMap</code></a>: a hash map type with a configurable hashing
algorithm.</p>
</li>
<li>
<p><a href="std/box.html"><code>Box</code></a>: an owned pointer for heap-allocated data.</p>
</li>
<li>
<p><a href="std/rc.html"><code>Rc</code></a>: a shared reference-counted pointer for heap-allocated data.</p>
</li>
</ul>
<details>
<ul>
<li>In fact, Rust contains several layers of the Standard Library: <code>core</code>, <code>alloc</code> and <code>std</code>. </li>
<li><code>core</code> includes the most basic types and functions that don‚Äôt depend on <code>libc</code>, allocator or
even the presence of an operating system. </li>
<li><code>alloc</code> includes types which require a global heap allocator, such as <code>Vec</code>, <code>Box</code> and <code>Arc</code>.</li>
<li>Embedded Rust applications often only use <code>core</code>, and sometimes <code>alloc</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option-and-result"><a class="header" href="#option-and-result"><code>Option</code> and <code>Result</code></a></h1>
<p>The types represent optional data:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let numbers = vec![10, 20, 30];
    let first: Option&lt;&amp;i8&gt; = numbers.first();
    println!(&quot;first: {first:?}&quot;);

    let idx: Result&lt;usize, usize&gt; = numbers.binary_search(&amp;10);
    println!(&quot;idx: {idx:?}&quot;);
}</code></pre></pre>
<details>
<ul>
<li><code>Option</code> and <code>Result</code> are widely used not just in the standard library.</li>
<li><code>Option&lt;&amp;T&gt;</code> has zero space overhead compared to <code>&amp;T</code>.</li>
<li><code>Result</code> is the standard type to implement error handling as we will see on Day 3.</li>
<li><code>binary_search</code> returns <code>Result&lt;usize, usize&gt;</code>.
<ul>
<li>If found, <code>Result::Ok</code> holds the index where the element is found.</li>
<li>Otherwise, <code>Result::Err</code> contains the index where such an element should be inserted.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> is the standard heap-allocated growable UTF-8 string buffer:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut s1 = String::new();
    s1.push_str(&quot;Hello&quot;);
    println!(&quot;s1: len = {}, capacity = {}&quot;, s1.len(), s1.capacity());

    let mut s2 = String::with_capacity(s1.len() + 1);
    s2.push_str(&amp;s1);
    s2.push('!');
    println!(&quot;s2: len = {}, capacity = {}&quot;, s2.len(), s2.capacity());

    let s3 = String::from(&quot;üá®üá≠&quot;);
    println!(&quot;s3: len = {}, number of chars = {}&quot;, s3.len(),
             s3.chars().count());
}</code></pre></pre>
<p><code>String</code> implements <a href="https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"><code>Deref&lt;Target = str&gt;</code></a>, which means that you can call all
<code>str</code> methods on a <code>String</code>.</p>
<details>
<ul>
<li><code>String::new</code> returns a new empty string, use <code>String::with_capacity</code> when you know how much data you want to push to the string.</li>
<li><code>String::len</code> returns the size of the <code>String</code> in bytes (which can be different from its length in characters).</li>
<li><code>String::chars</code> returns an iterator over the actual characters. Note that a <code>char</code> can be different from what a human will consider a ‚Äúcharacter‚Äù due to <a href="https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes.html">grapheme clusters</a>.</li>
<li>When people refer to strings they could either be talking about <code>&amp;str</code> or <code>String</code>.</li>
<li>When a type implements <code>Deref&lt;Target = T&gt;</code>, the compiler will let you transparently call methods from <code>T</code>.
<ul>
<li><code>String</code> implements <code>Deref&lt;Target = str&gt;</code> which transparently gives it access to <code>str</code>‚Äôs methods.</li>
<li>Write and compare <code>let s3 = s1.deref();</code> and  <code>let s3 = &amp;*s1</code>;.</li>
</ul>
</li>
<li><code>String</code> is implemented as a wrapper around a vector of bytes, many of the operations you see supported on vectors are also supported on <code>String</code>, but with some extra guarantees.</li>
<li>Compare the different ways to index a <code>String</code>:
<ul>
<li>To a character by using <code>s3.chars().nth(i).unwrap()</code> where <code>i</code> is in-bound, out-of-bounds.</li>
<li>To a substring by using <code>s3[0..4]</code>, where that slice is on character boundaries or not.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vec"><a class="header" href="#vec"><code>Vec</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> is the standard resizable heap-allocated buffer:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut v1 = Vec::new();
    v1.push(42);
    println!(&quot;v1: len = {}, capacity = {}&quot;, v1.len(), v1.capacity());

    let mut v2 = Vec::with_capacity(v1.len() + 1);
    v2.extend(v1.iter());
    v2.push(9999);
    println!(&quot;v2: len = {}, capacity = {}&quot;, v2.len(), v2.capacity());

    // Canonical macro to initialize a vector with elements.
    let mut v3 = vec![0, 0, 1, 2, 3, 4];

    // Retain only the even elements.
    v3.retain(|x| x % 2 == 0);
    println!(&quot;{v3:?}&quot;);

    // Remove consecutive duplicates.
    v3.dedup();
    println!(&quot;{v3:?}&quot;);
}</code></pre></pre>
<p><code>Vec</code> implements <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-%5BT%5D"><code>Deref&lt;Target = [T]&gt;</code></a>, which means that you can call slice
methods on a <code>Vec</code>.</p>
<details>
<ul>
<li><code>Vec</code> is a type of collection, along with <code>String</code> and <code>HashMap</code>. The data it contains is stored
on the heap. This means the amount of data doesn‚Äôt need to be  known at compile time. It can grow
or shrink at runtime.</li>
<li>Notice how <code>Vec&lt;T&gt;</code> is a generic type too, but you don‚Äôt have to specify <code>T</code> explicitly. As always
with Rust type inference, the <code>T</code> was established during the first <code>push</code> call.</li>
<li><code>vec![...]</code> is a canonical macro to use instead of <code>Vec::new()</code> and it supports adding initial
elements to the vector.</li>
<li>To index the vector you use <code>[</code> <code>]</code>, but they will panic if out of bounds. Alternatively, using
<code>get</code> will return an <code>Option</code>. The <code>pop</code> function will remove the last element.</li>
<li>Show iterating over a vector and mutating the value:
<code>for e in &amp;mut v { *e += 50; }</code></li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap"><code>HashMap</code></a></h1>
<p>Standard hash map with protection against HashDoS attacks:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;

fn main() {
    let mut page_counts = HashMap::new();
    page_counts.insert(&quot;Adventures of Huckleberry Finn&quot;.to_string(), 207);
    page_counts.insert(&quot;Grimms' Fairy Tales&quot;.to_string(), 751);
    page_counts.insert(&quot;Pride and Prejudice&quot;.to_string(), 303);

    if !page_counts.contains_key(&quot;Les Mis√©rables&quot;) {
        println!(&quot;We know about {} books, but not Les Mis√©rables.&quot;,
                 page_counts.len());
    }

    for book in [&quot;Pride and Prejudice&quot;, &quot;Alice's Adventure in Wonderland&quot;] {
        match page_counts.get(book) {
            Some(count) =&gt; println!(&quot;{book}: {count} pages&quot;),
            None =&gt; println!(&quot;{book} is unknown.&quot;)
        }
    }

    // Use the .entry() method to insert a value if nothing is found.
    for book in [&quot;Pride and Prejudice&quot;, &quot;Alice's Adventure in Wonderland&quot;] {
        let page_count: &amp;mut i32 = page_counts.entry(book.to_string()).or_insert(0);
        *page_count += 1;
    }

    println!(&quot;{page_counts:#?}&quot;);
}</code></pre></pre>
<details>
<ul>
<li>
<p><code>HashMap</code> is not defined in the prelude and needs to be brought into scope.</p>
</li>
<li>
<p>Try the following lines of code. The first line will see if a book is in the hashmap and if not return an alternative value. The second line will insert the alternative value in the hashmap if the book is not found.</p>
<pre><code class="language-rust ignore">  let pc1 = page_counts
      .get(&quot;Harry Potter and the Sorcerer's Stone &quot;)
      .unwrap_or(&amp;336);
  let pc2 = page_counts
      .entry(&quot;The Hunger Games&quot;.to_string())
      .or_insert(374);</code></pre>
</li>
<li>
<p>Unlike <code>vec!</code>, there is unfortunately no standard <code>hashmap!</code> macro.</p>
<ul>
<li>
<p>Although, since Rust 1.56, HashMap implements <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E"><code>From&lt;[(K, V); N]&gt;</code></a>, which allows us to easily initialize a hash map from a literal array:</p>
<pre><code class="language-rust ignore">  let page_counts = HashMap::from([
    (&quot;Harry Potter and the Sorcerer's Stone&quot;.to_string(), 336),
    (&quot;The Hunger Games&quot;.to_string(), 374),
  ]);</code></pre>
</li>
</ul>
</li>
<li>
<p>Alternatively HashMap can be built from any <code>Iterator</code> which yields key-value tuples.</p>
</li>
<li>
<p>We are showing <code>HashMap&lt;String, i32&gt;</code>, and avoid using <code>&amp;str</code> as key to make examples easier. Using references in collections can, of course, be done,
but it can lead into complications with the borrow checker.</p>
<ul>
<li>Try removing <code>to_string()</code> from the example above and see if it still compiles. Where do you think we might run into issues?</li>
</ul>
</li>
<li>
<p>This type has several ‚Äúmethod-specific‚Äù return types, such as <code>std::collections::hash_map::Keys</code>. These types often appear in searches of the Rust docs. Show students the docs for this type, and the helpful link back to the <code>keys</code> method.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box"><a class="header" href="#box"><code>Box</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a> is an owned pointer to data on the heap:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let five = Box::new(5);
    println!(&quot;five: {}&quot;, *five);
}</code></pre></pre>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="288" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="288" height="176"></rect><rect x="36" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><circle cx="52" cy="88" r="3" class="nofill"></circle><rect x="196" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><text x="218" y="92" >5</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="218" y="12" >Heap</text><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><line x1="232" y1="24" x2="240" y2="24" class="solid"></line><line x1="248" y1="24" x2="256" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><text x="42" y="60" >five</text><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><line x1="216" y1="152" x2="224" y2="152" class="solid"></line><line x1="232" y1="152" x2="240" y2="152" class="solid"></line><line x1="248" y1="152" x2="256" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><path d="M 112,24 A 4,4 0,0,1 116,28" class="nofill"></path><line x1="116" y1="28" x2="116" y2="148" class="broken"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><path d="M 116,148 A 4,4 0,0,1 112,152" class="nofill"></path></g><g><path d="M 168,24 A 4,4 0,0,0 164,28" class="nofill"></path><line x1="164" y1="28" x2="164" y2="148" class="broken"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><path d="M 164,148 A 4,4 0,0,0 168,152" class="nofill"></path><line x1="168" y1="152" x2="176" y2="152" class="solid"></line></g><g><line x1="56" y1="88" x2="184" y2="88" class="solid"></line><polygon points="184,84 192,88 184,92" class="filled"></polygon></g><g><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 272,24 A 4,4 0,0,1 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="264" y1="152" x2="272" y2="152" class="solid"></line><path d="M 276,148 A 4,4 0,0,1 272,152" class="nofill"></path></g></svg></div>
<p><code>Box&lt;T&gt;</code> implements <code>Deref&lt;Target = T&gt;</code>, which means that you can <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion">call methods
from <code>T</code> directly on a <code>Box&lt;T&gt;</code></a>.</p>
<details>
<ul>
<li><code>Box</code> is like <code>std::unique_ptr</code> in C++, except that it‚Äôs guaranteed to be not null. </li>
<li>In the above example, you can even leave out the <code>*</code> in the <code>println!</code> statement thanks to <code>Deref</code>. </li>
<li>A <code>Box</code> can be useful when you:
<ul>
<li>have a type whose size that can‚Äôt be known at compile time, but the Rust compiler wants to know an exact size.</li>
<li>want to transfer ownership of a large amount of data. To avoid copying large amounts of data on the stack, instead store the data on the heap in a <code>Box</code> so only the pointer is moved.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box-with-recursive-data-structures"><a class="header" href="#box-with-recursive-data-structures">Box with Recursive Data Structures</a></h1>
<p>Recursive data types or data types with dynamic sizes need to use a <code>Box</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}

fn main() {
    let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!(&quot;{list:?}&quot;);
}</code></pre></pre>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="656" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="656" height="176"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="266" y="12" >Heap</text><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><text x="42" y="60" >list</text><text x="50" y="92" >Cons</text><text x="106" y="92" >1</text><circle cx="148" cy="88" r="3" class="nofill"></circle><text x="314" y="92" >Cons</text><text x="370" y="92" >2</text><circle cx="412" cy="88" r="3" class="nofill"></circle><text x="490" y="92" >Nil</text><line x1="552" y1="80" x2="544" y2="96" class="solid"></line><line x1="560" y1="80" x2="552" y2="96" class="solid"></line><line x1="592" y1="80" x2="584" y2="96" class="solid"></line><line x1="600" y1="80" x2="592" y2="96" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><line x1="120" y1="152" x2="128" y2="152" class="solid"></line><line x1="136" y1="152" x2="144" y2="152" class="solid"></line><line x1="152" y1="152" x2="160" y2="152" class="solid"></line><line x1="168" y1="152" x2="176" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="280" y1="152" x2="288" y2="152" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><line x1="536" y1="152" x2="544" y2="152" class="solid"></line><line x1="552" y1="152" x2="560" y2="152" class="solid"></line><line x1="568" y1="152" x2="576" y2="152" class="solid"></line><line x1="584" y1="152" x2="592" y2="152" class="solid"></line><line x1="600" y1="152" x2="608" y2="152" class="solid"></line><line x1="616" y1="152" x2="624" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><path d="M 208,24 A 4,4 0,0,1 212,28" class="nofill"></path><line x1="212" y1="28" x2="212" y2="148" class="broken"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><path d="M 212,148 A 4,4 0,0,1 208,152" class="nofill"></path></g><g><path d="M 264,24 A 4,4 0,0,0 260,28" class="nofill"></path><line x1="260" y1="28" x2="260" y2="148" class="broken"></line><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 260,148 A 4,4 0,0,0 264,152" class="nofill"></path><line x1="264" y1="152" x2="272" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="172" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="104" class="solid"></line><line x1="92" y1="72" x2="92" y2="104" class="solid"></line><line x1="132" y1="72" x2="132" y2="104" class="solid"></line><line x1="172" y1="72" x2="172" y2="104" class="solid"></line><line x1="36" y1="104" x2="172" y2="104" class="solid"></line></g><g><line x1="300" y1="72" x2="436" y2="72" class="solid"></line><line x1="300" y1="72" x2="300" y2="104" class="solid"></line><line x1="356" y1="72" x2="356" y2="104" class="solid"></line><line x1="396" y1="72" x2="396" y2="104" class="solid"></line><line x1="436" y1="72" x2="436" y2="104" class="solid"></line><line x1="300" y1="104" x2="436" y2="104" class="solid"></line></g><g><line x1="476" y1="72" x2="612" y2="72" class="solid"></line><line x1="476" y1="72" x2="476" y2="104" class="solid"></line><line x1="532" y1="72" x2="532" y2="104" class="solid"></line><line x1="572" y1="72" x2="572" y2="104" class="solid"></line><line x1="612" y1="72" x2="612" y2="104" class="solid"></line><line x1="476" y1="104" x2="612" y2="104" class="solid"></line></g><g><line x1="152" y1="88" x2="288" y2="88" class="solid"></line><polygon points="288,84 296,88 288,92" class="filled"></polygon></g><g><line x1="416" y1="88" x2="464" y2="88" class="solid"></line><polygon points="464,84 472,88 464,92" class="filled"></polygon></g><g><line x1="632" y1="24" x2="640" y2="24" class="solid"></line><path d="M 640,24 A 4,4 0,0,1 644,28" class="nofill"></path><line x1="644" y1="28" x2="644" y2="148" class="broken"></line><line x1="632" y1="152" x2="640" y2="152" class="solid"></line><path d="M 644,148 A 4,4 0,0,1 640,152" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>
<p>If <code>Box</code> was not used and we attempted to embed a <code>List</code> directly into the <code>List</code>,
the compiler would not compute a fixed size of the struct in memory (<code>List</code> would be of infinite size).</p>
</li>
<li>
<p><code>Box</code> solves this problem as it has the same size as a regular pointer and just points at the next
element of the <code>List</code> in the heap.</p>
</li>
<li>
<p>Remove the <code>Box</code> in the List definition and show the compiler error. ‚ÄúRecursive with indirection‚Äù is a hint you might want to use a Box or reference of some kind, instead of storing a value directly.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="niche-optimization"><a class="header" href="#niche-optimization">Niche Optimization</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}

fn main() {
    let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!(&quot;{list:?}&quot;);
}</code></pre></pre>
<p>A <code>Box</code> cannot be empty, so the pointer is always valid and non-<code>null</code>. This
allows the compiler to optimize the memory layout:</p>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="640" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="640" height="176"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="266" y="12" >Heap</text><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><text x="42" y="60" >list</text><text x="50" y="92" >1</text><circle cx="92" cy="88" r="3" class="nofill"></circle><text x="314" y="92" >2</text><circle cx="356" cy="88" r="3" class="nofill"></circle><line x1="440" y1="80" x2="432" y2="96" class="solid"></line><line x1="448" y1="80" x2="440" y2="96" class="solid"></line><text x="474" y="92" >null</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><line x1="120" y1="152" x2="128" y2="152" class="solid"></line><line x1="136" y1="152" x2="144" y2="152" class="solid"></line><line x1="152" y1="152" x2="160" y2="152" class="solid"></line><line x1="168" y1="152" x2="176" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="280" y1="152" x2="288" y2="152" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><line x1="536" y1="152" x2="544" y2="152" class="solid"></line><line x1="552" y1="152" x2="560" y2="152" class="solid"></line><line x1="568" y1="152" x2="576" y2="152" class="solid"></line><line x1="584" y1="152" x2="592" y2="152" class="solid"></line><line x1="600" y1="152" x2="608" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><path d="M 208,24 A 4,4 0,0,1 212,28" class="nofill"></path><line x1="212" y1="28" x2="212" y2="148" class="broken"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><path d="M 212,148 A 4,4 0,0,1 208,152" class="nofill"></path></g><g><path d="M 264,24 A 4,4 0,0,0 260,28" class="nofill"></path><line x1="260" y1="28" x2="260" y2="148" class="broken"></line><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 260,148 A 4,4 0,0,0 264,152" class="nofill"></path><line x1="264" y1="152" x2="272" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="116" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="104" class="solid"></line><line x1="76" y1="72" x2="76" y2="104" class="solid"></line><line x1="116" y1="72" x2="116" y2="104" class="solid"></line><line x1="36" y1="104" x2="116" y2="104" class="solid"></line></g><g><line x1="300" y1="72" x2="380" y2="72" class="solid"></line><line x1="300" y1="72" x2="300" y2="104" class="solid"></line><line x1="340" y1="72" x2="340" y2="104" class="solid"></line><line x1="380" y1="72" x2="380" y2="104" class="solid"></line><line x1="300" y1="104" x2="380" y2="104" class="solid"></line></g><g><line x1="420" y1="72" x2="516" y2="72" class="solid"></line><line x1="420" y1="72" x2="420" y2="104" class="solid"></line><line x1="460" y1="72" x2="460" y2="104" class="solid"></line><line x1="516" y1="72" x2="516" y2="104" class="solid"></line><line x1="420" y1="104" x2="516" y2="104" class="solid"></line></g><g><line x1="96" y1="88" x2="288" y2="88" class="solid"></line><polygon points="288,84 296,88 288,92" class="filled"></polygon></g><g><line x1="360" y1="88" x2="408" y2="88" class="solid"></line><polygon points="408,84 416,88 408,92" class="filled"></polygon></g><g><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><path d="M 624,24 A 4,4 0,0,1 628,28" class="nofill"></path><line x1="628" y1="28" x2="628" y2="148" class="broken"></line><line x1="616" y1="152" x2="624" y2="152" class="solid"></line><path d="M 628,148 A 4,4 0,0,1 624,152" class="nofill"></path></g></svg></div><div style="break-before: page; page-break-before: always;"></div><h1 id="rc"><a class="header" href="#rc"><code>Rc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> is a reference-counted shared pointer. Use this when you need to refer
to the same data from multiple places:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::rc::Rc;

fn main() {
    let mut a = Rc::new(10);
    let mut b = Rc::clone(&amp;a);

    println!(&quot;a: {a}&quot;);
    println!(&quot;b: {b}&quot;);
}</code></pre></pre>
<ul>
<li>See <a href="concurrency/shared_state/arc.html"><code>Arc</code></a> and <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> if you are in a multi-threaded context.</li>
<li>You can <em>downgrade</em> a shared pointer into a <a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak</code></a> pointer to create cycles
that will get dropped.</li>
</ul>
<details>
<ul>
<li><code>Rc</code>‚Äôs count ensures that its contained value is valid for as long as there are references.</li>
<li><code>Rc</code> in Rust is like <code>std::shared_ptr</code> in C++.</li>
<li><code>Rc::clone</code> is cheap: it creates a pointer to the same allocation and increases the reference count. Does not make a deep clone and can generally be ignored when looking for performance issues in code.</li>
<li><code>make_mut</code> actually clones the inner value if necessary (‚Äúclone-on-write‚Äù) and returns a mutable reference.</li>
<li>Use <code>Rc::strong_count</code> to check the reference count.</li>
<li><code>Rc::downgrade</code> gives you a <em>weakly reference-counted</em> object to
create cycles that will be dropped properly (likely in combination with
<code>RefCell</code>, on the next slide).</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cell-and-refcell"><a class="header" href="#cell-and-refcell"><code>Cell</code> and <code>RefCell</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell</code></a> and
<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> implement
what Rust calls <em>interior mutability:</em> mutation of values in an immutable
context.</p>
<p><code>Cell</code> is typically used for simple types, as it requires copying or moving
values. More complex interior types typically use <code>RefCell</code>, which tracks shared
and exclusive references at runtime and panics if they are misused.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug, Default)]
struct Node {
    value: i64,
    children: Vec&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
}

impl Node {
    fn new(value: i64) -&gt; Rc&lt;RefCell&lt;Node&gt;&gt; {
        Rc::new(RefCell::new(Node { value, ..Node::default() }))
    }

    fn sum(&amp;self) -&gt; i64 {
        self.value + self.children.iter().map(|c| c.borrow().sum()).sum::&lt;i64&gt;()
    }
}

fn main() {
    let root = Node::new(1);
    root.borrow_mut().children.push(Node::new(5));
    let subtree = Node::new(10);
    subtree.borrow_mut().children.push(Node::new(11));
    subtree.borrow_mut().children.push(Node::new(12));
    root.borrow_mut().children.push(subtree);

    println!(&quot;graph: {root:#?}&quot;);
    println!(&quot;graph sum: {}&quot;, root.borrow().sum());
}</code></pre></pre>
<details>
<ul>
<li>If we were using <code>Cell</code> instead of <code>RefCell</code> in this example, we would have to move the <code>Node</code> out of the <code>Rc</code> to push children, then move it back in. This is safe because there‚Äôs always one, un-referenced value in the cell, but it‚Äôs not ergonomic.</li>
<li>To do anything with a Node, you must call a <code>RefCell</code> method, usually <code>borrow</code> or <code>borrow_mut</code>.</li>
<li>Demonstrate that reference loops can be created by adding <code>root</code> to <code>subtree.children</code> (don‚Äôt try to print it!).</li>
<li>To demonstrate a runtime panic, add a <code>fn inc(&amp;mut self)</code> that increments <code>self.value</code> and calls the same method on its children. This will panic in the presence of the reference loop, with <code>thread 'main' panicked at 'already borrowed: BorrowMutError'</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>We have seen how <code>impl</code> blocks let us namespace functions to a type.</p>
<p>Similarly, <code>mod</code> lets us namespace types and functions:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">mod foo {
    pub fn do_something() {
        println!(&quot;In the foo module&quot;);
    }
}

mod bar {
    pub fn do_something() {
        println!(&quot;In the bar module&quot;);
    }
}

fn main() {
    foo::do_something();
    bar::do_something();
}</code></pre></pre>
<details>
<ul>
<li>Packages provide functionality and include a <code>Cargo.toml</code> file that describes how to build a bundle of 1+ crates.</li>
<li>Crates are a tree of modules, where a binary crate creates an executable and a library crate compiles to a library.</li>
<li>Modules define organization, scope, and are the focus of this section.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visibility"><a class="header" href="#visibility">Visibility</a></h1>
<p>Modules are a privacy boundary:</p>
<ul>
<li>Module items are private by default (hides implementation details).</li>
<li>Parent and sibling items are always visible.</li>
<li>In other words, if an item is visible in module <code>foo</code>, it‚Äôs visible in all the
descendants of <code>foo</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">mod outer {
    fn private() {
        println!(&quot;outer::private&quot;);
    }

    pub fn public() {
        println!(&quot;outer::public&quot;);
    }

    mod inner {
        fn private() {
            println!(&quot;outer::inner::private&quot;);
        }

        pub fn public() {
            println!(&quot;outer::inner::public&quot;);
            super::private();
        }
    }
}

fn main() {
    outer::public();
}</code></pre></pre>
<details>
<ul>
<li>Use the <code>pub</code> keyword to make modules public.</li>
</ul>
<p>Additionally, there are advanced <code>pub(...)</code> specifiers to restrict the scope of public visibility.</p>
<ul>
<li>See the <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself">Rust Reference</a>.</li>
<li>Configuring <code>pub(crate)</code> visibility is a common pattern.</li>
<li>Less commonly, you can give visibility to a specific path.</li>
<li>In any case, visibility must be granted to an ancestor module (and all of its descendants).</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paths"><a class="header" href="#paths">Paths</a></h1>
<p>Paths are resolved as follows:</p>
<ol>
<li>
<p>As a relative path:</p>
<ul>
<li><code>foo</code> or <code>self::foo</code> refers to <code>foo</code> in the current module,</li>
<li><code>super::foo</code> refers to <code>foo</code> in the parent module.</li>
</ul>
</li>
<li>
<p>As an absolute path:</p>
<ul>
<li><code>crate::foo</code> refers to <code>foo</code> in the root of the current crate,</li>
<li><code>bar::foo</code> refers to <code>foo</code> in the <code>bar</code> crate.</li>
</ul>
</li>
</ol>
<p>A module can bring symbols from another module into scope with <code>use</code>.
You will typically see something like this at the top of each module:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashSet;
use std::mem::transmute;</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filesystem-hierarchy"><a class="header" href="#filesystem-hierarchy">Filesystem Hierarchy</a></h1>
<p>Omitting the module content will tell Rust to look for it in another file:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">mod garden;</code></pre></pre>
<p>This tells rust that the <code>garden</code> module content is found at <code>src/garden.rs</code>.
Similarly, a <code>garden::vegetables</code> module can be found at <code>src/garden/vegetables.rs</code>.</p>
<p>The <code>crate</code> root is in:</p>
<ul>
<li><code>src/lib.rs</code> (for a library crate)</li>
<li><code>src/main.rs</code> (for a binary crate)</li>
</ul>
<p>Modules defined in files can be documented, too, using ‚Äúinner doc comments‚Äù.
These document the item that contains them ‚Äì in this case, a module.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">//! This module implements the garden, including a highly performant germination
//! implementation.

// Re-export types from this module.
pub use seeds::SeedPacket;
pub use garden::Garden;

/// Sow the given seed packets.
pub fn sow(seeds: Vec&lt;SeedPacket&gt;) { todo!() }

/// Harvest the produce in the garden that is ready.
pub fn harvest(garden: &amp;mut Garden) { todo!() }</code></pre></pre>
<details>
<ul>
<li>
<p>Before Rust 2018, modules needed to be located at <code>module/mod.rs</code> instead of <code>module.rs</code>, and this is still a working alternative for editions after 2018.</p>
</li>
<li>
<p>The main reason to introduce <code>filename.rs</code> as alternative to <code>filename/mod.rs</code>
was because many files named <code>mod.rs</code> can be hard to distinguish in IDEs.</p>
</li>
<li>
<p>Deeper nesting can use folders, even if the main module is a file:</p>
<pre><code class="language-ignore">src/
‚îú‚îÄ‚îÄ main.rs
‚îú‚îÄ‚îÄ top_module.rs
‚îî‚îÄ‚îÄ top_module/
    ‚îî‚îÄ‚îÄ sub_module.rs
</code></pre>
</li>
<li>
<p>The place rust will look for modules can be changed with a compiler directive:</p>
<pre><code class="language-rust ignore">#[path = &quot;some/path.rs&quot;]
mod some_module;</code></pre>
<p>This is useful, for example, if you would like to place tests for a module in a file named
<code>some_module_test.rs</code>, similar to the convention in Go.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-2-afternoon-exercises"><a class="header" href="#day-2-afternoon-exercises">Day 2: Afternoon Exercises</a></h1>
<p>The exercises for this afternoon will focus on strings and iterators.</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/day-2/solutions-afternoon.html">solutions</a> provided.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="luhn-algorithm"><a class="header" href="#luhn-algorithm">Luhn Algorithm</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Luhn_algorithm">Luhn algorithm</a> is used to
validate credit card numbers. The algorithm takes a string as input and does the
following to validate the credit card number:</p>
<ul>
<li>
<p>Ignore all spaces. Reject number with less than two digits.</p>
</li>
<li>
<p>Moving from <strong>right to left</strong>, double every second digit: for the number <code>1234</code>,
we double <code>3</code> and <code>1</code>. For the number <code>98765</code>, we double <code>6</code> and <code>8</code>.</p>
</li>
<li>
<p>After doubling a digit, sum the digits. So doubling <code>7</code> becomes <code>14</code> which
becomes <code>5</code>.</p>
</li>
<li>
<p>Sum all the undoubled and doubled digits.</p>
</li>
<li>
<p>The credit card number is valid if the sum ends with <code>0</code>.</p>
</li>
</ul>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and implement the function.</p>
<p>Try to solve the problem the ‚Äúsimple‚Äù way first, using <code>for</code> loops and integers.
Then, revisit the solution and try to implement it with iterators.</p>
<pre><pre class="playground"><code class="language-rust edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub fn luhn(cc_number: &amp;str) -&gt; bool {
    unimplemented!()
}

#[test]
fn test_non_digit_cc_number() {
    assert!(!luhn(&quot;foo&quot;));
}

#[test]
fn test_empty_cc_number() {
    assert!(!luhn(&quot;&quot;));
    assert!(!luhn(&quot; &quot;));
    assert!(!luhn(&quot;  &quot;));
    assert!(!luhn(&quot;    &quot;));
}

#[test]
fn test_single_digit_cc_number() {
    assert!(!luhn(&quot;0&quot;));
}

#[test]
fn test_two_digit_cc_number() {
    assert!(luhn(&quot; 0 0 &quot;));
}

#[test]
fn test_valid_cc_number() {
    assert!(luhn(&quot;4263 9826 4026 9299&quot;));
    assert!(luhn(&quot;4539 3195 0343 6467&quot;));
    assert!(luhn(&quot;7992 7398 713&quot;));
}

#[test]
fn test_invalid_cc_number() {
    assert!(!luhn(&quot;4223 9826 4026 9299&quot;));
    assert!(!luhn(&quot;4539 3195 0343 6476&quot;));
    assert!(!luhn(&quot;8273 1232 7352 0569&quot;));
}

#[allow(dead_code)]
fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings-and-iterators"><a class="header" href="#strings-and-iterators">Strings and Iterators</a></h1>
<p>In this exercise, you are implementing a routing component of a web server. The
server is configured with a number of <em>path prefixes</em> which are matched against
<em>request paths</em>. The path prefixes can contain a wildcard character which
matches a full segment. See the unit tests below.</p>
<p>Copy the following code to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and make the tests
pass. Try avoiding allocating a <code>Vec</code> for your intermediate results:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub fn prefix_matches(prefix: &amp;str, request_path: &amp;str) -&gt; bool {
    unimplemented!()
}

#[test]
fn test_matches_without_wildcard() {
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc-123&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc/books&quot;));

    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishersBooks&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/parent/publishers&quot;));
}

#[test]
fn test_matches_with_wildcard() {
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/bar/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books/book1&quot;
    ));

    assert!(!prefix_matches(&quot;/v1/publishers/*/books&quot;, &quot;/v1/publishers&quot;));
    assert!(!prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/booksByAuthor&quot;
    ));
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-day-3"><a class="header" href="#welcome-to-day-3">Welcome to Day 3</a></h1>
<p>Today, we will cover some more advanced topics of Rust:</p>
<ul>
<li>
<p>Traits: deriving traits, default methods, and important standard library
traits.</p>
</li>
<li>
<p>Generics: generic data types, generic methods, monomorphization, and trait
objects.</p>
</li>
<li>
<p>Error handling: panics, <code>Result</code>, and the try operator <code>?</code>.</p>
</li>
<li>
<p>Testing: unit tests, documentation tests, and integration tests.</p>
</li>
<li>
<p>Unsafe Rust: raw pointers, static variables, unsafe functions, and extern
functions.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Rust support generics, which lets you abstract algorithms or data structures
(such as sorting or a binary tree)
over the types used or stored.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-data-types"><a class="header" href="#generic-data-types">Generic Data Types</a></h1>
<p>You can use generics to abstract over the concrete field type:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
    println!(&quot;{integer:?} and {float:?}&quot;);
}</code></pre></pre>
<details>
<ul>
<li>
<p>Try declaring a new variable <code>let p = Point { x: 5, y: 10.0 };</code>.</p>
</li>
<li>
<p>Fix the code to allow points that have elements of different types.</p>
</li>
</ul>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="generic-methods"><a class="header" href="#generic-methods">Generic Methods</a></h1>
<p>You can declare a generic type on your <code>impl</code> block:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Point&lt;T&gt;(T, T);

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.0  // + 10
    }

    // fn set_x(&amp;mut self, x: T)
}

fn main() {
    let p = Point(5, 10);
    println!(&quot;p.x = {}&quot;, p.x());
}</code></pre></pre>
<details>
<ul>
<li><em>Q:</em> Why <code>T</code> is specified twice in <code>impl&lt;T&gt; Point&lt;T&gt; {}</code>? Isn‚Äôt that redundant?
<ul>
<li>This is because it is a generic implementation section for generic type. They are independently generic.</li>
<li>It means these methods are defined for any <code>T</code>.</li>
<li>It is possible to write <code>impl Point&lt;u32&gt; { .. }</code>. 
<ul>
<li><code>Point</code> is still generic and you can use <code>Point&lt;f64&gt;</code>, but methods in this block will only be available for <code>Point&lt;u32&gt;</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monomorphization"><a class="header" href="#monomorphization">Monomorphization</a></h1>
<p>Generic code is turned into non-generic code based on the call sites:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let integer = Some(5);
    let float = Some(5.0);
}</code></pre></pre>
<p>behaves as if you wrote</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre></pre>
<p>This is a zero-cost abstraction: you get exactly the same result as if you had
hand-coded the data structures without the abstraction.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>Rust lets you abstract over types with traits. They‚Äôre similar to interfaces:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Pet {
    fn name(&amp;self) -&gt; String;
}

struct Dog {
    name: String,
}

struct Cat;

impl Pet for Dog {
    fn name(&amp;self) -&gt; String {
        self.name.clone()
    }
}

impl Pet for Cat {
    fn name(&amp;self) -&gt; String {
        String::from(&quot;The cat&quot;) // No name, cats won't respond to it anyway.
    }
}

fn greet&lt;P: Pet&gt;(pet: &amp;P) {
    println!(&quot;Who's a cutie? {} is!&quot;, pet.name());
}

fn main() {
    let fido = Dog { name: &quot;Fido&quot;.into() };
    greet(&amp;fido);

    let captain_floof = Cat;
    greet(&amp;captain_floof);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-objects"><a class="header" href="#trait-objects">Trait Objects</a></h1>
<p>Trait objects allow for values of different types, for instance in a collection:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Pet {
    fn name(&amp;self) -&gt; String;
}

struct Dog {
    name: String,
}

struct Cat;

impl Pet for Dog {
    fn name(&amp;self) -&gt; String {
        self.name.clone()
    }
}

impl Pet for Cat {
    fn name(&amp;self) -&gt; String {
        String::from(&quot;The cat&quot;) // No name, cats won't respond to it anyway.
    }
}

fn main() {
    let pets: Vec&lt;Box&lt;dyn Pet&gt;&gt; = vec![
        Box::new(Cat),
        Box::new(Dog { name: String::from(&quot;Fido&quot;) }),
    ];
    for pet in pets {
        println!(&quot;Hello {}!&quot;, pet.name());
    }
}</code></pre></pre>
<p>Memory layout after allocating <code>pets</code>:</p>
<div style='width:100%; height:400px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="656" height="400"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="656" height="400"></rect><rect x="420" y="120" width="128" height="32" class="solid nofill" rx="0"></rect><text x="434" y="140" >name:</text><text x="482" y="140" >Fido</text><rect x="420" y="184" width="184" height="32" class="solid nofill" rx="0"></rect><text x="434" y="204" >&lt;Dog as Pet&gt;::name</text><rect x="372" y="312" width="184" height="32" class="solid nofill" rx="0"></rect><text x="386" y="332" >&lt;Cat as Pet&gt;::name</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >pets</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><circle cx="324" cy="88" r="3" class="nofill"></circle><circle cx="340" cy="88" r="3" class="nofill"></circle><circle cx="372" cy="88" r="3" class="nofill"></circle><circle cx="388" cy="88" r="3" class="nofill"></circle><text x="50" y="108" >len</text><text x="178" y="108" >2</text><text x="50" y="124" >capacity</text><text x="178" y="124" >2</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><line x1="296" y1="376" x2="304" y2="376" class="solid"></line><line x1="312" y1="376" x2="320" y2="376" class="solid"></line><line x1="328" y1="376" x2="336" y2="376" class="solid"></line><line x1="344" y1="376" x2="352" y2="376" class="solid"></line><line x1="360" y1="376" x2="368" y2="376" class="solid"></line><line x1="376" y1="376" x2="384" y2="376" class="solid"></line><line x1="392" y1="376" x2="400" y2="376" class="solid"></line><line x1="408" y1="376" x2="416" y2="376" class="solid"></line><line x1="424" y1="376" x2="432" y2="376" class="solid"></line><line x1="440" y1="376" x2="448" y2="376" class="solid"></line><line x1="456" y1="376" x2="464" y2="376" class="solid"></line><line x1="472" y1="376" x2="480" y2="376" class="solid"></line><line x1="488" y1="376" x2="496" y2="376" class="solid"></line><line x1="504" y1="376" x2="512" y2="376" class="solid"></line><line x1="520" y1="376" x2="528" y2="376" class="solid"></line><line x1="536" y1="376" x2="544" y2="376" class="solid"></line><line x1="552" y1="376" x2="560" y2="376" class="solid"></line><line x1="568" y1="376" x2="576" y2="376" class="solid"></line><line x1="584" y1="376" x2="592" y2="376" class="solid"></line><line x1="600" y1="376" x2="608" y2="376" class="solid"></line><line x1="616" y1="376" x2="624" y2="376" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="372" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,372 A 4,4 0,0,0 280,376" class="nofill"></path><line x1="280" y1="376" x2="288" y2="376" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="404" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="356" y1="72" x2="356" y2="104" class="solid"></line><line x1="404" y1="72" x2="404" y2="104" class="solid"></line><line x1="308" y1="104" x2="404" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="324" y1="92" x2="324" y2="324" class="solid"></line><path d="M 324,324 A 4,4 0,0,0 328,328" class="nofill"></path><line x1="328" y1="328" x2="360" y2="328" class="solid"></line><polygon points="360,324 368,328 360,332" class="filled"></polygon></g><g><line x1="340" y1="92" x2="340" y2="260" class="solid"></line><path d="M 340,260 A 4,4 0,0,0 344,264" class="nofill"></path><line x1="344" y1="264" x2="360" y2="264" class="solid"></line><polygon points="360,260 368,264 360,268" class="filled"></polygon></g><g><line x1="372" y1="92" x2="372" y2="196" class="solid"></line><path d="M 372,196 A 4,4 0,0,0 376,200" class="nofill"></path><line x1="376" y1="200" x2="408" y2="200" class="solid"></line><polygon points="408,196 416,200 408,204" class="filled"></polygon></g><g><line x1="388" y1="92" x2="388" y2="132" class="solid"></line><path d="M 388,132 A 4,4 0,0,0 392,136" class="nofill"></path><line x1="392" y1="136" x2="408" y2="136" class="solid"></line><polygon points="408,132 416,136 408,140" class="filled"></polygon></g><g><line x1="372" y1="248" x2="388" y2="248" class="solid"></line><line x1="372" y1="248" x2="372" y2="280" class="solid"></line><line x1="372" y1="248" x2="388" y2="280" class="solid"></line><line x1="388" y1="248" x2="388" y2="280" class="solid"></line><line x1="372" y1="280" x2="388" y2="280" class="solid"></line></g><g><line x1="632" y1="24" x2="640" y2="24" class="solid"></line><path d="M 640,24 A 4,4 0,0,1 644,28" class="nofill"></path><line x1="644" y1="28" x2="644" y2="372" class="broken"></line><line x1="632" y1="376" x2="640" y2="376" class="solid"></line><path d="M 644,372 A 4,4 0,0,1 640,376" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>Types that implement a given trait may be of different sizes. This makes it impossible to have things like <code>Vec&lt;Pet&gt;</code> in the example above.</li>
<li><code>dyn Pet</code> is a way to tell the compiler about a dynamically sized type that implements <code>Pet</code>.</li>
<li>In the example, <code>pets</code> holds <em>fat pointers</em> to objects that implement <code>Pet</code>. The fat pointer consists of two components, a pointer to the actual object and a pointer to the virtual method table for the <code>Pet</code> implementation of that particular object.</li>
<li>Compare these outputs in the above example:
<pre><code class="language-rust ignore">    println!(&quot;{} {}&quot;, std::mem::size_of::&lt;Dog&gt;(), std::mem::size_of::&lt;Cat&gt;());
    println!(&quot;{} {}&quot;, std::mem::size_of::&lt;&amp;Dog&gt;(), std::mem::size_of::&lt;&amp;Cat&gt;());
    println!(&quot;{}&quot;, std::mem::size_of::&lt;&amp;dyn Pet&gt;());
    println!(&quot;{}&quot;, std::mem::size_of::&lt;Box&lt;dyn Pet&gt;&gt;());</code></pre>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deriving-traits"><a class="header" href="#deriving-traits">Deriving Traits</a></h1>
<p>Rust derive macros work by automatically generating code that implements the specified traits for a data structure.</p>
<p>You can let the compiler derive a number of traits as follows:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, Clone, PartialEq, Eq, Default)]
struct Player {
    name: String,
    strength: u8,
    hit_points: u8,
}

fn main() {
    let p1 = Player::default();
    let p2 = p1.clone();
    println!(&quot;Is {:?}\nequal to {:?}?\nThe answer is {}!&quot;, &amp;p1, &amp;p2,
             if p1 == p2 { &quot;yes&quot; } else { &quot;no&quot; });
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-methods"><a class="header" href="#default-methods">Default Methods</a></h1>
<p>Traits can implement behavior in terms of other trait methods:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Equals {
    fn equals(&amp;self, other: &amp;Self) -&gt; bool;
    fn not_equals(&amp;self, other: &amp;Self) -&gt; bool {
        !self.equals(other)
    }
}

#[derive(Debug)]
struct Centimeter(i16);

impl Equals for Centimeter {
    fn equals(&amp;self, other: &amp;Centimeter) -&gt; bool {
        self.0 == other.0
    }
}

fn main() {
    let a = Centimeter(10);
    let b = Centimeter(20);
    println!(&quot;{a:?} equals {b:?}: {}&quot;, a.equals(&amp;b));
    println!(&quot;{a:?} not_equals {b:?}: {}&quot;, a.not_equals(&amp;b));
}</code></pre></pre>
<details>
<ul>
<li>
<p>Traits may specify pre-implemented (default) methods and methods that users are required to
implement themselves. Methods with default implementations can rely on required methods.</p>
</li>
<li>
<p>Move method <code>not_equals</code> to a new trait <code>NotEquals</code>.</p>
</li>
<li>
<p>Make <code>Equals</code> a super trait for <code>NotEquals</code>.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">trait NotEquals: Equals {
    fn not_equals(&amp;self, other: &amp;Self) -&gt; bool {
        !self.equals(other)
    }
}</code></pre></pre>
</li>
<li>
<p>Provide a blanket implementation of <code>NotEquals</code> for <code>Equals</code>.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">trait NotEquals {
    fn not_equals(&amp;self, other: &amp;Self) -&gt; bool;
}

impl&lt;T&gt; NotEquals for T where T: Equals {
    fn not_equals(&amp;self, other: &amp;Self) -&gt; bool {
        !self.equals(other)
    }
}</code></pre></pre>
<ul>
<li>With the blanket implementation, you no longer need <code>Equals</code> as a super trait for <code>NotEqual</code>.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-bounds"><a class="header" href="#trait-bounds">Trait Bounds</a></h1>
<p>When working with generics, you often want to require the types to implement
some trait, so that you can call this trait‚Äôs methods.</p>
<p>You can do this with <code>T: Trait</code> or <code>impl Trait</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn duplicate&lt;T: Clone&gt;(a: T) -&gt; (T, T) {
    (a.clone(), a.clone())
}

// Syntactic sugar for:
//   fn add_42_millions&lt;T: Into&lt;i32&gt;&gt;(x: T) -&gt; i32 {
fn add_42_millions(x: impl Into&lt;i32&gt;) -&gt; i32 {
    x.into() + 42_000_000
}

// struct NotClonable;

fn main() {
    let foo = String::from(&quot;foo&quot;);
    let pair = duplicate(foo);
    println!(&quot;{pair:?}&quot;);

    let many = add_42_millions(42_i8);
    println!(&quot;{many}&quot;);
    let many_more = add_42_millions(10_000_000);
    println!(&quot;{many_more}&quot;);
}</code></pre></pre>
<details>
<p>Show a <code>where</code> clause, students will encounter it when reading code.</p>
<pre><code class="language-rust ignore">fn duplicate&lt;T&gt;(a: T) -&gt; (T, T)
where
    T: Clone,
{
    (a.clone(), a.clone())
}</code></pre>
<ul>
<li>It declutters the function signature if you have many parameters.</li>
<li>It has additional features making it more powerful.
<ul>
<li>If someone asks, the extra feature is that the type on the left of ‚Äú:‚Äù can be arbitrary, like <code>Option&lt;T&gt;</code>.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait"><a class="header" href="#impl-trait"><code>impl Trait</code></a></h1>
<p>Similar to trait bounds, an <code>impl Trait</code> syntax can be used in function
arguments and return values:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Display;

fn get_x(name: impl Display) -&gt; impl Display {
    format!(&quot;Hello {name}&quot;)
}

fn main() {
    let x = get_x(&quot;foo&quot;);
    println!(&quot;{x}&quot;);
}</code></pre></pre>
<ul>
<li><code>impl Trait</code> allows you to work with types which you cannot name.</li>
</ul>
<details>
<p>The meaning of <code>impl Trait</code> is a bit different in the different positions.</p>
<ul>
<li>
<p>For a parameter, <code>impl Trait</code> is like an anonymous generic parameter with a trait bound.</p>
</li>
<li>
<p>For a return type, it means that the return type is some concrete type that implements the trait,
without naming the type. This can be useful when you don‚Äôt want to expose the concrete type in a
public API.</p>
<p>Inference is hard in return position. A function returning <code>impl Foo</code> picks
the concrete type it returns, without writing it out in the source. A function
returning a generic type like <code>collect&lt;B&gt;() -&gt; B</code> can return any type
satisfying <code>B</code>, and the caller may need to choose one, such as with <code>let x: Vec&lt;_&gt; = foo.collect()</code> or with the turbofish, <code>foo.collect::&lt;Vec&lt;_&gt;&gt;()</code>.</p>
</li>
</ul>
<p>This example is great, because it uses <code>impl Display</code> twice. It helps to explain that
nothing here enforces that it is <em>the same</em> <code>impl Display</code> type. If we used a single 
<code>T: Display</code>, it would enforce the constraint that input <code>T</code> and return <code>T</code> type are the same type.
It would not work for this particular function, as the type we expect as input is likely not
what <code>format!</code> returns. If we wanted to do the same via <code>: Display</code> syntax, we‚Äôd need two
independent generic parameters.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="important-traits"><a class="header" href="#important-traits">Important Traits</a></h1>
<p>We will now look at some of the most common traits of the Rust standard library:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> and <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> used in <code>for</code> loops,</li>
<li><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> used to convert values,</li>
<li><a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> and <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a> used for IO,</li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a>, ‚Ä¶ used for operator overloading, and</li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> used for defining destructors.</li>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> used to construct a default instance of a type.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<p>You can implement the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait on your own types:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Fibonacci {
    curr: u32,
    next: u32,
}

impl Iterator for Fibonacci {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let new_next = self.curr + self.next;
        self.curr = self.next;
        self.next = new_next;
        Some(self.curr)
    }
}

fn main() {
    let fib = Fibonacci { curr: 0, next: 1 };
    for (i, n) in fib.enumerate().take(5) {
        println!(&quot;fib({i}): {n}&quot;);
    }
}</code></pre></pre>
<details>
<ul>
<li>
<p>The <code>Iterator</code> trait implements many common functional programming operations over collections 
(e.g. <code>map</code>, <code>filter</code>, <code>reduce</code>, etc). This is the trait where you can find all the documentation
about them. In Rust these functions should produce the code as efficient as equivalent imperative
implementations.</p>
</li>
<li>
<p><code>IntoIterator</code> is the trait that makes for loops work. It is implemented by collection types such as
<code>Vec&lt;T&gt;</code> and references to them such as <code>&amp;Vec&lt;T&gt;</code> and <code>&amp;[T]</code>. Ranges also implement it. This is why
you can iterate over a vector with <code>for i in some_vec { .. }</code> but
<code>some_vec.next()</code> doesn‚Äôt exist.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fromiterator"><a class="header" href="#fromiterator">FromIterator</a></h1>
<p><a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>FromIterator</code></a> lets you build a collection from an <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let primes = vec![2, 3, 5, 7];
    let prime_squares = primes
        .into_iter()
        .map(|prime| prime * prime)
        .collect::&lt;Vec&lt;_&gt;&gt;();
}</code></pre></pre>
<details>
<p><code>Iterator</code> implements
<code>fn collect&lt;B&gt;(self) -&gt; B where B: FromIterator&lt;Self::Item&gt;, Self: Sized</code></p>
<p>There are also implementations which let you do cool things like convert an
<code>Iterator&lt;Item = Result&lt;V, E&gt;&gt;</code> into a <code>Result&lt;Vec&lt;V&gt;, E&gt;</code>.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-and-into"><a class="header" href="#from-and-into"><code>From</code> and <code>Into</code></a></h1>
<p>Types implement <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> to facilitate type conversions:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = String::from(&quot;hello&quot;);
    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);
    let one = i16::from(true);
    let bigger = i32::from(123i16);
    println!(&quot;{s}, {addr}, {one}, {bigger}&quot;);
}</code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> is automatically implemented when <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> is implemented:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s: String = &quot;hello&quot;.into();
    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();
    let one: i16 = true.into();
    let bigger: i32 = 123i16.into();
    println!(&quot;{s}, {addr}, {one}, {bigger}&quot;);
}</code></pre></pre>
<details>
<ul>
<li>That‚Äôs why it is common to only implement <code>From</code>, as your type will get <code>Into</code> implementation too.</li>
<li>When declaring a function argument input type like ‚Äúanything that can be converted into a <code>String</code>‚Äù, the rule is opposite, you should use <code>Into</code>.
Your function will accept types that implement <code>From</code> and those that <em>only</em> implement <code>Into</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read-and-write"><a class="header" href="#read-and-write"><code>Read</code> and <code>Write</code></a></h1>
<p>Using <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> and <a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a>, you can abstract over <code>u8</code> sources:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::io::{BufRead, BufReader, Read, Result};

fn count_lines&lt;R: Read&gt;(reader: R) -&gt; usize {
    let buf_reader = BufReader::new(reader);
    buf_reader.lines().count()
}

fn main() -&gt; Result&lt;()&gt; {
    let slice: &amp;[u8] = b&quot;foo\nbar\nbaz\n&quot;;
    println!(&quot;lines in slice: {}&quot;, count_lines(slice));

    let file = std::fs::File::open(std::env::current_exe()?)?;
    println!(&quot;lines in file: {}&quot;, count_lines(file));
    Ok(())
}</code></pre></pre>
<p>Similarly, <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a> lets you abstract over <code>u8</code> sinks:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::io::{Result, Write};

fn log&lt;W: Write&gt;(writer: &amp;mut W, msg: &amp;str) -&gt; Result&lt;()&gt; {
    writer.write_all(msg.as_bytes())?;
    writer.write_all(&quot;\n&quot;.as_bytes())
}

fn main() -&gt; Result&lt;()&gt; {
    let mut buffer = Vec::new();
    log(&amp;mut buffer, &quot;Hello&quot;)?;
    log(&amp;mut buffer, &quot;World&quot;)?;
    println!(&quot;Logged: {:?}&quot;, buffer);
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-drop-trait"><a class="header" href="#the-drop-trait">The <code>Drop</code> Trait</a></h1>
<p>Values which implement <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> can specify code to run when they go out of scope:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Droppable {
    name: &amp;'static str,
}

impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping {}&quot;, self.name);
    }
}

fn main() {
    let a = Droppable { name: &quot;a&quot; };
    {
        let b = Droppable { name: &quot;b&quot; };
        {
            let c = Droppable { name: &quot;c&quot; };
            let d = Droppable { name: &quot;d&quot; };
            println!(&quot;Exiting block B&quot;);
        }
        println!(&quot;Exiting block A&quot;);
    }
    drop(a);
    println!(&quot;Exiting main&quot;);
}</code></pre></pre>
<details>
<p>Discussion points:</p>
<ul>
<li>Why doesn‚Äôt <code>Drop::drop</code> take <code>self</code>?
<ul>
<li>Short-answer: If it did, <code>std::mem::drop</code> would be called at the end of
the block, resulting in another call to <code>Drop::drop</code>, and a stack
overflow!</li>
</ul>
</li>
<li>Try replacing <code>drop(a)</code> with <code>a.drop()</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-default-trait"><a class="header" href="#the-default-trait">The <code>Default</code> Trait</a></h1>
<p><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait produces a default value for a type.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, Default)]
struct Derived {
    x: u32,
    y: String,
    z: Implemented,
}

#[derive(Debug)]
struct Implemented(String);

impl Default for Implemented {
    fn default() -&gt; Self {
        Self(&quot;John Smith&quot;.into())
    }
}

fn main() {
    let default_struct = Derived::default();
    println!(&quot;{default_struct:#?}&quot;);

    let almost_default_struct = Derived {
        y: &quot;Y is set!&quot;.into(),
        ..Derived::default()
    };
    println!(&quot;{almost_default_struct:#?}&quot;);

    let nothing: Option&lt;Derived&gt; = None;
    println!(&quot;{:#?}&quot;, nothing.unwrap_or_default());
}
</code></pre></pre>
<details>
<ul>
<li>It can be implemented directly or it can be derived via <code>#[derive(Default)]</code>.</li>
<li>A derived implementation will produce a value where all fields are set to their default values.
<ul>
<li>This means all types in the struct must implement <code>Default</code> too.</li>
</ul>
</li>
<li>Standard Rust types often implement <code>Default</code> with reasonable values (e.g. <code>0</code>, <code>&quot;&quot;</code>, etc).</li>
<li>The partial struct copy works nicely with default.</li>
<li>Rust standard library is aware that types can implement <code>Default</code> and provides convenience methods that use it.</li>
<li>the <code>..</code> syntax is called <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">struct update syntax</a></li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-mul-"><a class="header" href="#add-mul-"><code>Add</code>, <code>Mul</code>, ‚Ä¶</a></h1>
<p>Operator overloading is implemented via traits in <a href="https://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, Copy, Clone)]
struct Point { x: i32, y: i32 }

impl std::ops::Add for Point {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self {x: self.x + other.x, y: self.y + other.y}
    }
}

fn main() {
    let p1 = Point { x: 10, y: 20 };
    let p2 = Point { x: 100, y: 200 };
    println!(&quot;{:?} + {:?} = {:?}&quot;, p1, p2, p1 + p2);
}</code></pre></pre>
<details>
<p>Discussion points:</p>
<ul>
<li>You could implement <code>Add</code> for <code>&amp;Point</code>. In which situations is that useful? 
<ul>
<li>Answer: <code>Add:add</code> consumes <code>self</code>. If type <code>T</code> for which you are
overloading the operator is not <code>Copy</code>, you should consider overloading
the operator for <code>&amp;T</code> as well. This avoids unnecessary cloning on the
call site.</li>
</ul>
</li>
<li>Why is <code>Output</code> an associated type? Could it be made a type parameter of the method?
<ul>
<li>Short answer: Function type parameters are controlled by the caller, but
associated types (like <code>Output</code>) are controlled by the implementor of a
trait.</li>
</ul>
</li>
<li>You could implement <code>Add</code> for two different types, e.g.
<code>impl Add&lt;(i32, i32)&gt; for Point</code> would add a tuple to a <code>Point</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p>Closures or lambda expressions have types which cannot be named. However, they
implement special <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>,
<a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, and
<a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> traits:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn apply_with_log(func: impl FnOnce(i32) -&gt; i32, input: i32) -&gt; i32 {
    println!(&quot;Calling function on {input}&quot;);
    func(input)
}

fn main() {
    let add_3 = |x| x + 3;
    println!(&quot;add_3: {}&quot;, apply_with_log(add_3, 10));
    println!(&quot;add_3: {}&quot;, apply_with_log(add_3, 20));

    let mut v = Vec::new();
    let mut accumulate = |x: i32| {
        v.push(x);
        v.iter().sum::&lt;i32&gt;()
    };
    println!(&quot;accumulate: {}&quot;, apply_with_log(&amp;mut accumulate, 4));
    println!(&quot;accumulate: {}&quot;, apply_with_log(&amp;mut accumulate, 5));

    let multiply_sum = |x| x * v.into_iter().sum::&lt;i32&gt;();
    println!(&quot;multiply_sum: {}&quot;, apply_with_log(multiply_sum, 3));
}</code></pre></pre>
<details>
<p>An <code>Fn</code> (e.g. <code>add_3</code>) neither consumes nor mutates captured values, or perhaps captures
nothing at all. It can be called multiple times concurrently.</p>
<p>An <code>FnMut</code> (e.g. <code>accumulate</code>) might mutate captured values. You can call it multiple times,
but not concurrently.</p>
<p>If you have an <code>FnOnce</code> (e.g. <code>multiply_sum</code>), you may only call it once. It might consume
captured values.</p>
<p><code>FnMut</code> is a subtype of <code>FnOnce</code>. <code>Fn</code> is a subtype of <code>FnMut</code> and <code>FnOnce</code>. I.e. you can use an
<code>FnMut</code> wherever an <code>FnOnce</code> is called for, and you can use an <code>Fn</code> wherever an <code>FnMut</code> or <code>FnOnce</code>
is called for.</p>
<p>The compiler also infers <code>Copy</code> (e.g. for <code>add_3</code>) and <code>Clone</code> (e.g. <code>multiply_sum</code>),
depending on what the closure captures.</p>
<p>By default, closures will capture by reference if they can. The <code>move</code> keyword makes them capture
by value.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn make_greeter(prefix: String) -&gt; impl Fn(&amp;str) {
    return move |name| println!(&quot;{} {}&quot;, prefix, name)
}

fn main() {
    let hi = make_greeter(&quot;Hi&quot;.to_string());
    hi(&quot;there&quot;);
}</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶§‡ßÉ‡¶§‡ßÄ‡ßü-‡¶¶‡¶ø‡¶®‡¶É-‡¶∏‡¶ï‡¶æ‡¶≤‡ßá‡¶∞-‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®"><a class="header" href="#‡¶§‡ßÉ‡¶§‡ßÄ‡ßü-‡¶¶‡¶ø‡¶®‡¶É-‡¶∏‡¶ï‡¶æ‡¶≤‡ßá‡¶∞-‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®">‡¶§‡ßÉ‡¶§‡ßÄ‡ßü ‡¶¶‡¶ø‡¶®‡¶É ‡¶∏‡¶ï‡¶æ‡¶≤‡ßá‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®</a></h1>
<p>We will design a classical GUI library traits and trait objects.</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/day-3/solutions-morning.html">solutions</a> provided.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-simple-gui-library"><a class="header" href="#a-simple-gui-library">A Simple GUI Library</a></h1>
<p>Let us design a classical GUI library using our new knowledge of traits and
trait objects.</p>
<p>We will have a number of widgets in our library:</p>
<ul>
<li><code>Window</code>: has a <code>title</code> and contains other widgets.</li>
<li><code>Button</code>: has a <code>label</code> and a callback function which is invoked when the
button is pressed.</li>
<li><code>Label</code>: has a <code>label</code>.</li>
</ul>
<p>The widgets will implement a <code>Widget</code> trait, see below.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a>, fill in the missing
<code>draw_into</code> methods so that you implement the <code>Widget</code> trait:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_imports, unused_variables, dead_code)]

pub trait Widget {
    /// Natural width of `self`.
    fn width(&amp;self) -&gt; usize;

    /// Draw the widget into a buffer.
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&amp;self) {
        let mut buffer = String::new();
        self.draw_into(&amp;mut buffer);
        println!(&quot;{buffer}&quot;);
    }
}

pub struct Label {
    label: String,
}

impl Label {
    fn new(label: &amp;str) -&gt; Label {
        Label {
            label: label.to_owned(),
        }
    }
}

pub struct Button {
    label: Label,
    callback: Box&lt;dyn FnMut()&gt;,
}

impl Button {
    fn new(label: &amp;str, callback: Box&lt;dyn FnMut()&gt;) -&gt; Button {
        Button {
            label: Label::new(label),
            callback,
        }
    }
}

pub struct Window {
    title: String,
    widgets: Vec&lt;Box&lt;dyn Widget&gt;&gt;,
}

impl Window {
    fn new(title: &amp;str) -&gt; Window {
        Window {
            title: title.to_owned(),
            widgets: Vec::new(),
        }
    }

    fn add_widget(&amp;mut self, widget: Box&lt;dyn Widget&gt;) {
        self.widgets.push(widget);
    }

    fn inner_width(&amp;self) -&gt; usize {
        std::cmp::max(
            self.title.chars().count(),
            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),
        )
    }
}


impl Widget for Label {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        unimplemented!()
    }
}

impl Widget for Button {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        unimplemented!()
    }
}

impl Widget for Window {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        unimplemented!()
    }
}

fn main() {
    let mut window = Window::new(&quot;Rust GUI Demo 1.23&quot;);
    window.add_widget(Box::new(Label::new(&quot;This is a small text GUI demo.&quot;)));
    window.add_widget(Box::new(Button::new(
        &quot;Click me!&quot;,
        Box::new(|| println!(&quot;You clicked the button!&quot;)),
    )));
    window.draw();
}</code></pre></pre>
<p>The output of the above program can be something simple like this:</p>
<pre><code class="language-text">========
Rust GUI Demo 1.23
========

This is a small text GUI demo.

| Click me! |
</code></pre>
<p>If you want to draw aligned text, you can use the
<a href="https://doc.rust-lang.org/std/fmt/index.html#fillalignment">fill/alignment</a>
formatting operators. In particular, notice how you can pad with different
characters (here a <code>'/'</code>) and how you can control alignment:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let width = 10;
    println!(&quot;left aligned:  |{:/&lt;width$}|&quot;, &quot;foo&quot;);
    println!(&quot;centered:      |{:/^width$}|&quot;, &quot;foo&quot;);
    println!(&quot;right aligned: |{:/&gt;width$}|&quot;, &quot;foo&quot;);
}</code></pre></pre>
<p>Using such alignment tricks, you can for example produce output like this:</p>
<pre><code class="language-text">+--------------------------------+
|       Rust GUI Demo 1.23       |
+================================+
| This is a small text GUI demo. |
| +-----------+                  |
| | Click me! |                  |
| +-----------+                  |
+--------------------------------+
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>Error handling in Rust is done using explicit control flow:</p>
<ul>
<li>Functions that can have errors list this in their return type,</li>
<li>There are no exceptions.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panics"><a class="header" href="#panics">Panics</a></h1>
<p>Rust will trigger a panic if a fatal error happens at runtime:</p>
<pre><pre class="playground"><code class="language-rust editable should_panic edition2021">fn main() {
    let v = vec![10, 20, 30];
    println!(&quot;v[100]: {}&quot;, v[100]);
}</code></pre></pre>
<ul>
<li>Panics are for unrecoverable and unexpected errors.
<ul>
<li>Panics are symptoms of bugs in the program.</li>
</ul>
</li>
<li>Use non-panicking APIs (such as <code>Vec::get</code>) if crashing is not acceptable.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catching-the-stack-unwinding"><a class="header" href="#catching-the-stack-unwinding">Catching the Stack Unwinding</a></h1>
<p>By default, a panic will cause the stack to unwind. The unwinding can be caught:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::panic;

fn main() {
    let result = panic::catch_unwind(|| {
        println!(&quot;hello!&quot;);
    });
    assert!(result.is_ok());
    
    let result = panic::catch_unwind(|| {
        panic!(&quot;oh no!&quot;);
    });
    assert!(result.is_err());
}</code></pre></pre>
<ul>
<li>This can be useful in servers which should keep running even if a single
request crashes.</li>
<li>This does not work if <code>panic = 'abort'</code> is set in your <code>Cargo.toml</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structured-error-handling-with-result"><a class="header" href="#structured-error-handling-with-result">Structured Error Handling with <code>Result</code></a></h1>
<p>We have already seen the <code>Result</code> enum. This is used pervasively when errors are
expected as part of normal operation:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fs;
use std::io::Read;

fn main() {
    let file = fs::File::open(&quot;diary.txt&quot;);
    match file {
        Ok(mut file) =&gt; {
            let mut contents = String::new();
            file.read_to_string(&amp;mut contents);
            println!(&quot;Dear diary: {contents}&quot;);
        },
        Err(err) =&gt; {
            println!(&quot;The diary could not be opened: {err}&quot;);
        }
    }
}</code></pre></pre>
<details>
<ul>
<li>As with <code>Option</code>, the successful value sits inside of <code>Result</code>, forcing the developer to
explicitly extract it. This encourages error checking. In the case where an error should never happen,
<code>unwrap()</code> or <code>expect()</code> can be called, and this is a signal of the developer intent too.</li>
<li><code>Result</code> documentation is a recommended read. Not during the course, but it is worth mentioning. 
It contains a lot of convenience methods and functions that help functional-style programming. </li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="propagating-errors-with-"><a class="header" href="#propagating-errors-with-">Propagating Errors with <code>?</code></a></h1>
<p>The try-operator <code>?</code> is used to return errors to the caller. It lets you turn
the common</p>
<pre><code class="language-rust ignore">match some_expression {
    Ok(value) =&gt; value,
    Err(err) =&gt; return Err(err),
}</code></pre>
<p>into the much simpler</p>
<pre><code class="language-rust ignore">some_expression?</code></pre>
<p>We can use this to simplify our error handling code:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::{fs, io};
use std::io::Read;

fn read_username(path: &amp;str) -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = fs::File::open(path);
    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(err) =&gt; return Err(err),
    };

    let mut username = String::new();
    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(err) =&gt; Err(err),
    }
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;alice&quot;).unwrap();
    let username = read_username(&quot;config.dat&quot;);
    println!(&quot;username or error: {username:?}&quot;);
}</code></pre></pre>
<details>
<p>‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¶‡¶ø‡¶ï:</p>
<ul>
<li>The <code>username</code> variable can be either <code>Ok(string)</code> or <code>Err(error)</code>.</li>
<li>Use the <code>fs::write</code> call to test out the different scenarios: no file, empty file, file with username.</li>
<li>The return type of the function has to be compatible with the nested functions it calls. For instance,
a function returning a <code>Result&lt;T, Err&gt;</code> can only apply the <code>?</code> operator on a function returning a 
<code>Result&lt;AnyT, Err&gt;</code>. It cannot apply the <code>?</code> operator on a function returning an <code>Option&lt;AnyT&gt;</code> or <code>Result&lt;T, OtherErr&gt;</code>
unless <code>OtherErr</code> implements <code>From&lt;Err&gt;</code>. Reciprocally, a function returning an <code>Option&lt;T&gt;</code> can only apply the <code>?</code> operator 
on a function returning an <code>Option&lt;AnyT&gt;</code>.
<ul>
<li>You can convert incompatible types into one another with the different <code>Option</code> and <code>Result</code> methods 
such as <code>Option::ok_or</code>, <code>Result::ok</code>, <code>Result::err</code>.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-error-types"><a class="header" href="#converting-error-types">Converting Error Types</a></h1>
<p>The effective expansion of <code>?</code> is a little more complicated than previously indicated:</p>
<pre><code class="language-rust ignore">expression?</code></pre>
<p>works the same as</p>
<pre><code class="language-rust ignore">match expression {
    Ok(value) =&gt; value,
    Err(err)  =&gt; return Err(From::from(err)),
}</code></pre>
<p>The <code>From::from</code> call here means we attempt to convert the error type to the
type returned by the function:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-error-types-1"><a class="header" href="#converting-error-types-1">Converting Error Types</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::error::Error;
use std::fmt::{self, Display, Formatter};
use std::fs::{self, File};
use std::io::{self, Read};

#[derive(Debug)]
enum ReadUsernameError {
    IoError(io::Error),
    EmptyUsername(String),
}

impl Error for ReadUsernameError {}

impl Display for ReadUsernameError {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        match self {
            Self::IoError(e) =&gt; write!(f, &quot;IO error: {e}&quot;),
            Self::EmptyUsername(filename) =&gt; write!(f, &quot;Found no username in {filename}&quot;),
        }
    }
}

impl From&lt;io::Error&gt; for ReadUsernameError {
    fn from(err: io::Error) -&gt; ReadUsernameError {
        ReadUsernameError::IoError(err)
    }
}

fn read_username(path: &amp;str) -&gt; Result&lt;String, ReadUsernameError&gt; {
    let mut username = String::with_capacity(100);
    File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    let username = read_username(&quot;config.dat&quot;);
    println!(&quot;username or error: {username:?}&quot;);
}</code></pre></pre>
<details>
<p>‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¶‡¶ø‡¶ï:</p>
<ul>
<li>The <code>username</code> variable can be either <code>Ok(string)</code> or <code>Err(error)</code>.</li>
<li>Use the <code>fs::write</code> call to test out the different scenarios: no file, empty file, file with username.</li>
</ul>
<p>It is good practice for all error types that don‚Äôt need to be <code>no_std</code> to implement <code>std::error::Error</code>, which requires <code>Debug</code> and <code>Display</code>. The <code>Error</code> crate for <code>core</code> is only available in <a href="https://github.com/rust-lang/rust/issues/103765">nightly</a>, so not fully <code>no_std</code> compatible yet.</p>
<p>It‚Äôs generally helpful for them to implement <code>Clone</code> and <code>Eq</code> too where possible, to make
life easier for tests and consumers of your library. In this case we can‚Äôt easily do so, because
<code>io::Error</code> doesn‚Äôt implement them.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deriving-error-enums"><a class="header" href="#deriving-error-enums">Deriving Error Enums</a></h1>
<p>The <a href="https://docs.rs/thiserror/">thiserror</a> crate is a popular way to create an
error enum like we did on the previous page:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::{fs, io};
use std::io::Read;
use thiserror::Error;

#[derive(Debug, Error)]
enum ReadUsernameError {
    #[error(&quot;Could not read: {0}&quot;)]
    IoError(#[from] io::Error),
    #[error(&quot;Found no username in {0}&quot;)]
    EmptyUsername(String),
}

fn read_username(path: &amp;str) -&gt; Result&lt;String, ReadUsernameError&gt; {
    let mut username = String::new();
    fs::File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err)     =&gt; println!(&quot;Error: {err}&quot;),
    }
}</code></pre></pre>
<details>
<p><code>thiserror</code>‚Äôs derive macro automatically implements <code>std::error::Error</code>, and optionally <code>Display</code>
(if the <code>#[error(...)]</code> attributes are provided) and <code>From</code> (if the <code>#[from]</code> attribute is added).
It also works for structs.</p>
<p>It doesn‚Äôt affect your public API, which makes it good for libraries.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-error-types"><a class="header" href="#dynamic-error-types">Dynamic Error Types</a></h1>
<p>Sometimes we want to allow any type of error to be returned without writing our own enum covering
all the different possibilities. <code>std::error::Error</code> makes this easy.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::fs;
use std::io::Read;
use thiserror::Error;
use std::error::Error;

#[derive(Clone, Debug, Eq, Error, PartialEq)]
#[error(&quot;Found no username in {0}&quot;)]
struct EmptyUsernameError(String);

fn read_username(path: &amp;str) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
    let mut username = String::new();
    fs::File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(EmptyUsernameError(String::from(path)).into());
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err)     =&gt; println!(&quot;Error: {err}&quot;),
    }
}</code></pre></pre>
<details>
<p>This saves on code, but gives up the ability to cleanly handle different error cases differently in
the program. As such it‚Äôs generally not a good idea to use <code>Box&lt;dyn Error&gt;</code> in the public API of a
library, but it can be a good option in a program where you just want to display the error message
somewhere.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-context-to-errors"><a class="header" href="#adding-context-to-errors">Adding Context to Errors</a></h1>
<p>The widely used <a href="https://docs.rs/anyhow/">anyhow</a> crate can help you add
contextual information to your errors and allows you to have fewer
custom error types:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::{fs, io};
use std::io::Read;
use anyhow::{Context, Result, bail};

fn read_username(path: &amp;str) -&gt; Result&lt;String&gt; {
    let mut username = String::with_capacity(100);
    fs::File::open(path)
        .with_context(|| format!(&quot;Failed to open {path}&quot;))?
        .read_to_string(&amp;mut username)
        .context(&quot;Failed to read&quot;)?;
    if username.is_empty() {
        bail!(&quot;Found no username in {path}&quot;);
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err)     =&gt; println!(&quot;Error: {err:?}&quot;),
    }
}</code></pre></pre>
<details>
<ul>
<li><code>anyhow::Result&lt;V&gt;</code> is a type alias for <code>Result&lt;V, anyhow::Error&gt;</code>.</li>
<li><code>anyhow::Error</code> is essentially a wrapper around <code>Box&lt;dyn Error&gt;</code>. As such it‚Äôs again generally not
a good choice for the public API of a library, but is widely used in applications.</li>
<li>Actual error type inside of it can be extracted for examination if necessary.</li>
<li>Functionality provided by <code>anyhow::Result&lt;T&gt;</code> may be familiar to Go developers, as it provides
similar usage patterns and ergonomics to <code>(T, error)</code> from Go.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Rust and Cargo come with a simple unit test framework:</p>
<ul>
<li>
<p>Unit tests are supported throughout your code.</p>
</li>
<li>
<p>Integration tests are supported via the <code>tests/</code> directory.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h1>
<p>Mark unit tests with <code>#[test]</code>:</p>
<pre><code class="language-rust editable ignore">fn first_word(text: &amp;str) -&gt; &amp;str {
    match text.find(' ') {
        Some(idx) =&gt; &amp;text[..idx],
        None =&gt; &amp;text,
    }
}

#[test]
fn test_empty() {
    assert_eq!(first_word(&quot;&quot;), &quot;&quot;);
}

#[test]
fn test_single_word() {
    assert_eq!(first_word(&quot;Hello&quot;), &quot;Hello&quot;);
}

#[test]
fn test_multiple_words() {
    assert_eq!(first_word(&quot;Hello World&quot;), &quot;Hello&quot;);
}</code></pre>
<p>Use <code>cargo test</code> to find and run the unit tests.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-modules"><a class="header" href="#test-modules">Test Modules</a></h1>
<p>Unit tests are often put in a nested module (run tests on the
<a href="https://play.rust-lang.org/">Playground</a>):</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn helper(a: &amp;str, b: &amp;str) -&gt; String {
    format!(&quot;{a} {b}&quot;)
}

pub fn main() {
    println!(&quot;{}&quot;, helper(&quot;Hello&quot;, &quot;World&quot;));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_helper() {
        assert_eq!(helper(&quot;foo&quot;, &quot;bar&quot;), &quot;foo bar&quot;);
    }
}</code></pre></pre>
<ul>
<li>This lets you unit test private helpers.</li>
<li>The <code>#[cfg(test)]</code> attribute is only active when you run <code>cargo test</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation-tests"><a class="header" href="#documentation-tests">Documentation Tests</a></h1>
<p>Rust has built-in support for documentation tests:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Shortens a string to the given length.
///
/// ```
/// use playground::shorten_string;
/// assert_eq!(shorten_string(&quot;Hello World&quot;, 5), &quot;Hello&quot;);
/// assert_eq!(shorten_string(&quot;Hello World&quot;, 20), &quot;Hello World&quot;);
/// ```
pub fn shorten_string(s: &amp;str, length: usize) -&gt; &amp;str {
    &amp;s[..std::cmp::min(length, s.len())]
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Code blocks in <code>///</code> comments are automatically seen as Rust code.</li>
<li>The code will be compiled and executed as part of <code>cargo test</code>.</li>
<li>Test the above code on the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3ce2ad13ea1302f6572cb15cd96becf0">Rust Playground</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h1>
<p>If you want to test your library as a client, use an integration test.</p>
<p>Create a <code>.rs</code> file under <code>tests/</code>:</p>
<pre><code class="language-rust ignore">use my_library::init;

#[test]
fn test_init() {
    assert!(init().is_ok());
}</code></pre>
<p>These tests only have access to the public API of your crate.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="useful-crates-for-writing-tests"><a class="header" href="#useful-crates-for-writing-tests">Useful crates for writing tests</a></h2>
<p>Rust comes with only basic support for writing tests.</p>
<p>Here are some additional crates which we recommend for writing tests:</p>
<ul>
<li><a href="https://docs.rs/googletest">googletest</a>: Comprehensive test assertion library in the tradition of GoogleTest for C++.</li>
<li><a href="https://docs.rs/proptest">proptest</a>: Property-based testing for Rust.</li>
<li><a href="https://docs.rs/rstest">rstest</a>: Support for fixtures and parameterised tests.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h1>
<p>The Rust language has two parts:</p>
<ul>
<li><strong>Safe Rust:</strong> memory safe, no undefined behavior possible.</li>
<li><strong>Unsafe Rust:</strong> can trigger undefined behavior if preconditions are violated.</li>
</ul>
<p>We will be seeing mostly safe Rust in this course, but it‚Äôs important to know
what Unsafe Rust is.</p>
<p>Unsafe code is usually small and isolated, and its correctness should be carefully
documented. It is usually wrapped in a safe abstraction layer.</p>
<p>Unsafe Rust gives you access to five new capabilities:</p>
<ul>
<li>Dereference raw pointers.</li>
<li>Access or modify mutable static variables.</li>
<li>Access <code>union</code> fields.</li>
<li>Call <code>unsafe</code> functions, including <code>extern</code> functions.</li>
<li>Implement <code>unsafe</code> traits.</li>
</ul>
<p>We will briefly cover unsafe capabilities next. For full details, please see
<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">Chapter 19.1 in the Rust Book</a>
and the <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>.</p>
<details>
<p>Unsafe Rust does not mean the code is incorrect. It means that developers have
turned off the compiler safety features and have to write correct code by
themselves. It means the compiler no longer enforces Rust‚Äôs memory-safety rules.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dereferencing-raw-pointers"><a class="header" href="#dereferencing-raw-pointers">Dereferencing Raw Pointers</a></h1>
<p>Creating pointers is safe, but dereferencing them requires <code>unsafe</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut num = 5;

    let r1 = &amp;mut num as *mut i32;
    let r2 = r1 as *const i32;

    // Safe because r1 and r2 were obtained from references and so are
    // guaranteed to be non-null and properly aligned, the objects underlying
    // the references from which they were obtained are live throughout the
    // whole unsafe block, and they are not accessed either through the
    // references or concurrently through any other pointers.
    unsafe {
        println!(&quot;r1 is: {}&quot;, *r1);
        *r1 = 10;
        println!(&quot;r2 is: {}&quot;, *r2);
    }
}</code></pre></pre>
<details>
<p>It is good practice (and required by the Android Rust style guide) to write a comment for each
<code>unsafe</code> block explaining how the code inside it satisfies the safety requirements of the unsafe
operations it is doing.</p>
<p>In the case of pointer dereferences, this means that the pointers must be
<a href="https://doc.rust-lang.org/std/ptr/index.html#safety"><em>valid</em></a>, i.e.:</p>
<ul>
<li>The pointer must be non-null.</li>
<li>The pointer must be <em>dereferenceable</em> (within the bounds of a single allocated object).</li>
<li>The object must not have been deallocated.</li>
<li>There must not be concurrent accesses to the same location.</li>
<li>If the pointer was obtained by casting a reference, the underlying object must be live and no
reference may be used to access the memory.</li>
</ul>
<p>In most cases the pointer must also be properly aligned.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-static-variables"><a class="header" href="#mutable-static-variables">Mutable Static Variables</a></h1>
<p>It is safe to read an immutable static variable:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;HELLO_WORLD: {HELLO_WORLD}&quot;);
}</code></pre></pre>
<p>However, since data races can occur, it is unsafe to read and write mutable
static variables:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">static mut COUNTER: u32 = 0;

fn add_to_counter(inc: u32) {
    unsafe { COUNTER += inc; }  // Potential data race!
}

fn main() {
    add_to_counter(42);

    unsafe { println!(&quot;COUNTER: {COUNTER}&quot;); }  // Potential data race!
}</code></pre></pre>
<details>
<p>Using a mutable static is generally a bad idea, but there are some cases where it might make sense
in low-level <code>no_std</code> code, such as implementing a heap allocator or working with some C APIs.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unions"><a class="header" href="#unions">Unions</a></h1>
<p>Unions are like enums, but you need to track the active field yourself:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[repr(C)]
union MyUnion {
    i: u8,
    b: bool,
}

fn main() {
    let u = MyUnion { i: 42 };
    println!(&quot;int: {}&quot;, unsafe { u.i });
    println!(&quot;bool: {}&quot;, unsafe { u.b });  // Undefined behavior!
}</code></pre></pre>
<details>
<p>Unions are very rarely needed in Rust as you can usually use an enum. They are occasionally needed
for interacting with C library APIs.</p>
<p>If you just want to reinterpret bytes as a different type, you probably want
<a href="https://doc.rust-lang.org/stable/std/mem/fn.transmute.html"><code>std::mem::transmute</code></a> or a safe
wrapper such as the <a href="https://crates.io/crates/zerocopy"><code>zerocopy</code></a> crate.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-unsafe-functions"><a class="header" href="#calling-unsafe-functions">Calling Unsafe Functions</a></h1>
<p>A function or method can be marked <code>unsafe</code> if it has extra preconditions you
must uphold to avoid undefined behaviour:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let emojis = &quot;üóª‚ààüåè&quot;;

    // Safe because the indices are in the correct order, within the bounds of
    // the string slice, and lie on UTF-8 sequence boundaries.
    unsafe {
        println!(&quot;emoji: {}&quot;, emojis.get_unchecked(0..4));
        println!(&quot;emoji: {}&quot;, emojis.get_unchecked(4..7));
        println!(&quot;emoji: {}&quot;, emojis.get_unchecked(7..11));
    }

    println!(&quot;char count: {}&quot;, count_chars(unsafe { emojis.get_unchecked(0..7) }));

    // Not upholding the UTF-8 encoding requirement breaks memory safety!
    // println!(&quot;emoji: {}&quot;, unsafe { emojis.get_unchecked(0..3) });
    // println!(&quot;char count: {}&quot;, count_chars(unsafe { emojis.get_unchecked(0..3) }));
}

fn count_chars(s: &amp;str) -&gt; usize {
    s.chars().map(|_| 1).sum()
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-unsafe-functions"><a class="header" href="#writing-unsafe-functions">Writing Unsafe Functions</a></h1>
<p>You can mark your own functions as <code>unsafe</code> if they require particular conditions to avoid undefined
behaviour.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">/// Swaps the values pointed to by the given pointers.
///
/// # Safety
///
/// The pointers must be valid and properly aligned.
unsafe fn swap(a: *mut u8, b: *mut u8) {
    let temp = *a;
    *a = *b;
    *b = temp;
}

fn main() {
    let mut a = 42;
    let mut b = 66;

    // Safe because ...
    unsafe {
        swap(&amp;mut a, &amp;mut b);
    }

    println!(&quot;a = {}, b = {}&quot;, a, b);
}</code></pre></pre>
<details>
<p>We wouldn‚Äôt actually use pointers for this because it can be done safely with references.</p>
<p>Note that unsafe code is allowed within an unsafe function without an <code>unsafe</code> block. We can
prohibit this with <code>#[deny(unsafe_op_in_unsafe_fn)]</code>. Try adding it and see what happens.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-external-code"><a class="header" href="#calling-external-code">Calling External Code</a></h1>
<p>Functions from other languages might violate the guarantees of Rust. Calling
them is thus unsafe:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        // Undefined behavior if abs misbehaves.
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}</code></pre></pre>
<details>
<p>This is usually only a problem for extern functions which do things with pointers which might
violate Rust‚Äôs memory model, but in general any C function might have undefined behaviour under any
arbitrary circumstances.</p>
<p>The <code>&quot;C&quot;</code> in this example is the ABI;
<a href="https://doc.rust-lang.org/reference/items/external-blocks.html">other ABIs are available too</a>.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-unsafe-traits"><a class="header" href="#implementing-unsafe-traits">Implementing Unsafe Traits</a></h1>
<p>Like with functions, you can mark a trait as <code>unsafe</code> if the implementation must guarantee
particular conditions to avoid undefined behaviour.</p>
<p>For example, the <code>zerocopy</code> crate has an unsafe trait that looks
<a href="https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html">something like this</a>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::mem::size_of_val;
use std::slice;

/// ...
/// # Safety
/// The type must have a defined representation and no padding.
pub unsafe trait AsBytes {
    fn as_bytes(&amp;self) -&gt; &amp;[u8] {
        unsafe {
            slice::from_raw_parts(self as *const Self as *const u8, size_of_val(self))
        }
    }
}

// Safe because u32 has a defined representation and no padding.
unsafe impl AsBytes for u32 {}</code></pre></pre>
<details>
<p>There should be a <code># Safety</code> section on the Rustdoc for the trait explaining the requirements for
the trait to be safely implemented.</p>
<p>The actual safety section for <code>AsBytes</code> is rather longer and more complicated.</p>
<p>The built-in <code>Send</code> and <code>Sync</code> traits are unsafe.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-3-afternoon-exercises"><a class="header" href="#day-3-afternoon-exercises">Day 3: Afternoon Exercises</a></h1>
<p>Let us build a safe wrapper for reading directory content!</p>
<p>For this exercise, we suggest using a local dev environment instead
of the Playground. This will allow you to run your binary on your own machine.</p>
<p>To get started, follow the <a href="cargo/running-locally.html">running locally</a> instructions.</p>
<details>
<p>After looking at the exercise, you can look at the <a href="exercises/day-3/solutions-afternoon.html">solution</a> provided.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="safe-ffi-wrapper"><a class="header" href="#safe-ffi-wrapper">Safe FFI Wrapper</a></h1>
<p>Rust has great support for calling functions through a <em>foreign function
interface</em> (FFI). We will use this to build a safe wrapper for the <code>libc</code>
functions you would use from C to read the filenames of a directory.</p>
<p>You will want to consult the manual pages:</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man3/opendir.3.html"><code>opendir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/readdir.3.html"><code>readdir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/closedir.3.html"><code>closedir(3)</code></a></li>
</ul>
<p>You will also want to browse the <a href="https://doc.rust-lang.org/std/ffi/"><code>std::ffi</code></a> module. There you find a number of
string types which you need for the exercise:</p>
<div class="table-wrapper"><table><thead><tr><th>Types</th><th>Encoding</th><th>Use</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/std/primitive.str.html"><code>str</code></a> and <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a></td><td>UTF-8</td><td>Text processing in Rust</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ffi/struct.CStr.html"><code>CStr</code></a> and <a href="https://doc.rust-lang.org/std/ffi/struct.CString.html"><code>CString</code></a></td><td>NUL-terminated</td><td>Communicating with C functions</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html"><code>OsStr</code></a> and <a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>OsString</code></a></td><td>OS-specific</td><td>Communicating with the OS</td></tr>
</tbody></table>
</div>
<p>You will convert between all these types:</p>
<ul>
<li><code>&amp;str</code> to <code>CString</code>: you need to allocate space for a trailing <code>\0</code> character,</li>
<li><code>CString</code> to <code>*const i8</code>: you need a pointer to call C functions,</li>
<li><code>*const i8</code> to <code>&amp;CStr</code>: you need something which can find the trailing <code>\0</code> character,</li>
<li><code>&amp;CStr</code> to <code>&amp;[u8]</code>: a slice of bytes is the universal interface for ‚Äúsome unknow data‚Äù,</li>
<li><code>&amp;[u8]</code> to <code>&amp;OsStr</code>: <code>&amp;OsStr</code> is a step towards <code>OsString</code>, use
<a href="https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html"><code>OsStrExt</code></a>
to create it,</li>
<li><code>&amp;OsStr</code> to <code>OsString</code>: you need to clone the data in <code>&amp;OsStr</code> to be able to return it and call
<code>readdir</code> again.</li>
</ul>
<p>The <a href="https://doc.rust-lang.org/nomicon/ffi.html">Nomicon</a> also has a very useful chapter about FFI.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing
functions and methods:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2021">// TODO: remove this when you're done with your implementation.
#![allow(unused_imports, unused_variables, dead_code)]

mod ffi {
    use std::os::raw::{c_char, c_int};
    #[cfg(not(target_os = &quot;macos&quot;))]
    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    // Layout according to the Linux man page for readdir(3), where ino_t and
    // off_t are resolved according to the definitions in
    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.
    #[cfg(not(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_ulong,
        pub d_off: c_long,
        pub d_reclen: c_ushort,
        pub d_type: c_uchar,
        pub d_name: [c_char; 256],
    }

    // Layout according to the macOS man page for dir(5).
    #[cfg(all(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_fileno: u64,
        pub d_seekoff: u64,
        pub d_reclen: u16,
        pub d_namlen: u16,
        pub d_type: u8,
        pub d_name: [c_char; 1024],
    }

    extern &quot;C&quot; {
        pub fn opendir(s: *const c_char) -&gt; *mut DIR;

        #[cfg(not(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;)))]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        // See https://github.com/rust-lang/libc/issues/414 and the section on
        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).
        //
        // &quot;Platforms that existed before these updates were available&quot; refers
        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and PowerPC.
        #[cfg(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;))]
        #[link_name = &quot;readdir$INODE64&quot;]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        pub fn closedir(s: *mut DIR) -&gt; c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}

impl DirectoryIterator {
    fn new(path: &amp;str) -&gt; Result&lt;DirectoryIterator, String&gt; {
        // Call opendir and return a Ok value if that worked,
        // otherwise return Err with a message.
        unimplemented!()
    }
}

impl Iterator for DirectoryIterator {
    type Item = OsString;
    fn next(&amp;mut self) -&gt; Option&lt;OsString&gt; {
        // Keep calling readdir until we get a NULL pointer back.
        unimplemented!()
    }
}

impl Drop for DirectoryIterator {
    fn drop(&amp;mut self) {
        // Call closedir as needed.
        unimplemented!()
    }
}

fn main() -&gt; Result&lt;(), String&gt; {
    let iter = DirectoryIterator::new(&quot;.&quot;)?;
    println!(&quot;files: {:#?}&quot;, iter.collect::&lt;Vec&lt;_&gt;&gt;());
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-rust-in-android"><a class="header" href="#welcome-to-rust-in-android">Welcome to Rust in Android</a></h1>
<p>Rust is supported for native platform development on Android. This means that
you can write new operating system services in Rust, as well as extending
existing services.</p>
<blockquote>
<p>We will attempt to call Rust from one of your own projects today. So try to
find a little corner of your code base where we can move some lines of code to
Rust. The fewer dependencies and ‚Äúexotic‚Äù types the better. Something that
parses some raw bytes would be ideal.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>We will be using an Android Virtual Device to test our code. Make sure you have
access to one or create a new one with:</p>
<pre><code class="language-shell">source build/envsetup.sh
lunch aosp_cf_x86_64_phone-userdebug
acloud create
</code></pre>
<p>Please see the <a href="https://source.android.com/docs/setup/start">Android Developer
Codelab</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-rules"><a class="header" href="#build-rules">Build Rules</a></h1>
<p>The Android build system (Soong) supports Rust via a number of modules:</p>
<div class="table-wrapper"><table><thead><tr><th>Module Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rust_binary</code></td><td>Produces a Rust binary.</td></tr>
<tr><td><code>rust_library</code></td><td>Produces a Rust library, and provides both <code>rlib</code> and <code>dylib</code> variants.</td></tr>
<tr><td><code>rust_ffi</code></td><td>Produces a Rust C library usable by <code>cc</code> modules, and provides both static and shared variants.</td></tr>
<tr><td><code>rust_proc_macro</code></td><td>Produces a <code>proc-macro</code> Rust library. These are analogous to compiler plugins.</td></tr>
<tr><td><code>rust_test</code></td><td>Produces a Rust test binary that uses the standard Rust test harness.</td></tr>
<tr><td><code>rust_fuzz</code></td><td>Produces a Rust fuzz binary leveraging <code>libfuzzer</code>.</td></tr>
<tr><td><code>rust_protobuf</code></td><td>Generates source and produces a Rust library that provides an interface for a particular protobuf.</td></tr>
<tr><td><code>rust_bindgen</code></td><td>Generates source and produces a Rust library containing Rust bindings to C libraries.</td></tr>
</tbody></table>
</div>
<p>We will look at <code>rust_binary</code> and <code>rust_library</code> next.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-binaries"><a class="header" href="#rust-binaries">Rust Binaries</a></h1>
<p>Let us start with a simple application. At the root of an AOSP checkout, create
the following files:</p>
<p><em>hello_rust/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;hello_rust&quot;,
    crate_name: &quot;hello_rust&quot;,
    srcs: [&quot;src/main.rs&quot;],
}
</code></pre>
<p><em>hello_rust/src/main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">//! Rust demo.

/// Prints a greeting to standard output.
fn main() {
    println!(&quot;Hello from Rust!&quot;);
}</code></pre></pre>
<p>You can now build, push, and run the binary:</p>
<pre><code class="language-shell">m hello_rust
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp&quot;
adb shell /data/local/tmp/hello_rust
</code></pre>
<pre><code class="language-text">Hello from Rust!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-libraries"><a class="header" href="#rust-libraries">Rust Libraries</a></h1>
<p>You use <code>rust_library</code> to create a new Rust library for Android.</p>
<p>Here we declare a dependency on two libraries:</p>
<ul>
<li><code>libgreeting</code>, which we define below,</li>
<li><code>libtextwrap</code>, which is a crate already vendored in
<a href="https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"><code>external/rust/crates/</code></a>.</li>
</ul>
<p><em>hello_rust/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;hello_rust_with_dep&quot;,
    crate_name: &quot;hello_rust_with_dep&quot;,
    srcs: [&quot;src/main.rs&quot;],
    rustlibs: [
        &quot;libgreetings&quot;,
        &quot;libtextwrap&quot;,
    ],
    prefer_rlib: true,
}

rust_library {
    name: &quot;libgreetings&quot;,
    crate_name: &quot;greetings&quot;,
    srcs: [&quot;src/lib.rs&quot;],
}
</code></pre>
<p><em>hello_rust/src/main.rs</em>:</p>
<pre><code class="language-rust ignore">//! Rust demo.

use greetings::greeting;
use textwrap::fill;

/// Prints a greeting to standard output.
fn main() {
    println!(&quot;{}&quot;, fill(&amp;greeting(&quot;Bob&quot;), 24));
}</code></pre>
<p><em>hello_rust/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">//! Greeting library.

/// Greet `name`.
pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {name}, it is very nice to meet you!&quot;)
}</code></pre>
<p>You build, push, and run the binary like before:</p>
<pre><code class="language-shell">m hello_rust_with_dep
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/tmp&quot;
adb shell /data/local/tmp/hello_rust_with_dep
</code></pre>
<pre><code class="language-text">Hello Bob, it is very
nice to meet you!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aidl"><a class="header" href="#aidl">AIDL</a></h1>
<p>The <a href="https://developer.android.com/guide/components/aidl">Android Interface Definition Language
(AIDL)</a> is supported in Rust:</p>
<ul>
<li>Rust code can call existing AIDL servers,</li>
<li>You can create new AIDL servers in Rust.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aidl-interfaces"><a class="header" href="#aidl-interfaces">AIDL Interfaces</a></h1>
<p>You declare the API of your service using an AIDL interface:</p>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</em>:</p>
<pre><code class="language-java">package com.example.birthdayservice;

/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years);
}
</code></pre>
<p><em>birthday_service/aidl/Android.bp</em>:</p>
<pre><code class="language-javascript">aidl_interface {
    name: &quot;com.example.birthdayservice&quot;,
    srcs: [&quot;com/example/birthdayservice/*.aidl&quot;],
    unstable: true,
    backend: {
        rust: { // Rust is not enabled by default
            enabled: true,
        },
    },
}
</code></pre>
<p>Add <code>vendor_available: true</code> if your AIDL file is used by a binary in the vendor
partition.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-implementation"><a class="header" href="#service-implementation">Service Implementation</a></h1>
<p>We can now implement the AIDL service:</p>
<p><em>birthday_service/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">//! Implementation of the `IBirthdayService` AIDL interface.
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::binder;

/// The `IBirthdayService` implementation.
pub struct BirthdayService;

impl binder::Interface for BirthdayService {}

impl IBirthdayService for BirthdayService {
    fn wishHappyBirthday(&amp;self, name: &amp;str, years: i32) -&gt; binder::Result&lt;String&gt; {
        Ok(format!(
            &quot;Happy Birthday {name}, congratulations with the {years} years!&quot;
        ))
    }
}</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_library {
    name: &quot;libbirthdayservice&quot;,
    srcs: [&quot;src/lib.rs&quot;],
    crate_name: &quot;birthdayservice&quot;,
    rustlibs: [
        &quot;com.example.birthdayservice-rust&quot;,
        &quot;libbinder_rs&quot;,
    ],
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aidl-server"><a class="header" href="#aidl-server">AIDL Server</a></h1>
<p>Finally, we can create a server which exposes the service:</p>
<p><em>birthday_service/src/server.rs</em>:</p>
<pre><code class="language-rust ignore">//! Birthday service.
use birthdayservice::BirthdayService;
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::BnBirthdayService;
use com_example_birthdayservice::binder;

const SERVICE_IDENTIFIER: &amp;str = &quot;birthdayservice&quot;;

/// Entry point for birthday service.
fn main() {
    let birthday_service = BirthdayService;
    let birthday_service_binder = BnBirthdayService::new_binder(
        birthday_service,
        binder::BinderFeatures::default(),
    );
    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder.as_binder())
        .expect(&quot;Failed to register service&quot;);
    binder::ProcessState::join_thread_pool()
}</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;birthday_server&quot;,
    crate_name: &quot;birthday_server&quot;,
    srcs: [&quot;src/server.rs&quot;],
    rustlibs: [
        &quot;com.example.birthdayservice-rust&quot;,
        &quot;libbinder_rs&quot;,
        &quot;libbirthdayservice&quot;,
    ],
    prefer_rlib: true,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploy"><a class="header" href="#deploy">Deploy</a></h1>
<p>We can now build, push, and start the service:</p>
<pre><code class="language-shell">m birthday_server
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/tmp&quot;
adb shell /data/local/tmp/birthday_server
</code></pre>
<p>In another terminal, check that the service runs:</p>
<pre><code class="language-shell">adb shell service check birthdayservice
</code></pre>
<pre><code class="language-text">Service birthdayservice: found
</code></pre>
<p>You can also call the service with <code>service call</code>:</p>
<pre><code class="language-shell">adb shell service call birthdayservice 1 s16 Bob i32 24
</code></pre>
<pre><code class="language-text">Result: Parcel(
  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'
  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'
  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'
  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'
  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'
  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'
  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'
  0x00000070: 00210073 00000000                   's.!.....        ')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aidl-client"><a class="header" href="#aidl-client">AIDL Client</a></h1>
<p>Finally, we can create a Rust client for our new service.</p>
<p><em>birthday_service/src/client.rs</em>:</p>
<pre><code class="language-rust ignore">//! Birthday service.
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::binder;

const SERVICE_IDENTIFIER: &amp;str = &quot;birthdayservice&quot;;

/// Connect to the BirthdayService.
pub fn connect() -&gt; Result&lt;binder::Strong&lt;dyn IBirthdayService&gt;, binder::StatusCode&gt; {
    binder::get_interface(SERVICE_IDENTIFIER)
}

/// Call the birthday service.
fn main() -&gt; Result&lt;(), binder::Status&gt; {
    let name = std::env::args()
        .nth(1)
        .unwrap_or_else(|| String::from(&quot;Bob&quot;));
    let years = std::env::args()
        .nth(2)
        .and_then(|arg| arg.parse::&lt;i32&gt;().ok())
        .unwrap_or(42);

    binder::ProcessState::start_thread_pool();
    let service = connect().expect(&quot;Failed to connect to BirthdayService&quot;);
    let msg = service.wishHappyBirthday(&amp;name, years)?;
    println!(&quot;{msg}&quot;);
    Ok(())
}</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;birthday_client&quot;,
    crate_name: &quot;birthday_client&quot;,
    srcs: [&quot;src/client.rs&quot;],
    rustlibs: [
        &quot;com.example.birthdayservice-rust&quot;,
        &quot;libbinder_rs&quot;,
    ],
    prefer_rlib: true,
}
</code></pre>
<p>Notice that the client does not depend on <code>libbirthdayservice</code>.</p>
<p>Build, push, and run the client on your device:</p>
<pre><code class="language-shell">m birthday_client
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/tmp&quot;
adb shell /data/local/tmp/birthday_client Charlie 60
</code></pre>
<pre><code class="language-text">Happy Birthday Charlie, congratulations with the 60 years!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changing-api"><a class="header" href="#changing-api">Changing API</a></h1>
<p>Let us extend the API with more functionality: we want to let clients specify a
list of lines for the birthday card:</p>
<pre><code class="language-java">package com.example.birthdayservice;

/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years, in String[] text);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>You should use the <code>log</code> crate to automatically log to <code>logcat</code> (on-device) or
<code>stdout</code> (on-host):</p>
<p><em>hello_rust_logs/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;hello_rust_logs&quot;,
    crate_name: &quot;hello_rust_logs&quot;,
    srcs: [&quot;src/main.rs&quot;],
    rustlibs: [
        &quot;liblog_rust&quot;,
        &quot;liblogger&quot;,
    ],
    prefer_rlib: true,
    host_supported: true,
}
</code></pre>
<p><em>hello_rust_logs/src/main.rs</em>:</p>
<pre><code class="language-rust ignore">//! Rust logging demo.

use log::{debug, error, info};

/// Logs a greeting.
fn main() {
    logger::init(
        logger::Config::default()
            .with_tag_on_device(&quot;rust&quot;)
            .with_min_level(log::Level::Trace),
    );
    debug!(&quot;Starting program.&quot;);
    info!(&quot;Things are going fine.&quot;);
    error!(&quot;Something went wrong!&quot;);
}</code></pre>
<p>Build, push, and run the binary on your device:</p>
<pre><code class="language-shell">m hello_rust_logs
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/tmp&quot;
adb shell /data/local/tmp/hello_rust_logs
</code></pre>
<p>The logs show up in <code>adb logcat</code>:</p>
<pre><code class="language-shell">adb logcat -s rust
</code></pre>
<pre><code class="language-text">09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.
09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going fine.
09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went wrong!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interoperability"><a class="header" href="#interoperability">Interoperability</a></h1>
<p>Rust has excellent support for interoperability with other languages. This means
that you can:</p>
<ul>
<li>Call Rust functions from other languages.</li>
<li>Call functions written in other languages from Rust.</li>
</ul>
<p>When you call functions in a foreign language we say that you‚Äôre using a
<em>foreign function interface</em>, also known as FFI.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interoperability-with-c"><a class="header" href="#interoperability-with-c">Interoperability with C</a></h1>
<p>Rust has full support for linking object files with a C calling convention.
Similarly, you can export Rust functions and call them from C.</p>
<p>You can do it by hand if you want:</p>
<pre><pre class="playground"><code class="language-rust edition2021">extern &quot;C&quot; {
    fn abs(x: i32) -&gt; i32;
}

fn main() {
    let x = -42;
    let abs_x = unsafe { abs(x) };
    println!(&quot;{x}, {abs_x}&quot;);
}</code></pre></pre>
<p>We already saw this in the <a href="exercises/day-3/safe-ffi-wrapper.html">Safe FFI Wrapper
exercise</a>.</p>
<blockquote>
<p>This assumes full knowledge of the target platform. Not recommended for
production.</p>
</blockquote>
<p>We will look at better options next.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-bindgen"><a class="header" href="#using-bindgen">Using Bindgen</a></h1>
<p>The <a href="https://rust-lang.github.io/rust-bindgen/introduction.html">bindgen</a> tool
can auto-generate bindings from a C header file.</p>
<p>First create a small C library:</p>
<p><em>interoperability/bindgen/libbirthday.h</em>:</p>
<pre><code class="language-c">typedef struct card {
  const char* name;
  int years;
} card;

void print_card(const card* card);
</code></pre>
<p><em>interoperability/bindgen/libbirthday.c</em>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;libbirthday.h&quot;

void print_card(const card* card) {
  printf(&quot;+--------------\n&quot;);
  printf(&quot;| Happy Birthday %s!\n&quot;, card-&gt;name);
  printf(&quot;| Congratulations with the %i years!\n&quot;, card-&gt;years);
  printf(&quot;+--------------\n&quot;);
}
</code></pre>
<p>Add this to your <code>Android.bp</code> file:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">cc_library {
    name: &quot;libbirthday&quot;,
    srcs: [&quot;libbirthday.c&quot;],
}
</code></pre>
<p>Create a wrapper header file for the library (not strictly needed in this
example):</p>
<p><em>interoperability/bindgen/libbirthday_wrapper.h</em>:</p>
<pre><code class="language-c">#include &quot;libbirthday.h&quot;
</code></pre>
<p>You can now auto-generate the bindings:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_bindgen {
    name: &quot;libbirthday_bindgen&quot;,
    crate_name: &quot;birthday_bindgen&quot;,
    wrapper_src: &quot;libbirthday_wrapper.h&quot;,
    source_stem: &quot;bindings&quot;,
    static_libs: [&quot;libbirthday&quot;],
}
</code></pre>
<p>Finally, we can use the bindings in our Rust program:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;print_birthday_card&quot;,
    srcs: [&quot;main.rs&quot;],
    rustlibs: [&quot;libbirthday_bindgen&quot;],
}
</code></pre>
<p><em>interoperability/bindgen/main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">//! Bindgen demo.

use birthday_bindgen::{card, print_card};

fn main() {
    let name = std::ffi::CString::new(&quot;Peter&quot;).unwrap();
    let card = card {
        name: name.as_ptr(),
        years: 42,
    };
    unsafe {
        print_card(&amp;card as *const card);
    }
}</code></pre></pre>
<p>Build, push, and run the binary on your device:</p>
<pre><code class="language-shell">m print_birthday_card
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/tmp&quot;
adb shell /data/local/tmp/print_birthday_card
</code></pre>
<p>Finally, we can run auto-generated tests to ensure the bindings work:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_test {
    name: &quot;libbirthday_bindgen_test&quot;,
    srcs: [&quot;:libbirthday_bindgen&quot;],
    crate_name: &quot;libbirthday_bindgen_test&quot;,
    test_suites: [&quot;general-tests&quot;],
    auto_gen_config: true,
    clippy_lints: &quot;none&quot;, // Generated file, skip linting
    lints: &quot;none&quot;,
}
</code></pre>
<pre><code class="language-shell">atest libbirthday_bindgen_test
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-rust"><a class="header" href="#calling-rust">Calling Rust</a></h1>
<p>Exporting Rust functions and types to C is easy:</p>
<p><em>interoperability/rust/libanalyze/analyze.rs</em></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">//! Rust FFI demo.
#![deny(improper_ctypes_definitions)]

use std::os::raw::c_int;

/// Analyze the numbers.
#[no_mangle]
pub extern &quot;C&quot; fn analyze_numbers(x: c_int, y: c_int) {
    if x &lt; y {
        println!(&quot;x ({x}) is smallest!&quot;);
    } else {
        println!(&quot;y ({y}) is probably larger than x ({x})&quot;);
    }
}</code></pre></pre>
<p><em>interoperability/rust/libanalyze/analyze.h</em></p>
<pre><code class="language-c">#ifndef ANALYSE_H
#define ANALYSE_H

extern &quot;C&quot; {
void analyze_numbers(int x, int y);
}

#endif
</code></pre>
<p><em>interoperability/rust/libanalyze/Android.bp</em></p>
<pre><code class="language-javascript">rust_ffi {
    name: &quot;libanalyze_ffi&quot;,
    crate_name: &quot;analyze_ffi&quot;,
    srcs: [&quot;analyze.rs&quot;],
    include_dirs: [&quot;.&quot;],
}
</code></pre>
<p>We can now call this from a C binary:</p>
<p><em>interoperability/rust/analyze/main.c</em></p>
<pre><code class="language-c">#include &quot;analyze.h&quot;

int main() {
  analyze_numbers(10, 20);
  analyze_numbers(123, 123);
  return 0;
}
</code></pre>
<p><em>interoperability/rust/analyze/Android.bp</em></p>
<pre><code class="language-javascript">cc_binary {
    name: &quot;analyze_numbers&quot;,
    srcs: [&quot;main.c&quot;],
    static_libs: [&quot;libanalyze_ffi&quot;],
}
</code></pre>
<p>Build, push, and run the binary on your device:</p>
<pre><code class="language-shell">m analyze_numbers
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/tmp&quot;
adb shell /data/local/tmp/analyze_numbers
</code></pre>
<details>
<p><code>#[no_mangle]</code> disables Rust‚Äôs usual name mangling, so the exported symbol will just be the name of
the function. You can also use <code>#[export_name = &quot;some_name&quot;]</code> to specify whatever name you want.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-c"><a class="header" href="#with-c">With C++</a></h1>
<p>The <a href="https://cxx.rs/">CXX crate</a> makes it possible to do safe interoperability between Rust
and C++.</p>
<p>The overall approach looks like this:</p>
<img src="android/interoperability/cpp/overview.svg">
<p>See the <a href="https://cxx.rs/tutorial.html">CXX tutorial</a> for an full example of using this.</p>
<details>
<ul>
<li>
<p>At this point, the instructor should switch to the <a href="https://cxx.rs/tutorial.html">CXX tutorial</a>.</p>
</li>
<li>
<p>Walk the students through the tutorial step by step.</p>
</li>
<li>
<p>Highlight how CXX presents a clean interface without unsafe code in <em>both languages</em>.</p>
</li>
<li>
<p>Show the correspondence between <a href="https://cxx.rs/bindings.html">Rust and C++ types</a>:</p>
<ul>
<li>
<p>Explain how a Rust <code>String</code> cannot map to a C++ <code>std::string</code>
(the latter does not uphold the UTF-8 invariant). Show that
despite being different types, <code>rust::String</code> in C++ can be
easily constructed from a C++ <code>std::string</code>, making it very
ergonomic to use.</p>
</li>
<li>
<p>Explain that a Rust function returning <code>Result&lt;T, E&gt;</code> becomes a
function which throws a <code>E</code> exception in C++ (and vice versa).</p>
</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interoperability-with-java"><a class="header" href="#interoperability-with-java">Interoperability with Java</a></h1>
<p>Java can load shared objects via <a href="https://en.wikipedia.org/wiki/Java_Native_Interface">Java Native Interface
(JNI)</a>. The <a href="https://docs.rs/jni/"><code>jni</code>
crate</a> allows you to create a compatible library.</p>
<p>First, we create a Rust function to export to Java:</p>
<p><em>interoperability/java/src/lib.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Rust &lt;-&gt; Java FFI demo.

use jni::objects::{JClass, JString};
use jni::sys::jstring;
use jni::JNIEnv;

/// HelloWorld::hello method implementation.
#[no_mangle]
pub extern &quot;system&quot; fn Java_HelloWorld_hello(
    env: JNIEnv,
    _class: JClass,
    name: JString,
) -&gt; jstring {
    let input: String = env.get_string(name).unwrap().into();
    let greeting = format!(&quot;Hello, {input}!&quot;);
    let output = env.new_string(greeting).unwrap();
    output.into_inner()
}
<span class="boring">}</span></code></pre></pre>
<p><em>interoperability/java/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_ffi_shared {
    name: &quot;libhello_jni&quot;,
    crate_name: &quot;hello_jni&quot;,
    srcs: [&quot;src/lib.rs&quot;],
    rustlibs: [&quot;libjni&quot;],
}
</code></pre>
<p>Finally, we can call this function from Java:</p>
<p><em>interoperability/java/HelloWorld.java</em>:</p>
<pre><code class="language-java">class HelloWorld {
    private static native String hello(String name);

    static {
        System.loadLibrary(&quot;hello_jni&quot;);
    }

    public static void main(String[] args) {
        String output = HelloWorld.hello(&quot;Alice&quot;);
        System.out.println(output);
    }
}
</code></pre>
<p><em>interoperability/java/Android.bp</em>:</p>
<pre><code class="language-javascript">java_binary {
    name: &quot;helloworld_jni&quot;,
    srcs: [&quot;HelloWorld.java&quot;],
    main_class: &quot;HelloWorld&quot;,
    required: [&quot;libhello_jni&quot;],
}
</code></pre>
<p>Finally, you can build, sync, and run the binary:</p>
<pre><code class="language-shell">m helloworld_jni
adb sync  # requires adb root &amp;&amp; adb remount
adb shell /system/bin/helloworld_jni
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<p>This is a group exercise: We will look at one of the projects you work with and
try to integrate some Rust into it. Some suggestions:</p>
<ul>
<li>
<p>Call your AIDL service with a client written in Rust.</p>
</li>
<li>
<p>Move a function from your project to Rust and call it.</p>
</li>
</ul>
<details>
<p>No solution is provided here since this is open-ended: it relies on someone in
the class having a piece of code which you can turn in to Rust on the fly.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-bare-metal-rust"><a class="header" href="#welcome-to-bare-metal-rust">Welcome to Bare Metal Rust</a></h1>
<p>This is a standalone one-day course about bare-metal Rust, aimed at people who are familiar with the
basics of Rust (perhaps from completing the Comprehensive Rust course), and ideally also have some
experience with bare-metal programming in some other language such as C.</p>
<p>Today we will talk about ‚Äòbare-metal‚Äô Rust: running Rust code without an OS underneath us. This will
be divided into several parts:</p>
<ul>
<li>What is <code>no_std</code> Rust?</li>
<li>Writing firmware for microcontrollers.</li>
<li>Writing bootloader / kernel code for application processors.</li>
<li>Some useful crates for bare-metal Rust development.</li>
</ul>
<p>For the microcontroller part of the course we will use the <a href="https://microbit.org/">BBC micro:bit</a> v2
as an example. It‚Äôs a <a href="https://tech.microbit.org/hardware/">development board</a> based on the Nordic
nRF51822 microcontroller with some LEDs and buttons, an I2C-connected accelerometer and compass, and
an on-board SWD debugger.</p>
<p>To get started, install some tools we‚Äôll need later. On gLinux or Debian:</p>
<pre><code class="language-bash">sudo apt install gcc-aarch64-linux-gnu gdb-multiarch libudev-dev picocom pkg-config qemu-system-arm
rustup update
rustup target add aarch64-unknown-none thumbv7em-none-eabihf
rustup component add llvm-tools-preview
cargo install cargo-binutils cargo-embed
</code></pre>
<p>And give users in the <code>plugdev</code> group access to the micro:bit programmer:</p>
<pre><code class="language-bash">echo 'SUBSYSTEM==&quot;usb&quot;, ATTR{idVendor}==&quot;0d28&quot;, MODE=&quot;0664&quot;, GROUP=&quot;plugdev&quot;' |\
  sudo tee /etc/udev/rules.d/50-microbit.rules
sudo udevadm control --reload-rules
</code></pre>
<p>On MacOS:</p>
<pre><code class="language-bash">xcode-select --install
brew install gdb picocom qemu
brew install --cask gcc-aarch64-embedded
rustup update
rustup target add aarch64-unknown-none thumbv7em-none-eabihf
rustup component add llvm-tools-preview
cargo install cargo-binutils cargo-embed
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="no_std"><a class="header" href="#no_std"><code>no_std</code></a></h1>
<table>
<tr>
<th>
<p><code>core</code></p>
</th>
<th>
<p><code>alloc</code></p>
</th>
<th>
<p><code>std</code></p>
</th>
</tr>
<tr valign="top">
<td>
<ul>
<li>Slices, <code>&amp;str</code>, <code>CStr</code></li>
<li><code>NonZeroU8</code>‚Ä¶</li>
<li><code>Option</code>, <code>Result</code></li>
<li><code>Display</code>, <code>Debug</code>, <code>write!</code>‚Ä¶</li>
<li><code>Iterator</code></li>
<li><code>panic!</code>, <code>assert_eq!</code>‚Ä¶</li>
<li><code>NonNull</code> and all the usual pointer-related functions</li>
<li><code>Future</code> and <code>async</code>/<code>await</code></li>
<li><code>fence</code>, <code>AtomicBool</code>, <code>AtomicPtr</code>, <code>AtomicU32</code>‚Ä¶</li>
<li><code>Duration</code></li>
</ul>
</td>
<td>
<ul>
<li><code>Box</code>, <code>Cow</code>, <code>Arc</code>, <code>Rc</code></li>
<li><code>Vec</code>, <code>BinaryHeap</code>, <code>BtreeMap</code>, <code>LinkedList</code>, <code>VecDeque</code></li>
<li><code>String</code>, <code>CString</code>, <code>format!</code></li>
</ul>
</td>
<td>
<ul>
<li><code>Error</code></li>
<li><code>HashMap</code></li>
<li><code>Mutex</code>, <code>Condvar</code>, <code>Barrier</code>, <code>Once</code>, <code>RwLock</code>, <code>mpsc</code></li>
<li><code>File</code> and the rest of <code>fs</code></li>
<li><code>println!</code>, <code>Read</code>, <code>Write</code>, <code>Stdin</code>, <code>Stdout</code> and the rest of <code>io</code></li>
<li><code>Path</code>, <code>OsString</code></li>
<li><code>net</code></li>
<li><code>Command</code>, <code>Child</code>, <code>ExitCode</code></li>
<li><code>spawn</code>, <code>sleep</code> and the rest of <code>thread</code></li>
<li><code>SystemTime</code>, <code>Instant</code></li>
</ul>
</td>
</tr>
</table>
<details>
<ul>
<li><code>HashMap</code> depends on RNG.</li>
<li><code>std</code> re-exports the contents of both <code>core</code> and <code>alloc</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-minimal-no_std-program"><a class="header" href="#a-minimal-no_std-program">A minimal <code>no_std</code> program</a></h1>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_panic: &amp;PanicInfo) -&gt; ! {
    loop {}
}</code></pre></pre>
<details>
<ul>
<li>This will compile to an empty binary.</li>
<li><code>std</code> provides a panic handler; without it we must provide our own.</li>
<li>It can also be provided by another crate, such as <code>panic-halt</code>.</li>
<li>Depending on the target, you may need to compile with <code>panic = &quot;abort&quot;</code> to avoid an error about
<code>eh_personality</code>.</li>
<li>Note that there is no <code>main</code> or any other entry point; it‚Äôs up to you to define your own entry
point. This will typically involve a linker script and some assembly code to set things up ready
for Rust code to run.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alloc"><a class="header" href="#alloc"><code>alloc</code></a></h1>
<p>To use <code>alloc</code> you must implement a
<a href="https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html">global (heap) allocator</a>.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

extern crate alloc;
extern crate panic_halt as _;

use alloc::string::ToString;
use alloc::vec::Vec;
use buddy_system_allocator::LockedHeap;

#[global_allocator]
static HEAP_ALLOCATOR: LockedHeap&lt;32&gt; = LockedHeap::&lt;32&gt;::new();

static mut HEAP: [u8; 65536] = [0; 65536];

pub fn entry() {
    // Safe because `HEAP` is only used here and `entry` is only called once.
    unsafe {
        // Give the allocator some memory to allocate.
        HEAP_ALLOCATOR
            .lock()
            .init(HEAP.as_mut_ptr() as usize, HEAP.len());
    }

    // Now we can do things that require heap allocation.
    let mut v = Vec::new();
    v.push(&quot;A string&quot;.to_string());
}</code></pre></pre>
<details>
<ul>
<li><code>buddy_system_allocator</code> is a third-party crate implementing a basic buddy system allocator. Other
crates are available, or you can write your own or hook into your existing allocator.</li>
<li>The const parameter of <code>LockedHeap</code> is the max order of the allocator; i.e. in this case it can
allocate regions of up to 2**32 bytes.</li>
<li>If any crate in your dependency tree depends on <code>alloc</code> then you must have exactly one global
allocator defined in your binary. Usually this is done in the top-level binary crate.</li>
<li><code>extern crate panic_halt as _</code> is necessary to ensure that the <code>panic_halt</code> crate is linked in so
we get its panic handler.</li>
<li>This example will build but not run, as it doesn‚Äôt have an entry point.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microcontrollers"><a class="header" href="#microcontrollers">Microcontrollers</a></h1>
<p>The <code>cortex_m_rt</code> crate provides (among other things) a reset handler for Cortex M microcontrollers.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

extern crate panic_halt as _;

mod interrupts;

use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    loop {}
}</code></pre></pre>
<p>Next we‚Äôll look at how to access peripherals, with increasing levels of abstraction.</p>
<details>
<ul>
<li>The <code>cortex_m_rt::entry</code> macro requires that the function have type <code>fn() -&gt; !</code>, because returning
to the reset handler doesn‚Äôt make sense.</li>
<li>Run the example with <code>cargo embed --bin minimal</code></li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raw-mmio"><a class="header" href="#raw-mmio">Raw MMIO</a></h1>
<p>Most microcontrollers access peripherals via memory-mapped IO. Let‚Äôs try turning on an LED on our
micro:bit:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

extern crate panic_halt as _;

mod interrupts;

use core::mem::size_of;
use cortex_m_rt::entry;

/// GPIO port 0 peripheral address
const GPIO_P0: usize = 0x5000_0000;

// GPIO peripheral offsets
const PIN_CNF: usize = 0x700;
const OUTSET: usize = 0x508;
const OUTCLR: usize = 0x50c;

// PIN_CNF fields
const DIR_OUTPUT: u32 = 0x1;
const INPUT_DISCONNECT: u32 = 0x1 &lt;&lt; 1;
const PULL_DISABLED: u32 = 0x0 &lt;&lt; 2;
const DRIVE_S0S1: u32 = 0x0 &lt;&lt; 8;
const SENSE_DISABLED: u32 = 0x0 &lt;&lt; 16;

#[entry]
fn main() -&gt; ! {
    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::&lt;u32&gt;()) as *mut u32;
    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::&lt;u32&gt;()) as *mut u32;
    // Safe because the pointers are to valid peripheral control registers, and
    // no aliases exist.
    unsafe {
        pin_cnf_21.write_volatile(
            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | SENSE_DISABLED,
        );
        pin_cnf_28.write_volatile(
            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | SENSE_DISABLED,
        );
    }

    // Set pin 28 low and pin 21 high to turn the LED on.
    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;
    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;
    // Safe because the pointers are to valid peripheral control registers, and
    // no aliases exist.
    unsafe {
        gpio0_outclr.write_volatile(1 &lt;&lt; 28);
        gpio0_outset.write_volatile(1 &lt;&lt; 21);
    }

    loop {}
}</code></pre></pre>
<details>
<ul>
<li>GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28 to the first row.</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin mmio
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="peripheral-access-crates"><a class="header" href="#peripheral-access-crates">Peripheral Access Crates</a></h1>
<p><a href="https://crates.io/crates/svd2rust"><code>svd2rust</code></a> generates mostly-safe Rust wrappers for
memory-mapped peripherals from <a href="https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html">CMSIS-SVD</a>
files.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use nrf52833_pac::Peripherals;

#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();
    let gpio0 = p.P0;

    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    gpio0.pin_cnf[21].write(|w| {
        w.dir().output();
        w.input().disconnect();
        w.pull().disabled();
        w.drive().s0s1();
        w.sense().disabled();
        w
    });
    gpio0.pin_cnf[28].write(|w| {
        w.dir().output();
        w.input().disconnect();
        w.pull().disabled();
        w.drive().s0s1();
        w.sense().disabled();
        w
    });

    // Set pin 28 low and pin 21 high to turn the LED on.
    gpio0.outclr.write(|w| w.pin28().clear());
    gpio0.outset.write(|w| w.pin21().set());

    loop {}
}</code></pre></pre>
<details>
<ul>
<li>SVD (System View Description) files are XML files typically provided by silicon vendors which
describe the memory map of the device.
<ul>
<li>They are organised by peripheral, register, field and value, with names, descriptions, addresses
and so on.</li>
<li>SVD files are often buggy and incomplete, so there are various projects which patch the
mistakes, add missing details, and publish the generated crates.</li>
</ul>
</li>
<li><code>cortex-m-rt</code> provides the vector table, among other things.</li>
<li>If you <code>cargo install cargo-binutils</code> then you can run
<code>cargo objdump --bin pac -- -d --no-show-raw-insn</code> to see the resulting binary.</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin pac
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hal-crates"><a class="header" href="#hal-crates">HAL crates</a></h1>
<p><a href="https://github.com/rust-embedded/awesome-embedded-rust#hal-implementation-crates">HAL crates</a> for
many microcontrollers provide wrappers around various peripherals. These generally implement traits
from <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a>.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use nrf52833_hal::gpio::{p0, Level};
use nrf52833_hal::pac::Peripherals;
use nrf52833_hal::prelude::*;

#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();

    // Create HAL wrapper for GPIO port 0.
    let gpio0 = p0::Parts::new(p.P0);

    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);
    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);

    // Set pin 28 low and pin 21 high to turn the LED on.
    col1.set_low().unwrap();
    row1.set_high().unwrap();

    loop {}
}</code></pre></pre>
<details>
<ul>
<li><code>set_low</code> and <code>set_high</code> are methods on the <code>embedded_hal</code> <code>OutputPin</code> trait.</li>
<li>HAL crates exist for many Cortex-M and RISC-V devices, including various STM32, GD32, nRF, NXP,
MSP430, AVR and PIC microcontrollers.</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin hal
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="board-support-crates"><a class="header" href="#board-support-crates">Board support crates</a></h1>
<p>Board support crates provide a further level of wrapping for a specific board for convenience.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use microbit::hal::prelude::*;
use microbit::Board;

#[entry]
fn main() -&gt; ! {
    let mut board = Board::take().unwrap();

    board.display_pins.col1.set_low().unwrap();
    board.display_pins.row1.set_high().unwrap();

    loop {}
}</code></pre></pre>
<details>
<ul>
<li>In this case the board support crate is just providing more useful names, and a bit of
initialisation.</li>
<li>The crate may also include drivers for some on-board devices outside of the microcontroller
itself.
<ul>
<li><code>microbit-v2</code> includes a simple driver for the LED matrix.</li>
</ul>
</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin board_support
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-type-state-pattern"><a class="header" href="#the-type-state-pattern">The type state pattern</a></h1>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();
    let gpio0 = p0::Parts::new(p.P0);

    let pin: P0_01&lt;Disconnected&gt; = gpio0.p0_01;

    // let gpio0_01_again = gpio0.p0_01; // Error, moved.
    let pin_input: P0_01&lt;Input&lt;Floating&gt;&gt; = pin.into_floating_input();
    if pin_input.is_high().unwrap() {
        // ...
    }
    let mut pin_output: P0_01&lt;Output&lt;OpenDrain&gt;&gt; = pin_input
        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);
    pin_output.set_high().unwrap();
    // pin_input.is_high(); // Error, moved.

    let _pin2: P0_02&lt;Output&lt;OpenDrain&gt;&gt; = gpio0
        .p0_02
        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);
    let _pin3: P0_03&lt;Output&lt;PushPull&gt;&gt; = gpio0.p0_03.into_push_pull_output(Level::Low);

    loop {}
}</code></pre></pre>
<details>
<ul>
<li>Pins don‚Äôt implement <code>Copy</code> or <code>Clone</code>, so only one instance of each can exist. Once a pin is
moved out of the port struct nobody else can take it.</li>
<li>Changing the configuration of a pin consumes the old pin instance, so you can‚Äôt keep use the old
instance afterwards.</li>
<li>The type of a value indicates the state that it is in: e.g. in this case, the configuration state
of a GPIO pin. This encodes the state machine into the type system, and ensures that you don‚Äôt
try to use a pin in a certain way without properly configuring it first. Illegal state
transitions are caught at compile time.</li>
<li>You can call <code>is_high</code> on an input pin and <code>set_high</code> on an output pin, but not vice-versa.</li>
<li>Many HAL crates follow this pattern.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-hal"><a class="header" href="#embedded-hal"><code>embedded-hal</code></a></h1>
<p>The <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a> crate provides a number of traits
covering common microcontroller peripherals.</p>
<ul>
<li>GPIO</li>
<li>ADC</li>
<li>I2C, SPI, UART, CAN</li>
<li>RNG</li>
<li>Timers</li>
<li>Watchdogs</li>
</ul>
<p>Other crates then implement
<a href="https://github.com/rust-embedded/awesome-embedded-rust#driver-crates">drivers</a> in terms of these
traits, e.g. an accelerometer driver might need an I2C or SPI bus implementation.</p>
<details>
<ul>
<li>There are implementations for many microcontrollers, as well as other platforms such as Linux on
Raspberry Pi.</li>
<li>There is work in progress on an <code>async</code> version of <code>embedded-hal</code>, but it isn‚Äôt stable yet.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="probe-rs-cargo-embed"><a class="header" href="#probe-rs-cargo-embed"><code>probe-rs</code>, <code>cargo-embed</code></a></h1>
<p><a href="https://probe.rs/">probe-rs</a> is a handy toolset for embedded debugging, like OpenOCD but better
integrated.</p>
<ul>
<li><abbr title="Serial Wire Debug">SWD</abbr> and JTAG via CMSIS-DAP, ST-Link and J-Link probes</li>
<li>GDB stub and Microsoft <abbr title="Debug Adapter Protocol">DAP</abbr> server</li>
<li>Cargo integration</li>
</ul>
<p><code>cargo-embed</code> is a cargo subcommand to build and flash binaries, log
<abbr title="Real Time Transfers">RTT</abbr> output and connect GDB. It‚Äôs configured by an
<code>Embed.toml</code> file in your project directory.</p>
<details>
<ul>
<li><a href="https://arm-software.github.io/CMSIS_5/DAP/html/index.html">CMSIS-DAP</a> is an Arm standard
protocol over USB for an in-circuit debugger to access the CoreSight Debug Access Port of various
Arm Cortex processors. It‚Äôs what the on-board debugger on the BBC micro:bit uses.</li>
<li>ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link is a range from
SEGGER.</li>
<li>The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin Serial Wire Debug.</li>
<li>probe-rs is a library which you can integrate into your own tools if you want to.</li>
<li>The <a href="https://microsoft.github.io/debug-adapter-protocol/">Microsoft Debug Adapter Protocol</a> lets
VSCode and other IDEs debug code running on any supported microcontroller.</li>
<li>cargo-embed is a binary built using the probe-rs library.</li>
<li>RTT (Real Time Transfers) is a mechanism to transfer data between the debug host and the target
through a number of ringbuffers.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>Embed.toml:</p>
<pre><code class="language-toml">[default.general]
chip = &quot;nrf52833_xxAA&quot;

[debug.gdb]
enabled = true
</code></pre>
<p>In one terminal under <code>src/bare-metal/microcontrollers/examples/</code>:</p>
<pre><code class="language-sh">cargo embed --bin board_support debug
</code></pre>
<p>In another terminal in the same directory:</p>
<pre><code class="language-sh">gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-command=&quot;target remote :1337&quot;
</code></pre>
<details>
<p>In GDB, try running:</p>
<pre><code class="language-gdb">b src/bin/board_support.rs:29
b src/bin/board_support.rs:30
b src/bin/board_support.rs:32
c
c
c
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-projects"><a class="header" href="#other-projects">Other projects</a></h1>
<ul>
<li><a href="https://rtic.rs/">RTIC</a>
<ul>
<li>‚ÄúReal-Time Interrupt-driven Concurrency‚Äù</li>
<li>Shared resource management, message passing, task scheduling, timer queue</li>
</ul>
</li>
<li><a href="https://embassy.dev/">Embassy</a>
<ul>
<li><code>async</code> executors with priorities, timers, networking, USB</li>
</ul>
</li>
<li><a href="https://www.tockos.org/documentation/getting-started">TockOS</a>
<ul>
<li>Security-focused RTOS with preemptive scheduling and Memory Protection Unit support</li>
</ul>
</li>
<li><a href="https://hubris.oxide.computer/">Hubris</a>
<ul>
<li>Microkernel RTOS from Oxide Computer Company with memory protection, unprivileged drivers, IPC</li>
</ul>
</li>
<li><a href="https://github.com/lobaro/FreeRTOS-rust">Bindings for FreeRTOS</a></li>
<li>Some platforms have <code>std</code> implementations, e.g.
<a href="https://esp-rs.github.io/book/overview/using-the-standard-library.html">esp-idf</a>.</li>
</ul>
<details>
<ul>
<li>RTIC can be considered either an RTOS or a concurrency framework.
<ul>
<li>It doesn‚Äôt include any HALs.</li>
<li>It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for scheduling rather than a
proper kernel.</li>
<li>Cortex-M only.</li>
</ul>
</li>
<li>Google uses TockOS on the Haven microcontroller for Titan security keys.</li>
<li>FreeRTOS is mostly written in C, but there are Rust bindings for writing applications.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h1>
<p>We will read the direction from an I2C compass, and log the readings to a serial port.</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/bare-metal/solutions-morning.html">solutions</a> provided.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compass"><a class="header" href="#compass">Compass</a></h1>
<p>We will read the direction from an I2C compass, and log the readings to a serial port. If you have
time, try displaying it on the LEDs somehow too, or use the buttons somehow.</p>
<p>Hints:</p>
<ul>
<li>Check the documentation for the <a href="https://docs.rs/lsm303agr/latest/lsm303agr/"><code>lsm303agr</code></a> and
<a href="https://docs.rs/microbit-v2/latest/microbit/"><code>microbit-v2</code></a> crates, as well as the
<a href="https://tech.microbit.org/hardware/">micro:bit hardware</a>.</li>
<li>The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus.</li>
<li>TWI is another name for I2C, so the I2C master peripheral is called TWIM.</li>
<li>The LSM303AGR driver needs something implementing the <code>embedded_hal::blocking::i2c::WriteRead</code>
trait. The
<a href="https://docs.rs/microbit-v2/latest/microbit/hal/struct.Twim.html"><code>microbit::hal::Twim</code></a> struct
implements this.</li>
<li>You have a <a href="https://docs.rs/microbit-v2/latest/microbit/struct.Board.html"><code>microbit::Board</code></a>
struct with fields for the various pins and peripherals.</li>
<li>You can also look at the
<a href="https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.5.pdf">nRF52833 datasheet</a> if you want, but
it shouldn‚Äôt be necessary for this exercise.</li>
</ul>
<p>Download the <a href="comprehensive-rust-exercises.zip">exercise template</a> and look in the <code>compass</code>
directory for the following files.</p>
<p><code>src/main.rs</code>:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">#![no_main]
#![no_std]

extern crate panic_halt as _;

use core::fmt::Write;
use cortex_m_rt::entry;
use microbit::{hal::uarte::{Baudrate, Parity, Uarte}, Board};

#[entry]
fn main() -&gt; ! {
    let board = Board::take().unwrap();

    // Configure serial port.
    let mut serial = Uarte::new(
        board.UARTE0,
        board.uart.into(),
        Parity::EXCLUDED,
        Baudrate::BAUD115200,
    );

    // Set up the I2C controller and Inertial Measurement Unit.
    // TODO

    writeln!(serial, &quot;Ready.&quot;).unwrap();

    loop {
        // Read compass data and log it to the serial port.
        // TODO
    }
}</code></pre></pre>
<p><code>Cargo.toml</code> (you shouldn‚Äôt need to change this):</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[workspace]

[package]
name = &quot;compass&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
cortex-m-rt = &quot;0.7.3&quot;
embedded-hal = &quot;0.2.6&quot;
lsm303agr = &quot;0.2.2&quot;
microbit-v2 = &quot;0.13.0&quot;
panic-halt = &quot;0.2.0&quot;
</code></pre>
<p><code>Embed.toml</code> (you shouldn‚Äôt need to change this):</p>
<!-- File Embed.toml -->
<pre><code class="language-toml">[default.general]
chip = &quot;nrf52833_xxAA&quot;

[debug.gdb]
enabled = true

[debug.reset]
halt_afterwards = true
</code></pre>
<p><code>.cargo/config.toml</code> (you shouldn‚Äôt need to change this):</p>
<!-- File .cargo/config.toml -->
<pre><code class="language-toml">[build]
target = &quot;thumbv7em-none-eabihf&quot; # Cortex-M4F

[target.'cfg(all(target_arch = &quot;arm&quot;, target_os = &quot;none&quot;))']
rustflags = [&quot;-C&quot;, &quot;link-arg=-Tlink.x&quot;]
</code></pre>
<p>See the serial output on Linux with:</p>
<pre><code class="language-sh">picocom --baud 115200 --imap lfcrlf /dev/ttyACM0
</code></pre>
<p>Or on Mac OS something like (the device name may be slightly different):</p>
<pre><code class="language-sh">picocom --baud 115200 --imap lfcrlf /dev/tty.usbmodem14502
</code></pre>
<p>Use Ctrl+A Ctrl+Q to quit picocom.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-processors"><a class="header" href="#application-processors">Application processors</a></h1>
<p>So far we‚Äôve talked about microcontrollers, such as the Arm Cortex-M series. Now let‚Äôs try writing
something for Cortex-A. For simplicity we‚Äôll just work with QEMU‚Äôs aarch64
<a href="https://qemu-project.gitlab.io/qemu/system/arm/virt.html">‚Äòvirt‚Äô</a> board.</p>
<details>
<ul>
<li>Broadly speaking, microcontrollers don‚Äôt have an MMU or multiple levels of privilege (exception
levels on Arm CPUs, rings on x86), while application processors do.</li>
<li>QEMU supports emulating various different machines or board models for each architecture. The
‚Äòvirt‚Äô board doesn‚Äôt correspond to any particular real hardware, but is designed purely for
virtual machines.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-ready-to-rust"><a class="header" href="#getting-ready-to-rust">Getting Ready to Rust</a></h1>
<p>Before we can start running Rust code, we need to do some initialisation.</p>
<pre><code class="language-armasm">.section .init.entry, &quot;ax&quot;
.global entry
entry:
    /*
     * Load and apply the memory management configuration, ready to enable MMU and
     * caches.
     */
    adrp x30, idmap
    msr ttbr0_el1, x30

    mov_i x30, .Lmairval
    msr mair_el1, x30

    mov_i x30, .Ltcrval
    /* Copy the supported PA range into TCR_EL1.IPS. */
    mrs x29, id_aa64mmfr0_el1
    bfi x30, x29, #32, #4

    msr tcr_el1, x30

    mov_i x30, .Lsctlrval

    /*
     * Ensure everything before this point has completed, then invalidate any
     * potentially stale local TLB entries before they start being used.
     */
    isb
    tlbi vmalle1
    ic iallu
    dsb nsh
    isb

    /*
     * Configure sctlr_el1 to enable MMU and cache and don't proceed until this
     * has completed.
     */
    msr sctlr_el1, x30
    isb

    /* Disable trapping floating point access in EL1. */
    mrs x30, cpacr_el1
    orr x30, x30, #(0x3 &lt;&lt; 20)
    msr cpacr_el1, x30
    isb

    /* Zero out the bss section. */
    adr_l x29, bss_begin
    adr_l x30, bss_end
0:  cmp x29, x30
    b.hs 1f
    stp xzr, xzr, [x29], #16
    b 0b

1:  /* Prepare the stack. */
    adr_l x30, boot_stack_end
    mov sp, x30

    /* Set up exception vector. */
    adr x30, vector_table_el1
    msr vbar_el1, x30

    /* Call into Rust code. */
    bl main

    /* Loop forever waiting for interrupts. */
2:  wfi
    b 2b
</code></pre>
<details>
<ul>
<li>This is the same as it would be for C: initialising the processor state, zeroing the BSS, and
setting up the stack pointer.
<ul>
<li>The BSS (block starting symbol, for historical reasons) is the part of the object file which
containing statically allocated variables which are initialised to zero. They are omitted from
the image, to avoid wasting space on zeroes. The compiler assumes that the loader will take care
of zeroing them.</li>
</ul>
</li>
<li>The BSS may already be zeroed, depending on how memory is initialised and the image is loaded, but
we zero it to be sure.</li>
<li>We need to enable the MMU and cache before reading or writing any memory. If we don‚Äôt:
<ul>
<li>Unaligned accesses will fault. We build the Rust code for the <code>aarch64-unknown-none</code> target
which sets <code>+strict-align</code> to prevent the compiler generating unaligned accesses, so it should
be fine in this case, but this is not necessarily the case in general.</li>
<li>If it were running in a VM, this can lead to cache coherency issues. The problem is that the VM
is accessing memory directly with the cache disabled, while the host has cachable aliases to the
same memory. Even if the host doesn‚Äôt explicitly access the memory, speculative accesses can
lead to cache fills, and then changes from one or the other will get lost when the cache is
cleaned or the VM enables the cache. (Cache is keyed by physical address, not VA or IPA.)</li>
</ul>
</li>
<li>For simplicity, we just use a hardcoded pagetable (see <code>idmap.S</code>) which identity maps the first 1
GiB of address space for devices, the next 1 GiB for DRAM, and another 1 GiB higher up for more
devices. This matches the memory layout that QEMU uses.</li>
<li>We also set up the exception vector (<code>vbar_el1</code>), which we‚Äôll see more about later.</li>
<li>All examples this afternoon assume we will be running at exception level 1 (EL1). If you need to
run at a different exception level you‚Äôll need to modify <code>entry.S</code> accordingly.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-assembly"><a class="header" href="#inline-assembly">Inline assembly</a></h1>
<p>Sometimes we need to use assembly to do things that aren‚Äôt possible with Rust code. For example,
to make an <abbr title="hypervisor call">HVC</abbr> to tell the firmware to power off the system:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

use core::arch::asm;
use core::panic::PanicInfo;

mod exceptions;

const PSCI_SYSTEM_OFF: u32 = 0x84000008;

#[no_mangle]
extern &quot;C&quot; fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {
    // Safe because this only uses the declared registers and doesn't do
    // anything with memory.
    unsafe {
        asm!(&quot;hvc #0&quot;,
            inout(&quot;w0&quot;) PSCI_SYSTEM_OFF =&gt; _,
            inout(&quot;w1&quot;) 0 =&gt; _,
            inout(&quot;w2&quot;) 0 =&gt; _,
            inout(&quot;w3&quot;) 0 =&gt; _,
            inout(&quot;w4&quot;) 0 =&gt; _,
            inout(&quot;w5&quot;) 0 =&gt; _,
            inout(&quot;w6&quot;) 0 =&gt; _,
            inout(&quot;w7&quot;) 0 =&gt; _,
            options(nomem, nostack)
        );
    }

    loop {}
}</code></pre></pre>
<p>(If you actually want to do this, use the <a href="https://crates.io/crates/smccc"><code>smccc</code></a> crate which has wrappers for all these functions.)</p>
<details>
<ul>
<li>PSCI is the Arm Power State Coordination Interface, a standard set of functions to manage system
and CPU power states, among other things. It is implemented by EL3 firmware and hypervisors on
many systems.</li>
<li>The <code>0 =&gt; _</code> syntax means initialise the register to 0 before running the inline assembly code,
and ignore its contents afterwards. We need to use <code>inout</code> rather than <code>in</code> because the call could
potentially clobber the contents of the registers.</li>
<li>This <code>main</code> function needs to be <code>#[no_mangle]</code> and <code>extern &quot;C&quot;</code> because it is called from our
entry point in <code>entry.S</code>.</li>
<li><code>_x0</code>‚Äì<code>_x3</code> are the values of registers <code>x0</code>‚Äì<code>x3</code>, which are conventionally used by the bootloader
to pass things like a pointer to the device tree. According to the standard aarch64 calling
convention (which is what <code>extern &quot;C&quot;</code> specifies to use), registers <code>x0</code>‚Äì<code>x7</code> are used for the
first 8 arguments passed to a function, so <code>entry.S</code> doesn‚Äôt need to do anything special except
make sure it doesn‚Äôt change these registers.</li>
<li>Run the example in QEMU with <code>make qemu_psci</code> under <code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="volatile-memory-access-for-mmio"><a class="header" href="#volatile-memory-access-for-mmio">Volatile memory access for MMIO</a></h1>
<ul>
<li>Use <code>pointer::read_volatile</code> and <code>pointer::write_volatile</code>.</li>
<li>Never hold a reference.</li>
<li><code>addr_of!</code> lets you get fields of structs without creating an intermediate reference.</li>
</ul>
<details>
<ul>
<li>Volatile access: read or write operations may have side-effects, so prevent the compiler or
hardware from reordering, duplicating or eliding them.
<ul>
<li>Usually if you write and then read, e.g. via a mutable reference, the compiler may assume that
the value read is the same as the value just written, and not bother actually reading memory.</li>
</ul>
</li>
<li>Some existing crates for volatile access to hardware do hold references, but this is unsound.
Whenever a reference exist, the compiler may choose to dereference it.</li>
<li>Use the <code>addr_of!</code> macro to get struct field pointers from a pointer to the struct.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lets-write-a-uart-driver"><a class="header" href="#lets-write-a-uart-driver">Let‚Äôs write a UART driver</a></h1>
<p>The QEMU ‚Äòvirt‚Äô machine has a <a href="https://developer.arm.com/documentation/ddi0183/g">PL011</a> UART, so let‚Äôs write a driver for that.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">const FLAG_REGISTER_OFFSET: usize = 0x18;
const FR_BUSY: u8 = 1 &lt;&lt; 3;
const FR_TXFF: u8 = 1 &lt;&lt; 5;

/// Minimal driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    base_address: *mut u8,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the 8 MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u8) -&gt; Self {
        Self { base_address }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register() &amp; FR_TXFF != 0 {}

        // Safe because we know that the base address points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            self.base_address.write_volatile(byte);
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register() &amp; FR_BUSY != 0 {}
    }

    fn read_flag_register(&amp;self) -&gt; u8 {
        // Safe because we know that the base address points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET).read_volatile() }
    }
}</code></pre></pre>
<details>
<ul>
<li>Note that <code>Uart::new</code> is unsafe while the other methods are safe. This is because as long as the
caller of <code>Uart::new</code> guarantees that its safety requirements are met (i.e. that there is only
ever one instance of the driver for a given UART, and nothing else aliasing its address space),
then it is always safe to call <code>write_byte</code> later because we can assume the necessary
preconditions.</li>
<li>We could have done it the other way around (making <code>new</code> safe but <code>write_byte</code> unsafe), but that
would be much less convenient to use as every place that calls <code>write_byte</code> would need to reason
about the safety</li>
<li>This is a common pattern for writing safe wrappers of unsafe code: moving the burden of proof for
soundness from a large number of places to a smaller number of places.</li>
</ul>
</detais>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-traits"><a class="header" href="#more-traits">More traits</a></h1>
<p>We derived the <code>Debug</code> trait. It would be useful to implement a few more traits too.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use core::fmt::{self, Write};

impl Write for Uart {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        for c in s.as_bytes() {
            self.write_byte(*c);
        }
        Ok(())
    }
}

// Safe because it just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Uart {}</code></pre></pre>
<details>
<ul>
<li>Implementing <code>Write</code> lets us use the <code>write!</code> and <code>writeln!</code> macros with our <code>Uart</code> type.</li>
<li>Run the example in QEMU with <code>make qemu_minimal</code> under <code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-better-uart-driver"><a class="header" href="#a-better-uart-driver">A better UART driver</a></h1>
<p>The PL011 actually has <a href="https://developer.arm.com/documentation/ddi0183/g/programmers-model/summary-of-registers">a bunch more registers</a>, and adding offsets to construct pointers to access
them is error-prone and hard to read. Plus, some of them are bit fields which would be nice to
access in a structured way.</p>
<div class="table-wrapper"><table><thead><tr><th>Offset</th><th>Register name</th><th>Width</th></tr></thead><tbody>
<tr><td>0x00</td><td>DR</td><td>12</td></tr>
<tr><td>0x04</td><td>RSR</td><td>4</td></tr>
<tr><td>0x18</td><td>FR</td><td>9</td></tr>
<tr><td>0x20</td><td>ILPR</td><td>8</td></tr>
<tr><td>0x24</td><td>IBRD</td><td>16</td></tr>
<tr><td>0x28</td><td>FBRD</td><td>6</td></tr>
<tr><td>0x2c</td><td>LCR_H</td><td>8</td></tr>
<tr><td>0x30</td><td>CR</td><td>16</td></tr>
<tr><td>0x34</td><td>IFLS</td><td>6</td></tr>
<tr><td>0x38</td><td>IMSC</td><td>11</td></tr>
<tr><td>0x3c</td><td>RIS</td><td>11</td></tr>
<tr><td>0x40</td><td>MIS</td><td>11</td></tr>
<tr><td>0x44</td><td>ICR</td><td>11</td></tr>
<tr><td>0x48</td><td>DMACR</td><td>3</td></tr>
</tbody></table>
</div><details>
<ul>
<li>There are also some ID registers which have been omitted for brevity.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitflags"><a class="header" href="#bitflags">Bitflags</a></h1>
<p>The <a href="https://crates.io/crates/bitflags"><code>bitflags</code></a> crate is useful for working with bitflags.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use bitflags::bitflags;

bitflags! {
    /// Flags from the UART flag register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct Flags: u16 {
        /// Clear to send.
        const CTS = 1 &lt;&lt; 0;
        /// Data set ready.
        const DSR = 1 &lt;&lt; 1;
        /// Data carrier detect.
        const DCD = 1 &lt;&lt; 2;
        /// UART busy transmitting data.
        const BUSY = 1 &lt;&lt; 3;
        /// Receive FIFO is empty.
        const RXFE = 1 &lt;&lt; 4;
        /// Transmit FIFO is full.
        const TXFF = 1 &lt;&lt; 5;
        /// Receive FIFO is full.
        const RXFF = 1 &lt;&lt; 6;
        /// Transmit FIFO is empty.
        const TXFE = 1 &lt;&lt; 7;
        /// Ring indicator.
        const RI = 1 &lt;&lt; 8;
    }
}</code></pre></pre>
<details>
<ul>
<li>The <code>bitflags!</code> macro creates a newtype something like <code>Flags(u16)</code>, along with a bunch of method
implementations to get and set flags.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-registers"><a class="header" href="#multiple-registers">Multiple registers</a></h1>
<p>We can use a struct to represent the memory layout of the UART‚Äôs registers.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#[repr(C, align(4))]
struct Registers {
    dr: u16,
    _reserved0: [u8; 2],
    rsr: ReceiveStatus,
    _reserved1: [u8; 19],
    fr: Flags,
    _reserved2: [u8; 6],
    ilpr: u8,
    _reserved3: [u8; 3],
    ibrd: u16,
    _reserved4: [u8; 2],
    fbrd: u8,
    _reserved5: [u8; 3],
    lcr_h: u8,
    _reserved6: [u8; 3],
    cr: u16,
    _reserved7: [u8; 3],
    ifls: u8,
    _reserved8: [u8; 3],
    imsc: u16,
    _reserved9: [u8; 2],
    ris: u16,
    _reserved10: [u8; 2],
    mis: u16,
    _reserved11: [u8; 2],
    icr: u16,
    _reserved12: [u8; 2],
    dmacr: u8,
    _reserved13: [u8; 3],
}</code></pre></pre>
<details>
<ul>
<li><a href="https://doc.rust-lang.org/reference/type-layout.html#the-c-representation"><code>#[repr(C)]</code></a> tells
the compiler to lay the struct fields out in order, following the same rules as C. This is
necessary for our struct to have a predictable layout, as default Rust representation allows the
compiler to (among other things) reorder fields however it sees fit.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="driver"><a class="header" href="#driver">Driver</a></h1>
<p>Now let‚Äôs use the new <code>Registers</code> struct in our driver.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">/// Driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    registers: *mut Registers,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the 8 MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self {
            registers: base_address as *mut Registers,
        }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register().contains(Flags::TXFF) {}

        // Safe because we know that self.registers points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register().contains(Flags::BUSY) {}
    }

    /// Reads and returns a pending byte, or `None` if nothing has been received.
    pub fn read_byte(&amp;self) -&gt; Option&lt;u8&gt; {
        if self.read_flag_register().contains(Flags::RXFE) {
            None
        } else {
            let data = unsafe { addr_of!((*self.registers).dr).read_volatile() };
            // TODO: Check for error conditions in bits 8-11.
            Some(data as u8)
        }
    }

    fn read_flag_register(&amp;self) -&gt; Flags {
        // Safe because we know that self.registers points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe { addr_of!((*self.registers).fr).read_volatile() }
    }
}</code></pre></pre>
<details>
<ul>
<li>Note the use of <code>addr_of!</code> / <code>addr_of_mut!</code> to get pointers to individual fields without creating
an intermediate reference, which would be unsound.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-it"><a class="header" href="#using-it">Using it</a></h1>
<p>Let‚Äôs write a small program using our driver to write to the serial console, and echo incoming
bytes.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

mod exceptions;
mod pl011;

use crate::pl011::Uart;
use core::fmt::Write;
use core::panic::PanicInfo;
use log::error;
use smccc::psci::system_off;
use smccc::Hvc;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

#[no_mangle]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,
    // and nothing else accesses that address range.
    let mut uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };

    writeln!(uart, &quot;main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})&quot;).unwrap();

    loop {
        if let Some(byte) = uart.read_byte() {
            uart.write_byte(byte);
            match byte {
                b'\r' =&gt; {
                    uart.write_byte(b'\n');
                }
                b'q' =&gt; break,
                _ =&gt; {}
            }
        }
    }

    writeln!(uart, &quot;Bye!&quot;).unwrap();
    system_off::&lt;Hvc&gt;().unwrap();
}</code></pre></pre>
<details>
<ul>
<li>As in the <a href="bare-metal/aps/inline-assembly.html">inline assembly</a> example, this <code>main</code> function is called from our
entry point code in <code>entry.S</code>. See the speaker notes there for details.</li>
<li>Run the example in QEMU with <code>make qemu</code> under <code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging-1"><a class="header" href="#logging-1">Logging</a></h1>
<p>It would be nice to be able to use the logging macros from the <a href="https://crates.io/crates/log"><code>log</code></a> crate. We can do this by
implementing the <code>Log</code> trait.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use crate::pl011::Uart;
use core::fmt::Write;
use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};
use spin::mutex::SpinMutex;

static LOGGER: Logger = Logger {
    uart: SpinMutex::new(None),
};

struct Logger {
    uart: SpinMutex&lt;Option&lt;Uart&gt;&gt;,
}

impl Log for Logger {
    fn enabled(&amp;self, _metadata: &amp;Metadata) -&gt; bool {
        true
    }

    fn log(&amp;self, record: &amp;Record) {
        writeln!(
            self.uart.lock().as_mut().unwrap(),
            &quot;[{}] {}&quot;,
            record.level(),
            record.args()
        )
        .unwrap();
    }

    fn flush(&amp;self) {}
}

/// Initialises UART logger.
pub fn init(uart: Uart, max_level: LevelFilter) -&gt; Result&lt;(), SetLoggerError&gt; {
    LOGGER.uart.lock().replace(uart);

    log::set_logger(&amp;LOGGER)?;
    log::set_max_level(max_level);
    Ok(())
}</code></pre></pre>
<details>
<ul>
<li>The unwrap in <code>log</code> is safe because we initialise <code>LOGGER</code> before calling <code>set_logger</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-it-1"><a class="header" href="#using-it-1">Using it</a></h1>
<p>We need to initialise the logger before we use it.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;

use crate::pl011::Uart;
use core::panic::PanicInfo;
use log::{error, info, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

#[no_mangle]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,
    // and nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!(&quot;main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})&quot;);

    assert_eq!(x1, 42);

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!(&quot;{info}&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}</code></pre></pre>
<details>
<ul>
<li>Note that our panic handler can now log details of panics.</li>
<li>Run the example in QEMU with <code>make qemu_logger</code> under <code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h1>
<p>AArch64 defines an exception vector table with 16 entries, for 4 types of exceptions (synchronous,
IRQ, FIQ, SError) from 4 states (current EL with SP0, current EL with SPx, lower EL using AArch64,
lower EL using AArch32). We implement this in assembly to save volatile registers to the stack
before calling into Rust code:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use log::error;
use smccc::psci::system_off;
use smccc::Hvc;

#[no_mangle]
extern &quot;C&quot; fn sync_exception_current(_elr: u64, _spsr: u64) {
    error!(&quot;sync_exception_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn irq_current(_elr: u64, _spsr: u64) {
    error!(&quot;irq_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn fiq_current(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn serr_current(_elr: u64, _spsr: u64) {
    error!(&quot;serr_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn sync_lower(_elr: u64, _spsr: u64) {
    error!(&quot;sync_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn irq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;irq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn fiq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn serr_lower(_elr: u64, _spsr: u64) {
    error!(&quot;serr_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}</code></pre></pre>
<details>
<ul>
<li>EL is exception level; all our examples this afternoon run in EL1.</li>
<li>For simplicity we aren‚Äôt distinguishing between SP0 and SPx for the current EL exceptions, or
between AArch32 and AArch64 for the lower EL exceptions.</li>
<li>For this example we just log the exception and power down, as we don‚Äôt expect any of them to
actually happen.</li>
<li>We can think of exception handlers and our main execution context more or less like different
threads. <a href="concurrency/send-sync.html"><code>Send</code> and <code>Sync</code></a> will control what we can share between them, just like with threads.
For example, if we want to share some value between exception handlers and the rest of the
program, and it‚Äôs <code>Send</code> but not <code>Sync</code>, then we‚Äôll need to wrap it in something like a <code>Mutex</code>
and put it in a static.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-projects-1"><a class="header" href="#other-projects-1">Other projects</a></h1>
<ul>
<li><a href="https://github.com/oreboot/oreboot">oreboot</a>
<ul>
<li>‚Äúcoreboot without the C‚Äù</li>
<li>Supports x86, aarch64 and RISC-V.</li>
<li>Relies on LinuxBoot rather than having many drivers itself.</li>
</ul>
</li>
<li><a href="https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials">Rust RaspberryPi OS tutorial</a>
<ul>
<li>Initialisation, UART driver, simple bootloader, JTAG, exception levels, exception handling,
page tables</li>
<li>Some dodginess around cache maintenance and initialisation in Rust, not necessarily a good
example to copy for production code.</li>
</ul>
</li>
<li><a href="https://crates.io/crates/cargo-call-stack"><code>cargo-call-stack</code></a>
<ul>
<li>Static analysis to determine maximum stack usage.</li>
</ul>
</li>
</ul>
<details>
<ul>
<li>The RaspberryPi OS tutorial runs Rust code before the MMU and caches are enabled. This will read
and write memory (e.g. the stack). However:
<ul>
<li>Without the MMU and cache, unaligned accesses will fault. It builds with <code>aarch64-unknown-none</code>
which sets <code>+strict-align</code> to prevent the compiler generating unaligned accesses so it should be
alright, but this is not necessarily the case in general.</li>
<li>If it were running in a VM, this can lead to cache coherency issues. The problem is that the VM
is accessing memory directly with the cache disabled, while the host has cachable aliases to the
same memory. Even if the host doesn‚Äôt explicitly access the memory, speculative accesses can
lead to cache fills, and then changes from one or the other will get lost. Again this is alright
in this particular case (running directly on the hardware with no hypervisor), but isn‚Äôt a good
pattern in general.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useful-crates"><a class="header" href="#useful-crates">Useful crates</a></h1>
<p>We‚Äôll go over a few crates which solve some common problems in bare-metal programming.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zerocopy"><a class="header" href="#zerocopy"><code>zerocopy</code></a></h1>
<p>The <a href="https://docs.rs/zerocopy/"><code>zerocopy</code></a> crate (from Fuchsia) provides traits and macros for safely converting between
byte sequences and other types.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use zerocopy::AsBytes;

#[repr(u32)]
#[derive(AsBytes, Debug, Default)]
enum RequestType {
    #[default]
    In = 0,
    Out = 1,
    Flush = 4,
}

#[repr(C)]
#[derive(AsBytes, Debug, Default)]
struct VirtioBlockRequest {
    request_type: RequestType,
    reserved: u32,
    sector: u64,
}

fn main() {
    let request = VirtioBlockRequest {
        request_type: RequestType::Flush,
        sector: 42,
        ..Default::default()
    };

    assert_eq!(
        request.as_bytes(),
        &amp;[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]
    );
}</code></pre></pre>
<p>This is not suitable for MMIO (as it doesn‚Äôt use volatile reads and writes), but can be useful for
working with structures shared with hardware e.g. by DMA, or sent over some external interface.</p>
<details>
<ul>
<li><code>FromBytes</code> can be implemented for types for which any byte pattern is valid, and so can safely be
converted from an untrusted sequence of bytes.</li>
<li>Attempting to derive <code>FromBytes</code> for these types would fail, because <code>RequestType</code> doesn‚Äôt use all
possible u32 values as discriminants, so not all byte patterns are valid.</li>
<li><code>zerocopy::byteorder</code> has types for byte-order aware numeric primitives.</li>
<li>Run the example with <code>cargo run</code> under <code>src/bare-metal/useful-crates/zerocopy-example/</code>. (It won‚Äôt
run in the Playground because of the crate dependency.)</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aarch64-paging"><a class="header" href="#aarch64-paging"><code>aarch64-paging</code></a></h1>
<p>The <a href="https://crates.io/crates/aarch64-paging"><code>aarch64-paging</code></a> crate lets you create page tables according to the AArch64 Virtual Memory
System Architecture.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use aarch64_paging::{
    idmap::IdMap,
    paging::{Attributes, MemoryRegion},
};

const ASID: usize = 1;
const ROOT_LEVEL: usize = 1;

// Create a new page table with identity mapping.
let mut idmap = IdMap::new(ASID, ROOT_LEVEL);
// Map a 2 MiB region of memory as read-only.
idmap.map_range(
    &amp;MemoryRegion::new(0x80200000, 0x80400000),
    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,
).unwrap();
// Set `TTBR0_EL1` to activate the page table.
idmap.activate();</code></pre></pre>
<details>
<ul>
<li>For now it only supports EL1, but support for other exception levels should be straightforward to
add.</li>
<li>This is used in Android for the <a href="https://cs.android.com/android/platform/superproject/+/master:packages/modules/Virtualization/pvmfw/">Protected VM Firmware</a>.</li>
<li>There‚Äôs no easy way to run this example, as it needs to run on real hardware or under QEMU.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buddy_system_allocator"><a class="header" href="#buddy_system_allocator"><code>buddy_system_allocator</code></a></h1>
<p><a href="https://crates.io/crates/buddy_system_allocator"><code>buddy_system_allocator</code></a> is a third-party crate implementing a basic buddy system allocator.
It can be used both for <a href="https://docs.rs/buddy_system_allocator/0.9.0/buddy_system_allocator/struct.LockedHeap.html"><code>LockedHeap</code></a> implementing <a href="https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a> so you can use the
standard <code>alloc</code> crate (as we saw <a href="bare-metal/alloc.html">before</a>), or for allocating other address space. For example,
we might want to allocate MMIO space for PCI BARs:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use buddy_system_allocator::FrameAllocator;
use core::alloc::Layout;

fn main() {
    let mut allocator = FrameAllocator::&lt;32&gt;::new();
    allocator.add_frame(0x200_0000, 0x400_0000);

    let layout = Layout::from_size_align(0x100, 0x100).unwrap();
    let bar = allocator
        .alloc_aligned(layout)
        .expect(&quot;Failed to allocate 0x100 byte MMIO region&quot;);
    println!(&quot;Allocated 0x100 byte MMIO region at {:#x}&quot;, bar);
}</code></pre></pre>
<details>
<ul>
<li>PCI BARs always have alignment equal to their size.</li>
<li>Run the example with <code>cargo run</code> under <code>src/bare-metal/useful-crates/allocator-example/</code>. (It won‚Äôt
run in the Playground because of the crate dependency.)</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tinyvec"><a class="header" href="#tinyvec"><code>tinyvec</code></a></h1>
<p>Sometimes you want something which can be resized like a <code>Vec</code>, but without heap allocation.
<a href="https://crates.io/crates/tinyvec"><code>tinyvec</code></a> provides this: a vector backed by an array or slice, which could be statically
allocated or on the stack, which keeps track of how many elements are used and panics if you try to
use more than are allocated.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use tinyvec::{array_vec, ArrayVec};

fn main() {
    let mut numbers: ArrayVec&lt;[u32; 5]&gt; = array_vec!(42, 66);
    println!(&quot;{numbers:?}&quot;);
    numbers.push(7);
    println!(&quot;{numbers:?}&quot;);
    numbers.remove(1);
    println!(&quot;{numbers:?}&quot;);
}</code></pre></pre>
<details>
<ul>
<li><code>tinyvec</code> requires that the element type implement <code>Default</code> for initialisation.</li>
<li>The Rust Playground includes <code>tinyvec</code>, so this example will run fine inline.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spin"><a class="header" href="#spin"><code>spin</code></a></h1>
<p><code>std::sync::Mutex</code> and the other synchronisation primitives from <code>std::sync</code> are not available in
<code>core</code> or <code>alloc</code>. How can we manage synchronisation or interior mutability, such as for sharing
state between different CPUs?</p>
<p>The <a href="https://crates.io/crates/spin"><code>spin</code></a> crate provides spinlock-based equivalents of many of these primitives.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use spin::mutex::SpinMutex;

static counter: SpinMutex&lt;u32&gt; = SpinMutex::new(0);

fn main() {
    println!(&quot;count: {}&quot;, counter.lock());
    *counter.lock() += 2;
    println!(&quot;count: {}&quot;, counter.lock());
}</code></pre></pre>
<details>
<ul>
<li>Be careful to avoid deadlock if you take locks in interrupt handlers.</li>
<li><code>spin</code> also has a ticket lock mutex implementation; equivalents of <code>RwLock</code>, <code>Barrier</code> and <code>Once</code>
from <code>std::sync</code>;  and <code>Lazy</code> for lazy initialisation.</li>
<li>The <a href="https://crates.io/crates/once_cell"><code>once_cell</code></a> crate also has some useful types for late initialisation with a slightly
different approach to <code>spin::once::Once</code>.</li>
<li>The Rust Playground includes <code>spin</code>, so this example will run fine inline.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="android-1"><a class="header" href="#android-1">Android</a></h1>
<p>To build a bare-metal Rust binary in AOSP, you need to use a <code>rust_ffi_static</code> Soong rule to build
your Rust code, then a <code>cc_binary</code> with a linker script to produce the binary itself, and then a
<code>raw_binary</code> to convert the ELF to a raw binary ready to be run.</p>
<pre><code class="language-soong">rust_ffi_static {
    name: &quot;libvmbase_example&quot;,
    defaults: [&quot;vmbase_ffi_defaults&quot;],
    crate_name: &quot;vmbase_example&quot;,
    srcs: [&quot;src/main.rs&quot;],
    rustlibs: [
        &quot;libvmbase&quot;,
    ],
}

cc_binary {
    name: &quot;vmbase_example&quot;,
    defaults: [&quot;vmbase_elf_defaults&quot;],
    srcs: [
        &quot;idmap.S&quot;,
    ],
    static_libs: [
        &quot;libvmbase_example&quot;,
    ],
    linker_scripts: [
        &quot;image.ld&quot;,
        &quot;:vmbase_sections&quot;,
    ],
}

raw_binary {
    name: &quot;vmbase_example_bin&quot;,
    stem: &quot;vmbase_example.bin&quot;,
    src: &quot;:vmbase_example&quot;,
    enabled: false,
    target: {
        android_arm64: {
            enabled: true,
        },
    },
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vmbase"><a class="header" href="#vmbase">vmbase</a></h1>
<p>For VMs running under crosvm on aarch64, the <a href="https://android.googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/master/vmbase/">vmbase</a> library provides a linker script and useful
defaults for the build rules, along with an entry point, UART console logging and more.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">#![no_main]
#![no_std]

use vmbase::{main, println};

main!(main);

pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {
    println!(&quot;Hello world&quot;);
}</code></pre></pre>
<details>
<ul>
<li>The <code>main!</code> macro marks your main function, to be called from the <code>vmbase</code> entry point.</li>
<li>The <code>vmbase</code> entry point handles console initialisation, and issues a PSCI_SYSTEM_OFF to shutdown
the VM if your main function returns.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h1>
<p>We will write a driver for the PL031 real-time clock device.</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/bare-metal/solutions-afternoon.html">solutions</a> provided.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rtc-driver"><a class="header" href="#rtc-driver">RTC driver</a></h1>
<p>The QEMU aarch64 virt machine has a <a href="https://developer.arm.com/documentation/ddi0224/c">PL031</a> real-time clock at 0x9010000. For this exercise, you
should write a driver for it.</p>
<ol>
<li>Use it to print the current time to the serial console. You can use the <a href="https://crates.io/crates/chrono"><code>chrono</code></a> crate for
date/time formatting.</li>
<li>Use the match register and raw interrupt status to busy-wait until a given time, e.g. 3 seconds
in the future. (Call <a href="https://doc.rust-lang.org/core/hint/fn.spin_loop.html"><code>core::hint::spin_loop</code></a> inside the loop.)</li>
<li><em>Extension if you have time:</em> Enable and handle the interrupt generated by the RTC match. You can
use the driver provided in the <a href="https://docs.rs/arm-gic/"><code>arm-gic</code></a> crate to configure the Arm Generic Interrupt Controller.
<ul>
<li>Use the RTC interrupt, which is wired to the GIC as <code>IntId::spi(2)</code>.</li>
<li>Once the interrupt is enabled, you can put the core to sleep via <code>arm_gic::wfi()</code>, which will cause the core to sleep until it receives an interrupt.</li>
</ul>
</li>
</ol>
<p>Download the <a href="comprehensive-rust-exercises.zip">exercise template</a> and look in the <code>rtc</code>
directory for the following files.</p>
<p><code>src/main.rs</code>:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;

use crate::pl011::Uart;
use arm_gic::gicv3::GicV3;
use core::panic::PanicInfo;
use log::{error, info, trace, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base addresses of the GICv3.
const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;
const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

#[no_mangle]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,
    // and nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!(&quot;main({:#x}, {:#x}, {:#x}, {:#x})&quot;, x0, x1, x2, x3);

    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base
    // addresses of a GICv3 distributor and redistributor respectively, and
    // nothing else accesses those address ranges.
    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };
    gic.setup();

    // TODO: Create instance of RTC driver and print current time.

    // TODO: Wait for 3 seconds.

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!(&quot;{info}&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}</code></pre></pre>
<p><code>src/exceptions.rs</code> (you should only need to change this for the 3rd part of the exercise):</p>
<!-- File src/exceptions.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use arm_gic::gicv3::GicV3;
use log::{error, info, trace};
use smccc::psci::system_off;
use smccc::Hvc;

#[no_mangle]
extern &quot;C&quot; fn sync_exception_current(_elr: u64, _spsr: u64) {
    error!(&quot;sync_exception_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn irq_current(_elr: u64, _spsr: u64) {
    trace!(&quot;irq_current&quot;);
    let intid = GicV3::get_and_acknowledge_interrupt().expect(&quot;No pending interrupt&quot;);
    info!(&quot;IRQ {intid:?}&quot;);
}

#[no_mangle]
extern &quot;C&quot; fn fiq_current(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn serr_current(_elr: u64, _spsr: u64) {
    error!(&quot;serr_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn sync_lower(_elr: u64, _spsr: u64) {
    error!(&quot;sync_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn irq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;irq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn fiq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn serr_lower(_elr: u64, _spsr: u64) {
    error!(&quot;serr_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p><code>src/logger.rs</code> (you shouldn‚Äôt need to change this):</p>
<!-- File src/logger.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
use crate::pl011::Uart;
use core::fmt::Write;
use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};
use spin::mutex::SpinMutex;

static LOGGER: Logger = Logger {
    uart: SpinMutex::new(None),
};

struct Logger {
    uart: SpinMutex&lt;Option&lt;Uart&gt;&gt;,
}

impl Log for Logger {
    fn enabled(&amp;self, _metadata: &amp;Metadata) -&gt; bool {
        true
    }

    fn log(&amp;self, record: &amp;Record) {
        writeln!(
            self.uart.lock().as_mut().unwrap(),
            &quot;[{}] {}&quot;,
            record.level(),
            record.args()
        )
        .unwrap();
    }

    fn flush(&amp;self) {}
}

/// Initialises UART logger.
pub fn init(uart: Uart, max_level: LevelFilter) -&gt; Result&lt;(), SetLoggerError&gt; {
    LOGGER.uart.lock().replace(uart);

    log::set_logger(&amp;LOGGER)?;
    log::set_max_level(max_level);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><code>src/pl011.rs</code> (you shouldn‚Äôt need to change this):</p>
<!-- File src/pl011.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(unused)]

use core::fmt::{self, Write};
use core::ptr::{addr_of, addr_of_mut};

// ANCHOR: Flags
use bitflags::bitflags;

bitflags! {
    /// Flags from the UART flag register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct Flags: u16 {
        /// Clear to send.
        const CTS = 1 &lt;&lt; 0;
        /// Data set ready.
        const DSR = 1 &lt;&lt; 1;
        /// Data carrier detect.
        const DCD = 1 &lt;&lt; 2;
        /// UART busy transmitting data.
        const BUSY = 1 &lt;&lt; 3;
        /// Receive FIFO is empty.
        const RXFE = 1 &lt;&lt; 4;
        /// Transmit FIFO is full.
        const TXFF = 1 &lt;&lt; 5;
        /// Receive FIFO is full.
        const RXFF = 1 &lt;&lt; 6;
        /// Transmit FIFO is empty.
        const TXFE = 1 &lt;&lt; 7;
        /// Ring indicator.
        const RI = 1 &lt;&lt; 8;
    }
}
// ANCHOR_END: Flags

bitflags! {
    /// Flags from the UART Receive Status Register / Error Clear Register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct ReceiveStatus: u16 {
        /// Framing error.
        const FE = 1 &lt;&lt; 0;
        /// Parity error.
        const PE = 1 &lt;&lt; 1;
        /// Break error.
        const BE = 1 &lt;&lt; 2;
        /// Overrun error.
        const OE = 1 &lt;&lt; 3;
    }
}

// ANCHOR: Registers
#[repr(C, align(4))]
struct Registers {
    dr: u16,
    _reserved0: [u8; 2],
    rsr: ReceiveStatus,
    _reserved1: [u8; 19],
    fr: Flags,
    _reserved2: [u8; 6],
    ilpr: u8,
    _reserved3: [u8; 3],
    ibrd: u16,
    _reserved4: [u8; 2],
    fbrd: u8,
    _reserved5: [u8; 3],
    lcr_h: u8,
    _reserved6: [u8; 3],
    cr: u16,
    _reserved7: [u8; 3],
    ifls: u8,
    _reserved8: [u8; 3],
    imsc: u16,
    _reserved9: [u8; 2],
    ris: u16,
    _reserved10: [u8; 2],
    mis: u16,
    _reserved11: [u8; 2],
    icr: u16,
    _reserved12: [u8; 2],
    dmacr: u8,
    _reserved13: [u8; 3],
}
// ANCHOR_END: Registers

// ANCHOR: Uart
/// Driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    registers: *mut Registers,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self {
            registers: base_address as *mut Registers,
        }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register().contains(Flags::TXFF) {}

        // Safe because we know that self.registers points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register().contains(Flags::BUSY) {}
    }

    /// Reads and returns a pending byte, or `None` if nothing has been received.
    pub fn read_byte(&amp;self) -&gt; Option&lt;u8&gt; {
        if self.read_flag_register().contains(Flags::RXFE) {
            None
        } else {
            let data = unsafe { addr_of!((*self.registers).dr).read_volatile() };
            // TODO: Check for error conditions in bits 8-11.
            Some(data as u8)
        }
    }

    fn read_flag_register(&amp;self) -&gt; Flags {
        // Safe because we know that self.registers points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe { addr_of!((*self.registers).fr).read_volatile() }
    }
}
// ANCHOR_END: Uart

impl Write for Uart {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        for c in s.as_bytes() {
            self.write_byte(*c);
        }
        Ok(())
    }
}

// Safe because it just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Uart {}
<span class="boring">}</span></code></pre></pre>
<p><code>Cargo.toml</code> (you shouldn‚Äôt need to change this):</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[workspace]

[package]
name = &quot;rtc&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
arm-gic = &quot;0.1.0&quot;
bitflags = &quot;2.0.0&quot;
chrono = { version = &quot;0.4.24&quot;, default-features = false }
log = &quot;0.4.17&quot;
smccc = &quot;0.1.1&quot;
spin = &quot;0.9.8&quot;

[build-dependencies]
cc = &quot;1.0.73&quot;
</code></pre>
<p><code>build.rs</code> (you shouldn‚Äôt need to change this):</p>
<!-- File build.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use cc::Build;
use std::env;

fn main() {
    #[cfg(target_os = &quot;linux&quot;)]
    env::set_var(&quot;CROSS_COMPILE&quot;, &quot;aarch64-linux-gnu&quot;);
    #[cfg(not(target_os = &quot;linux&quot;))]
    env::set_var(&quot;CROSS_COMPILE&quot;, &quot;aarch64-none-elf&quot;);

    Build::new()
        .file(&quot;entry.S&quot;)
        .file(&quot;exceptions.S&quot;)
        .file(&quot;idmap.S&quot;)
        .compile(&quot;empty&quot;)
}</code></pre></pre>
<p><code>entry.S</code> (you shouldn‚Äôt need to change this):</p>
<!-- File entry.S -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

.macro adr_l, reg:req, sym:req
	adrp \reg, \sym
	add \reg, \reg, :lo12:\sym
.endm

.macro mov_i, reg:req, imm:req
	movz \reg, :abs_g3:\imm
	movk \reg, :abs_g2_nc:\imm
	movk \reg, :abs_g1_nc:\imm
	movk \reg, :abs_g0_nc:\imm
.endm

.set .L_MAIR_DEV_nGnRE,	0x04
.set .L_MAIR_MEM_WBWA,	0xff
.set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA &lt;&lt; 8)

/* 4 KiB granule size for TTBR0_EL1. */
.set .L_TCR_TG0_4KB, 0x0 &lt;&lt; 14
/* 4 KiB granule size for TTBR1_EL1. */
.set .L_TCR_TG1_4KB, 0x2 &lt;&lt; 30
/* Disable translation table walk for TTBR1_EL1, generating a translation fault instead. */
.set .L_TCR_EPD1, 0x1 &lt;&lt; 23
/* Translation table walks for TTBR0_EL1 are inner sharable. */
.set .L_TCR_SH_INNER, 0x3 &lt;&lt; 12
/*
 * Translation table walks for TTBR0_EL1 are outer write-back read-allocate write-allocate
 * cacheable.
 */
.set .L_TCR_RGN_OWB, 0x1 &lt;&lt; 10
/*
 * Translation table walks for TTBR0_EL1 are inner write-back read-allocate write-allocate
 * cacheable.
 */
.set .L_TCR_RGN_IWB, 0x1 &lt;&lt; 8
/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */
.set .L_TCR_T0SZ_512, 64 - 39
.set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | .L_TCR_RGN_OWB
.set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | .L_TCR_T0SZ_512

/* Stage 1 instruction access cacheability is unaffected. */
.set .L_SCTLR_ELx_I, 0x1 &lt;&lt; 12
/* SP alignment fault if SP is not aligned to a 16 byte boundary. */
.set .L_SCTLR_ELx_SA, 0x1 &lt;&lt; 3
/* Stage 1 data access cacheability is unaffected. */
.set .L_SCTLR_ELx_C, 0x1 &lt;&lt; 2
/* EL0 and EL1 stage 1 MMU enabled. */
.set .L_SCTLR_ELx_M, 0x1 &lt;&lt; 0
/* Privileged Access Never is unchanged on taking an exception to EL1. */
.set .L_SCTLR_EL1_SPAN, 0x1 &lt;&lt; 23
/* SETEND instruction disabled at EL0 in aarch32 mode. */
.set .L_SCTLR_EL1_SED, 0x1 &lt;&lt; 8
/* Various IT instructions are disabled at EL0 in aarch32 mode. */
.set .L_SCTLR_EL1_ITD, 0x1 &lt;&lt; 7
.set .L_SCTLR_EL1_RES1, (0x1 &lt;&lt; 11) | (0x1 &lt;&lt; 20) | (0x1 &lt;&lt; 22) | (0x1 &lt;&lt; 28) | (0x1 &lt;&lt; 29)
.set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | .L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED
.set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | .L_SCTLR_EL1_RES1

/**
 * This is a generic entry point for an image. It carries out the operations required to prepare the
 * loaded image to be run. Specifically, it zeroes the bss section using registers x25 and above,
 * prepares the stack, enables floating point, and sets up the exception vector. It preserves x0-x3
 * for the Rust entry point, as these may contain boot parameters.
 */
.section .init.entry, &quot;ax&quot;
.global entry
entry:
	/* Load and apply the memory management configuration, ready to enable MMU and caches. */
	adrp x30, idmap
	msr ttbr0_el1, x30

	mov_i x30, .Lmairval
	msr mair_el1, x30

	mov_i x30, .Ltcrval
	/* Copy the supported PA range into TCR_EL1.IPS. */
	mrs x29, id_aa64mmfr0_el1
	bfi x30, x29, #32, #4

	msr tcr_el1, x30

	mov_i x30, .Lsctlrval

	/*
	 * Ensure everything before this point has completed, then invalidate any potentially stale
	 * local TLB entries before they start being used.
	 */
	isb
	tlbi vmalle1
	ic iallu
	dsb nsh
	isb

	/*
	 * Configure sctlr_el1 to enable MMU and cache and don't proceed until this has completed.
	 */
	msr sctlr_el1, x30
	isb

	/* Disable trapping floating point access in EL1. */
	mrs x30, cpacr_el1
	orr x30, x30, #(0x3 &lt;&lt; 20)
	msr cpacr_el1, x30
	isb

	/* Zero out the bss section. */
	adr_l x29, bss_begin
	adr_l x30, bss_end
0:	cmp x29, x30
	b.hs 1f
	stp xzr, xzr, [x29], #16
	b 0b

1:	/* Prepare the stack. */
	adr_l x30, boot_stack_end
	mov sp, x30

	/* Set up exception vector. */
	adr x30, vector_table_el1
	msr vbar_el1, x30

	/* Call into Rust code. */
	bl main

	/* Loop forever waiting for interrupts. */
2:	wfi
	b 2b
</code></pre>
<p><code>exceptions.S</code> (you shouldn‚Äôt need to change this):</p>
<!-- File exceptions.S -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Saves the volatile registers onto the stack. This currently takes 14
 * instructions, so it can be used in exception handlers with 18 instructions
 * left.
 *
 * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 respectively,
 * which can be used as the first and second arguments of a subsequent call.
 */
.macro save_volatile_to_stack
	/* Reserve stack space and save registers x0-x18, x29 &amp; x30. */
	stp x0, x1, [sp, #-(8 * 24)]!
	stp x2, x3, [sp, #8 * 2]
	stp x4, x5, [sp, #8 * 4]
	stp x6, x7, [sp, #8 * 6]
	stp x8, x9, [sp, #8 * 8]
	stp x10, x11, [sp, #8 * 10]
	stp x12, x13, [sp, #8 * 12]
	stp x14, x15, [sp, #8 * 14]
	stp x16, x17, [sp, #8 * 16]
	str x18, [sp, #8 * 18]
	stp x29, x30, [sp, #8 * 20]

	/*
	 * Save elr_el1 &amp; spsr_el1. This such that we can take nested exception
	 * and still be able to unwind.
	 */
	mrs x0, elr_el1
	mrs x1, spsr_el1
	stp x0, x1, [sp, #8 * 22]
.endm

/**
 * Restores the volatile registers from the stack. This currently takes 14
 * instructions, so it can be used in exception handlers while still leaving 18
 * instructions left; if paired with save_volatile_to_stack, there are 4
 * instructions to spare.
 */
.macro restore_volatile_from_stack
	/* Restore registers x2-x18, x29 &amp; x30. */
	ldp x2, x3, [sp, #8 * 2]
	ldp x4, x5, [sp, #8 * 4]
	ldp x6, x7, [sp, #8 * 6]
	ldp x8, x9, [sp, #8 * 8]
	ldp x10, x11, [sp, #8 * 10]
	ldp x12, x13, [sp, #8 * 12]
	ldp x14, x15, [sp, #8 * 14]
	ldp x16, x17, [sp, #8 * 16]
	ldr x18, [sp, #8 * 18]
	ldp x29, x30, [sp, #8 * 20]

	/* Restore registers elr_el1 &amp; spsr_el1, using x0 &amp; x1 as scratch. */
	ldp x0, x1, [sp, #8 * 22]
	msr elr_el1, x0
	msr spsr_el1, x1

	/* Restore x0 &amp; x1, and release stack space. */
	ldp x0, x1, [sp], #8 * 24
.endm

/**
 * This is a generic handler for exceptions taken at the current EL while using
 * SP0. It behaves similarly to the SPx case by first switching to SPx, doing
 * the work, then switching back to SP0 before returning.
 *
 * Switching to SPx and calling the Rust handler takes 16 instructions. To
 * restore and return we need an additional 16 instructions, so we can implement
 * the whole handler within the allotted 32 instructions.
 */
.macro current_exception_sp0 handler:req
	msr spsel, #1
	save_volatile_to_stack
	bl \handler
	restore_volatile_from_stack
	msr spsel, #0
	eret
.endm

/**
 * This is a generic handler for exceptions taken at the current EL while using
 * SPx. It saves volatile registers, calls the Rust handler, restores volatile
 * registers, then returns.
 *
 * This also works for exceptions taken from EL0, if we don't care about
 * non-volatile registers.
 *
 * Saving state and jumping to the Rust handler takes 15 instructions, and
 * restoring and returning also takes 15 instructions, so we can fit the whole
 * handler in 30 instructions, under the limit of 32.
 */
.macro current_exception_spx handler:req
	save_volatile_to_stack
	bl \handler
	restore_volatile_from_stack
	eret
.endm

.section .text.vector_table_el1, &quot;ax&quot;
.global vector_table_el1
.balign 0x800
vector_table_el1:
sync_cur_sp0:
	current_exception_sp0 sync_exception_current

.balign 0x80
irq_cur_sp0:
	current_exception_sp0 irq_current

.balign 0x80
fiq_cur_sp0:
	current_exception_sp0 fiq_current

.balign 0x80
serr_cur_sp0:
	current_exception_sp0 serr_current

.balign 0x80
sync_cur_spx:
	current_exception_spx sync_exception_current

.balign 0x80
irq_cur_spx:
	current_exception_spx irq_current

.balign 0x80
fiq_cur_spx:
	current_exception_spx fiq_current

.balign 0x80
serr_cur_spx:
	current_exception_spx serr_current

.balign 0x80
sync_lower_64:
	current_exception_spx sync_lower

.balign 0x80
irq_lower_64:
	current_exception_spx irq_lower

.balign 0x80
fiq_lower_64:
	current_exception_spx fiq_lower

.balign 0x80
serr_lower_64:
	current_exception_spx serr_lower

.balign 0x80
sync_lower_32:
	current_exception_spx sync_lower

.balign 0x80
irq_lower_32:
	current_exception_spx irq_lower

.balign 0x80
fiq_lower_32:
	current_exception_spx fiq_lower

.balign 0x80
serr_lower_32:
	current_exception_spx serr_lower
</code></pre>
<p><code>idmap.S</code> (you shouldn‚Äôt need to change this):</p>
<!-- File idmap.S -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

.set .L_TT_TYPE_BLOCK, 0x1
.set .L_TT_TYPE_PAGE,  0x3
.set .L_TT_TYPE_TABLE, 0x3

/* Access flag. */
.set .L_TT_AF, 0x1 &lt;&lt; 10
/* Not global. */
.set .L_TT_NG, 0x1 &lt;&lt; 11
.set .L_TT_XN, 0x3 &lt;&lt; 53

.set .L_TT_MT_DEV, 0x0 &lt;&lt; 2			// MAIR #0 (DEV_nGnRE)
.set .L_TT_MT_MEM, (0x1 &lt;&lt; 2) | (0x3 &lt;&lt; 8)	// MAIR #1 (MEM_WBWA), inner shareable

.set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN
.set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG

.section &quot;.rodata.idmap&quot;, &quot;a&quot;, %progbits
.global idmap
.align 12
idmap:
	/* level 1 */
	.quad		.L_BLOCK_DEV | 0x0		    // 1 GiB of device mappings
	.quad		.L_BLOCK_MEM | 0x40000000	// 1 GiB of DRAM
	.fill		254, 8, 0x0			// 254 GiB of unmapped VA space
	.quad		.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings
	.fill		255, 8, 0x0			// 255 GiB of remaining VA space
</code></pre>
<p><code>image.ld</code> (you shouldn‚Äôt need to change this):</p>
<!-- File image.ld -->
<pre><code class="language-ld">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Code will start running at this symbol which is placed at the start of the
 * image.
 */
ENTRY(entry)

MEMORY
{
	image : ORIGIN = 0x40080000, LENGTH = 2M
}

SECTIONS
{
	/*
	 * Collect together the code.
	 */
	.init : ALIGN(4096) {
		text_begin = .;
		*(.init.entry)
		*(.init.*)
	} &gt;image
	.text : {
		*(.text.*)
	} &gt;image
	text_end = .;

	/*
	 * Collect together read-only data.
	 */
	.rodata : ALIGN(4096) {
		rodata_begin = .;
		*(.rodata.*)
	} &gt;image
	.got : {
		*(.got)
	} &gt;image
	rodata_end = .;

	/*
	 * Collect together the read-write data including .bss at the end which
	 * will be zero'd by the entry code.
	 */
	.data : ALIGN(4096) {
		data_begin = .;
		*(.data.*)
		/*
		 * The entry point code assumes that .data is a multiple of 32
		 * bytes long.
		 */
		. = ALIGN(32);
		data_end = .;
	} &gt;image

	/* Everything beyond this point will not be included in the binary. */
	bin_end = .;

	/* The entry point code assumes that .bss is 16-byte aligned. */
	.bss : ALIGN(16)  {
		bss_begin = .;
		*(.bss.*)
		*(COMMON)
		. = ALIGN(16);
		bss_end = .;
	} &gt;image

	.stack (NOLOAD) : ALIGN(4096) {
		boot_stack_begin = .;
		. += 40 * 4096;
		. = ALIGN(4096);
		boot_stack_end = .;
	} &gt;image

	. = ALIGN(4K);
	PROVIDE(dma_region = .);

	/*
	 * Remove unused sections from the image.
	 */
	/DISCARD/ : {
		/* The image loads itself so doesn't need these sections. */
		*(.gnu.hash)
		*(.hash)
		*(.interp)
		*(.eh_frame_hdr)
		*(.eh_frame)
		*(.note.gnu.build-id)
	}
}
</code></pre>
<p><code>Makefile</code> (you shouldn‚Äôt need to change this):</p>
<!-- File Makefile -->
<pre><code class="language-makefile"># Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

UNAME := $(shell uname -s)
ifeq ($(UNAME),Linux)
	TARGET = aarch64-linux-gnu
else
	TARGET = aarch64-none-elf
endif
OBJCOPY = $(TARGET)-objcopy

.PHONY: build qemu_minimal qemu qemu_logger

all: rtc.bin

build:
	cargo build

rtc.bin: build
	$(OBJCOPY) -O binary target/aarch64-unknown-none/debug/rtc $@

qemu: rtc.bin
	qemu-system-aarch64 -machine virt,gic-version=3 -cpu max -serial mon:stdio -display none -kernel $&lt; -s

clean:
	cargo clean
	rm -f *.bin
</code></pre>
<p><code>.cargo/config.toml</code> (you shouldn‚Äôt need to change this):</p>
<!-- File .cargo/config.toml -->
<pre><code class="language-toml">[build]
target = &quot;aarch64-unknown-none&quot;
rustflags = [&quot;-C&quot;, &quot;link-arg=-Timage.ld&quot;]
</code></pre>
<p>Run the code in QEMU with <code>make qemu</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="welcome-to-concurrency-in-rust"><a class="header" href="#welcome-to-concurrency-in-rust">Welcome to Concurrency in Rust</a></h1>
<p>Rust has full support for concurrency using OS threads with mutexes and
channels.</p>
<p>The Rust type system plays an important role in making many concurrency bugs
compile time bugs. This is often referred to as <em>fearless concurrency</em> since you
can rely on the compiler to ensure correctness at runtime.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<p>Rust threads work similarly to threads in other languages:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Count in thread: {i}!&quot;);
            thread::sleep(Duration::from_millis(5));
        }
    });

    for i in 1..5 {
        println!(&quot;Main thread: {i}&quot;);
        thread::sleep(Duration::from_millis(5));
    }
}</code></pre></pre>
<ul>
<li>Threads are all daemon threads, the main thread does not wait for them.</li>
<li>Thread panics are independent of each other.
<ul>
<li>Panics can carry a payload, which can be unpacked with <code>downcast_ref</code>.</li>
</ul>
</li>
</ul>
<details>
<p>‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¶‡¶ø‡¶ï:</p>
<ul>
<li>
<p>Notice that the thread is stopped before it reaches 10 ‚Äî the main thread is
not waiting.</p>
</li>
<li>
<p>Use <code>let handle = thread::spawn(...)</code> and later <code>handle.join()</code> to wait for
the thread to finish.</p>
</li>
<li>
<p>Trigger a panic in the thread, notice how this doesn‚Äôt affect <code>main</code>.</p>
</li>
<li>
<p>Use the <code>Result</code> return value from <code>handle.join()</code> to get access to the panic
payload. This is a good time to talk about <a href="https://doc.rust-lang.org/std/any/index.html"><code>Any</code></a>.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoped-threads"><a class="header" href="#scoped-threads">Scoped Threads</a></h1>
<p>Normal threads cannot borrow from their environment:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::thread;

fn foo() {
    let s = String::from(&quot;Hello&quot;);
    thread::spawn(|| {
        println!(&quot;Length: {}&quot;, s.len());
    });
}

fn main() {
    foo();
}</code></pre></pre>
<p>However, you can use a <a href="https://doc.rust-lang.org/std/thread/fn.scope.html">scoped thread</a> for this:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::thread;

fn main() {
    let s = String::from(&quot;Hello&quot;);

    thread::scope(|scope| {
        scope.spawn(|| {
            println!(&quot;Length: {}&quot;, s.len());
        });
    });
}</code></pre></pre>
<details>
<ul>
<li>The reason for that is that when the <code>thread::scope</code> function completes, all the threads are guaranteed to be joined, so they can return borrowed data.</li>
<li>Normal Rust borrowing rules apply: you can either borrow mutably by one thread, or immutably by any number of threads.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channels"><a class="header" href="#channels">Channels</a></h1>
<p>Rust channels have two parts: a <code>Sender&lt;T&gt;</code> and a <code>Receiver&lt;T&gt;</code>. The two parts
are connected via the channel, but you only see the end-points.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    tx.send(10).unwrap();
    tx.send(20).unwrap();

    println!(&quot;Received: {:?}&quot;, rx.recv());
    println!(&quot;Received: {:?}&quot;, rx.recv());

    let tx2 = tx.clone();
    tx2.send(30).unwrap();
    println!(&quot;Received: {:?}&quot;, rx.recv());
}</code></pre></pre>
<details>
<ul>
<li><code>mpsc</code> stands for Multi-Producer, Single-Consumer. <code>Sender</code> and <code>SyncSender</code> implement <code>Clone</code> (so
you can make multiple producers) but <code>Receiver</code> does not.</li>
<li><code>send()</code> and <code>recv()</code> return <code>Result</code>. If they return <code>Err</code>, it means the counterpart <code>Sender</code> or
<code>Receiver</code> is dropped and the channel is closed.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unbounded-channels"><a class="header" href="#unbounded-channels">Unbounded Channels</a></h1>
<p>You get an unbounded and asynchronous channel with <code>mpsc::channel()</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 1..10 {
            tx.send(format!(&quot;Message {i}&quot;)).unwrap();
            println!(&quot;{thread_id:?}: sent Message {i}&quot;);
        }
        println!(&quot;{thread_id:?}: done&quot;);
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!(&quot;Main: got {msg}&quot;);
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bounded-channels"><a class="header" href="#bounded-channels">Bounded Channels</a></h1>
<p>With bounded (synchronous) channels, <code>send</code> can block the current thread:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::sync_channel(3);

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 1..10 {
            tx.send(format!(&quot;Message {i}&quot;)).unwrap();
            println!(&quot;{thread_id:?}: sent Message {i}&quot;);
        }
        println!(&quot;{thread_id:?}: done&quot;);
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!(&quot;Main: got {msg}&quot;);
    }
}</code></pre></pre>
<details>
<ul>
<li>Calling <code>send</code> will block the current thread until there is space in the channel for the new message. The thread can be blocked indefinitely if there is nobody who reads from the channel.</li>
<li>A call to <code>send</code> will abort with an error (that is why it returns <code>Result</code>) if the channel is closed. A channel is closed when the receiver is dropped.</li>
<li>A bounded channel with a size of zero is called a ‚Äúrendezvous channel‚Äù. Every send will block the current thread until another thread calls <code>read</code>.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-and-sync"><a class="header" href="#send-and-sync"><code>Send</code> and <code>Sync</code></a></h1>
<p>How does Rust know to forbid shared access across thread? The answer is in two traits:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>: a type <code>T</code> is <code>Send</code> if it is safe to move a <code>T</code> across a thread
boundary.</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>: a type <code>T</code> is <code>Sync</code> if it is safe to move a <code>&amp;T</code> across a thread
boundary.</li>
</ul>
<p><code>Send</code> and <code>Sync</code> are <a href="unsafe/unsafe-traits.html">unsafe traits</a>. The compiler will automatically derive them for your types
as long as they only contain <code>Send</code> and <code>Sync</code> types. You can also implement them manually when you
know it is valid.</p>
<details>
<ul>
<li>One can think of these traits as markers that the type has certain thread-safety properties.</li>
<li>They can be used in the generic constraints as normal traits.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send"><a class="header" href="#send"><code>Send</code></a></h1>
<blockquote>
<p>A type <code>T</code> is <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> if it is safe to move a <code>T</code> value to another thread.</p>
</blockquote>
<p>The effect of moving ownership to another thread is that <em>destructors</em> will run
in that thread. So the question is when you can allocate a value in one thread
and deallocate it in another.</p>
<details>
<p>As an example, a connection to the SQLite library must only be accessed from a
single thread.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sync"><a class="header" href="#sync"><code>Sync</code></a></h1>
<blockquote>
<p>A type <code>T</code> is <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> if it is safe to access a <code>T</code> value from multiple
threads at the same time.</p>
</blockquote>
<p>More precisely, the definition is:</p>
<blockquote>
<p><code>T</code> is <code>Sync</code> if and only if <code>&amp;T</code> is <code>Send</code></p>
</blockquote>
<details>
<p>This statement is essentially a shorthand way of saying that if a type is thread-safe for shared use, it is also thread-safe to pass references of it across threads.</p>
<p>This is because if a type is Sync it means that it can be shared across multiple threads without the risk of data races or other synchronization issues, so it is safe to move it to another thread. A reference to the type is also safe to move to another thread, because the data it references can be accessed from any thread safely.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡¶∏‡¶Æ‡ßÇ‡¶π"><a class="header" href="#‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡¶∏‡¶Æ‡ßÇ‡¶π">‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡¶∏‡¶Æ‡ßÇ‡¶π</a></h1>
<h2 id="send--sync"><a class="header" href="#send--sync"><code>Send + Sync</code></a></h2>
<p>Most types you come across are <code>Send + Sync</code>:</p>
<ul>
<li><code>i8</code>, <code>f32</code>, <code>bool</code>, <code>char</code>, <code>&amp;str</code>, ‚Ä¶</li>
<li><code>(T1, T2)</code>, <code>[T; N]</code>, <code>&amp;[T]</code>, <code>struct { x: T }</code>, ‚Ä¶</li>
<li><code>String</code>, <code>Option&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, <code>Box&lt;T&gt;</code>, ‚Ä¶</li>
<li><code>Arc&lt;T&gt;</code>: Explicitly thread-safe via atomic reference count.</li>
<li><code>Mutex&lt;T&gt;</code>: Explicitly thread-safe via internal locking.</li>
<li><code>AtomicBool</code>, <code>AtomicU8</code>, ‚Ä¶: Uses special atomic instructions.</li>
</ul>
<p>The generic types are typically <code>Send + Sync</code> when the type parameters are
<code>Send + Sync</code>.</p>
<h2 id="send--sync-1"><a class="header" href="#send--sync-1"><code>Send + !Sync</code></a></h2>
<p>These types can be moved to other threads, but they‚Äôre not thread-safe.
Typically because of interior mutability:</p>
<ul>
<li><code>mpsc::Sender&lt;T&gt;</code></li>
<li><code>mpsc::Receiver&lt;T&gt;</code></li>
<li><code>Cell&lt;T&gt;</code></li>
<li><code>RefCell&lt;T&gt;</code></li>
</ul>
<h2 id="send--sync-2"><a class="header" href="#send--sync-2"><code>!Send + Sync</code></a></h2>
<p>These types are thread-safe, but they cannot be moved to another thread:</p>
<ul>
<li><code>MutexGuard&lt;T&gt;</code>: Uses OS level primitives which must be deallocated on the
thread which created them.</li>
</ul>
<h2 id="send--sync-3"><a class="header" href="#send--sync-3"><code>!Send + !Sync</code></a></h2>
<p>These types are not thread-safe and cannot be moved to other threads:</p>
<ul>
<li><code>Rc&lt;T&gt;</code>: each <code>Rc&lt;T&gt;</code> has a reference to an <code>RcBox&lt;T&gt;</code>, which contains a
non-atomic reference count.</li>
<li><code>*const T</code>, <code>*mut T</code>: Rust assumes raw pointers may have special
concurrency considerations.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-state"><a class="header" href="#shared-state">Shared State</a></h1>
<p>Rust uses the type system to enforce synchronization of shared data. This is
primarily done via two types:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>, atomic reference counted <code>T</code>: handles sharing between threads and
takes care to deallocate <code>T</code> when the last reference is dropped,</li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a>: ensures mutually exclusive access to the <code>T</code> value.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arc"><a class="header" href="#arc"><code>Arc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> allows shared read-only access via <code>Arc::clone</code>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::thread;
use std::sync::Arc;

fn main() {
    let v = Arc::new(vec![10, 20, 30]);
    let mut handles = Vec::new();
    for _ in 1..5 {
        let v = Arc::clone(&amp;v);
        handles.push(thread::spawn(move || {
            let thread_id = thread::current().id();
            println!(&quot;{thread_id:?}: {v:?}&quot;);
        }));
    }

    handles.into_iter().for_each(|h| h.join().unwrap());
    println!(&quot;v: {v:?}&quot;);
}</code></pre></pre>
<details>
<ul>
<li><code>Arc</code> stands for ‚ÄúAtomic Reference Counted‚Äù, a thread safe version of <code>Rc</code> that uses atomic
operations.</li>
<li><code>Arc&lt;T&gt;</code> implements <code>Clone</code> whether or not <code>T</code> does. It implements <code>Send</code> and <code>Sync</code> if
and only if <code>T</code> implements them both.</li>
<li><code>Arc::clone()</code> has the cost of atomic operations that get executed, but after that the use of the
<code>T</code> is free.</li>
<li>Beware of reference cycles, <code>Arc</code> does not use a garbage collector to detect them.
<ul>
<li><code>std::sync::Weak</code> can help.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutex"><a class="header" href="#mutex"><code>Mutex</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a> ensures mutual exclusion <em>and</em> allows mutable access to <code>T</code>
behind a read-only interface:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::Mutex;

fn main() {
    let v = Mutex::new(vec![10, 20, 30]);
    println!(&quot;v: {:?}&quot;, v.lock().unwrap());

    {
        let mut guard = v.lock().unwrap();
        guard.push(40);
    }

    println!(&quot;v: {:?}&quot;, v.lock().unwrap());
}</code></pre></pre>
<p>Notice how we have a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E"><code>impl&lt;T: Send&gt; Sync for Mutex&lt;T&gt;</code></a> blanket
implementation.</p>
<details>
<ul>
<li><code>Mutex</code> in Rust looks like a collection with just one element - the protected data.
<ul>
<li>It is not possible to forget to acquire the mutex before accessing the protected data.</li>
</ul>
</li>
<li>You can get an <code>&amp;mut T</code> from an <code>&amp;Mutex&lt;T&gt;</code> by taking the lock. The <code>MutexGuard</code> ensures that the
<code>&amp;mut T</code> doesn‚Äôt outlive the lock being held.</li>
<li><code>Mutex&lt;T&gt;</code> implements both <code>Send</code> and <code>Sync</code> iff (if and only if) <code>T</code> implements <code>Send</code>.</li>
<li>A read-write lock counterpart - <code>RwLock</code>.</li>
<li>Why does <code>lock()</code> return a <code>Result</code>? 
<ul>
<li>If the thread that held the <code>Mutex</code> panicked, the <code>Mutex</code> becomes ‚Äúpoisoned‚Äù to signal that
the data it protected might be in an inconsistent state. Calling <code>lock()</code> on a poisoned mutex
fails with a <a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html"><code>PoisonError</code></a>. You can call <code>into_inner()</code> on the error to recover the data
regardless.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1"><a class="header" href="#example-1">Example</a></h1>
<p>Let us see <code>Arc</code> and <code>Mutex</code> in action:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::thread;
// use std::sync::{Arc, Mutex};

fn main() {
    let v = vec![10, 20, 30];
    let handle = thread::spawn(|| {
        v.push(10);
    });
    v.push(1000);

    handle.join().unwrap();
    println!(&quot;v: {v:?}&quot;);
}</code></pre></pre>
<details>
<p>Possible solution:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let v = Arc::new(Mutex::new(vec![10, 20, 30]));

    let v2 = Arc::clone(&amp;v);
    let handle = thread::spawn(move || {
        let mut v2 = v2.lock().unwrap();
        v2.push(10);
    });

    {
        let mut v = v.lock().unwrap();
        v.push(1000);
    }

    handle.join().unwrap();

    println!(&quot;v: {v:?}&quot;);
}</code></pre></pre>
<p>Notable parts:</p>
<ul>
<li><code>v</code> is wrapped in both <code>Arc</code> and <code>Mutex</code>, because their concerns are orthogonal.
<ul>
<li>Wrapping a <code>Mutex</code> in an <code>Arc</code> is a common pattern to share mutable state between threads.</li>
</ul>
</li>
<li><code>v: Arc&lt;_&gt;</code> needs to be cloned as <code>v2</code> before it can be moved into another thread. Note <code>move</code> was added to the lambda signature.</li>
<li>Blocks are introduced to narrow the scope of the <code>LockGuard</code> as much as possible.</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h1>
<p>Let us practice our new concurrency skills with</p>
<ul>
<li>
<p>Dining philosophers: a classic problem in concurrency.</p>
</li>
<li>
<p>Multi-threaded link checker: a larger project where you‚Äôll use Cargo to
download dependencies and then check links in parallel.</p>
</li>
</ul>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/concurrency/solutions-morning.html">solutions</a> provided.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dining-philosophers"><a class="header" href="#dining-philosophers">Dining Philosophers</a></h1>
<p>The dining philosophers problem is a classic problem in concurrency:</p>
<blockquote>
<p>Five philosophers dine together at the same table. Each philosopher has their
own place at the table. There is a fork between each plate. The dish served is
a kind of spaghetti which has to be eaten with two forks. Each philosopher can
only alternately think and eat. Moreover, a philosopher can only eat their
spaghetti when they have both a left and right fork. Thus two forks will only
be available when their two nearest neighbors are thinking, not eating. After
an individual philosopher finishes eating, they will put down both forks.</p>
</blockquote>
<p>You will need a local <a href="cargo/running-locally.html">Cargo installation</a> for
this exercise. Copy the code below to a file called <code>src/main.rs</code>, fill out the
blanks, and test that <code>cargo run</code> does not deadlock:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::Duration;

struct Fork;

struct Philosopher {
    name: String,
    // left_fork: ...
    // right_fork: ...
    // thoughts: ...
}

impl Philosopher {
    fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .unwrap();
    }

    fn eat(&amp;self) {
        // Pick up forks...
        println!(&quot;{} is eating...&quot;, &amp;self.name);
        thread::sleep(Duration::from_millis(10));
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Thales&quot;, &quot;Pythagoras&quot;];

fn main() {
    // Create forks

    // Create philosophers

    // Make each of them think and eat 100 times

    // Output their thoughts
}</code></pre></pre>
<p>You can use the following <code>Cargo.toml</code>:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;dining-philosophers&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-threaded-link-checker"><a class="header" href="#multi-threaded-link-checker">Multi-threaded Link Checker</a></h1>
<p>Let us use our new knowledge to create a multi-threaded link checker. It should
start at a webpage and check that links on the page are valid. It should
recursively check other pages on the same domain and keep doing this until all
pages have been validated.</p>
<p>For this, you will need an HTTP client such as <a href="https://docs.rs/reqwest/"><code>reqwest</code></a>. Create a new
Cargo project and <code>reqwest</code> it as a dependency with:</p>
<pre><code class="language-shell">cargo new link-checker
cd link-checker
cargo add --features blocking,rustls-tls reqwest
</code></pre>
<blockquote>
<p>If <code>cargo add</code> fails with <code>error: no such subcommand</code>, then please edit the
<code>Cargo.toml</code> file by hand. Add the dependencies listed below.</p>
</blockquote>
<p>You will also need a way to find links. We can use <a href="https://docs.rs/scraper/"><code>scraper</code></a> for that:</p>
<pre><code class="language-shell">cargo add scraper
</code></pre>
<p>Finally, we‚Äôll need some way of handling errors. We use <a href="https://docs.rs/thiserror/"><code>thiserror</code></a> for
that:</p>
<pre><code class="language-shell">cargo add thiserror
</code></pre>
<p>The <code>cargo add</code> calls will update the <code>Cargo.toml</code> file to look like this:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;link-checker&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
reqwest = { version = &quot;0.11.12&quot;, features = [&quot;blocking&quot;, &quot;rustls-tls&quot;] }
scraper = &quot;0.13.0&quot;
thiserror = &quot;1.0.37&quot;
</code></pre>
<p>You can now download the start page. Try with a small site such as
<code>https://www.google.org/</code>.</p>
<p>Your <code>src/main.rs</code> file should look something like this:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use reqwest::{blocking::Client, Url};
use scraper::{Html, Selector};
use thiserror::Error;

#[derive(Error, Debug)]
enum Error {
    #[error(&quot;request error: {0}&quot;)]
    ReqwestError(#[from] reqwest::Error),
    #[error(&quot;bad http response: {0}&quot;)]
    BadResponse(String),
}

#[derive(Debug)]
struct CrawlCommand {
    url: Url,
    extract_links: bool,
}

fn visit_page(client: &amp;Client, command: &amp;CrawlCommand) -&gt; Result&lt;Vec&lt;Url&gt;, Error&gt; {
    println!(&quot;Checking {:#}&quot;, command.url);
    let response = client.get(command.url.clone()).send()?;
    if !response.status().is_success() {
        return Err(Error::BadResponse(response.status().to_string()));
    }

    let mut link_urls = Vec::new();
    if !command.extract_links {
        return Ok(link_urls);
    }

    let base_url = response.url().to_owned();
    let body_text = response.text()?;
    let document = Html::parse_document(&amp;body_text);

    let selector = Selector::parse(&quot;a&quot;).unwrap();
    let href_values = document
        .select(&amp;selector)
        .filter_map(|element| element.value().attr(&quot;href&quot;));
    for href in href_values {
        match base_url.join(href) {
            Ok(link_url) =&gt; {
                link_urls.push(link_url);
            }
            Err(err) =&gt; {
                println!(&quot;On {base_url:#}: ignored unparsable {href:?}: {err}&quot;);
            }
        }
    }
    Ok(link_urls)
}

fn main() {
    let client = Client::new();
    let start_url = Url::parse(&quot;https://www.google.org&quot;).unwrap();
    let crawl_command = CrawlCommand{ url: start_url, extract_links: true };
    match visit_page(&amp;client, &amp;crawl_command) {
        Ok(links) =&gt; println!(&quot;Links: {links:#?}&quot;),
        Err(err) =&gt; println!(&quot;Could not extract links: {err:#}&quot;),
    }
}</code></pre></pre>
<p>Run the code in <code>src/main.rs</code> with</p>
<pre><code class="language-shell">cargo run
</code></pre>
<h2 id="tasks"><a class="header" href="#tasks">Tasks</a></h2>
<ul>
<li>Use threads to check the links in parallel: send the URLs to be checked to a
channel and let a few threads check the URLs in parallel.</li>
<li>Extend this to recursively extract links from all pages on the
<code>www.google.org</code> domain. Put an upper limit of 100 pages or so so that you
don‚Äôt end up being blocked by the site.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-rust"><a class="header" href="#async-rust">Async Rust</a></h1>
<p>‚ÄúAsync‚Äù is a concurrency model where multiple tasks are executed concurrently by
executing each task until it would block, then switching to another task that is
ready to make progress. The model allows running a larger number of tasks on a
limited number of threads. This is because the per-task overhead is typically
very low and operating systems provide primitives for efficiently identifying
I/O that is able to proceed.</p>
<p>Rust‚Äôs asynchronous operation is based on ‚Äúfutures‚Äù, which represent work that
may be completed in the future. Futures are ‚Äúpolled‚Äù until they signal that
they are complete.</p>
<p>Futures are polled by an async runtime, and several different runtimes are
available.</p>
<h2 id="‡¶§‡ßÅ‡¶≤‡¶®‡¶æ‡¶∏‡¶Æ‡ßÇ‡¶π"><a class="header" href="#‡¶§‡ßÅ‡¶≤‡¶®‡¶æ‡¶∏‡¶Æ‡ßÇ‡¶π">‡¶§‡ßÅ‡¶≤‡¶®‡¶æ‡¶∏‡¶Æ‡ßÇ‡¶π</a></h2>
<ul>
<li>
<p>Python has a similar model in its <code>asyncio</code>. However, its <code>Future</code> type is
callback-based, and not polled. Async Python programs require a ‚Äúloop‚Äù,
similar to a runtime in Rust.</p>
</li>
<li>
<p>JavaScript‚Äôs <code>Promise</code> is similar, but again callback-based. The language
runtime implements the event loop, so many of the details of Promise
resolution are hidden.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncawait"><a class="header" href="#asyncawait"><code>async</code>/<code>await</code></a></h1>
<p>At a high level, async Rust code looks very much like ‚Äúnormal‚Äù sequential code:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use futures::executor::block_on;

async fn count_to(count: i32) {
    for i in 1..=count {
        println!(&quot;Count is: {i}!&quot;);
    }
}

async fn async_main(count: i32) {
    count_to(count).await;
}

fn main() {
    block_on(async_main(10));
}</code></pre></pre>
<details>
<p>‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¶‡¶ø‡¶ï:</p>
<ul>
<li>
<p>Note that this is a simplified example to show the syntax. There is no long
running operation or any real concurrency in it!</p>
</li>
<li>
<p>What is the return type of an async call?</p>
<ul>
<li>Use <code>let future: () = async_main(10);</code> in <code>main</code> to see the type.</li>
</ul>
</li>
<li>
<p>The ‚Äúasync‚Äù keyword is syntactic sugar. The compiler replaces the return type
with a future. </p>
</li>
<li>
<p>You cannot make <code>main</code> async, without additional instructions to the compiler
on how to use the returned future.</p>
</li>
<li>
<p>You need an executor to run async code. <code>block_on</code> blocks the current thread
until the provided future has run to completion. </p>
</li>
<li>
<p><code>.await</code> asynchronously waits for the completion of another operation. Unlike
<code>block_on</code>, <code>.await</code> doesn‚Äôt block the current thread.</p>
</li>
<li>
<p><code>.await</code> can only be used inside an <code>async</code> function (or block; these are
introduced later). </p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="futures"><a class="header" href="#futures">Futures</a></h1>
<p><a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>
is a trait, implemented by objects that represent an operation that may not be
complete yet. A future can be polled, and <code>poll</code> returns a
<a href="https://doc.rust-lang.org/std/task/enum.Poll.html"><code>Poll</code></a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::Context;

pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}

pub enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}</span></code></pre></pre>
<p>An async function returns an <code>impl Future</code>. It‚Äôs also possible (but uncommon) to
implement <code>Future</code> for your own types. For example, the <code>JoinHandle</code> returned
from <code>tokio::spawn</code> implements <code>Future</code> to allow joining to it.</p>
<p>The <code>.await</code> keyword, applied to a Future, causes the current async function to
pause until that Future is ready, and then evaluates to its output.</p>
<details>
<ul>
<li>
<p>The <code>Future</code> and <code>Poll</code> types are implemented exactly as shown; click the
links to show the implementations in the docs.</p>
</li>
<li>
<p>We will not get to <code>Pin</code> and <code>Context</code>, as we will focus on writing async
code, rather than building new async primitives. Briefly:</p>
<ul>
<li>
<p><code>Context</code> allows a Future to schedule itself to be polled again when an
event occurs.</p>
</li>
<li>
<p><code>Pin</code> ensures that the Future isn‚Äôt moved in memory, so that pointers into
that future remain valid. This is required to allow references to remain
valid after an <code>.await</code>.</p>
</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtimes"><a class="header" href="#runtimes">Runtimes</a></h1>
<p>A <em>runtime</em> provides support for performing operations asynchronously (a
<em>reactor</em>) and is responsible for executing futures (an <em>executor</em>). Rust does not have a
‚Äúbuilt-in‚Äù runtime, but several options are available:</p>
<ul>
<li><a href="https://tokio.rs/">Tokio</a>: performant, with a well-developed ecosystem of
functionality like <a href="https://hyper.rs/">Hyper</a> for HTTP or
<a href="https://github.com/hyperium/tonic">Tonic</a> for gRPC.</li>
<li><a href="https://async.rs/">async-std</a>: aims to be a ‚Äústd for async‚Äù, and includes a
basic runtime in <code>async::task</code>.</li>
<li><a href="https://docs.rs/smol/latest/smol/">smol</a>: simple and lightweight</li>
</ul>
<p>Several larger applications have their own runtimes. For example,
<a href="https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-async/src/lib.rs">Fuchsia</a>
already has one.</p>
<details>
<ul>
<li>
<p>Note that of the listed runtimes, only Tokio is supported in the Rust
playground. The playground also does not permit any I/O, so most interesting
async things can‚Äôt run in the playground.</p>
</li>
<li>
<p>Futures are ‚Äúinert‚Äù in that they do not do anything (not even start an I/O
operation) unless there is an executor polling them. This differs from JS
Promises, for example, which will run to completion even if they are never
used.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokio"><a class="header" href="#tokio">Tokio</a></h1>
<p>Tokio provides: </p>
<ul>
<li>A multi-threaded runtime for executing asynchronous code.</li>
<li>An asynchronous version of the standard library.</li>
<li>A large ecosystem of libraries.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use tokio::time;

async fn count_to(count: i32) {
    for i in 1..=count {
        println!(&quot;Count in task: {i}!&quot;);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}

#[tokio::main]
async fn main() {
    tokio::spawn(count_to(10));

    for i in 1..5 {
        println!(&quot;Main task: {i}&quot;);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}</code></pre></pre>
<details>
<ul>
<li>
<p>With the <code>tokio::main</code> macro we can now make <code>main</code> async.</p>
</li>
<li>
<p>The <code>spawn</code> function creates a new, concurrent ‚Äútask‚Äù.</p>
</li>
<li>
<p>Note: <code>spawn</code> takes a <code>Future</code>, you don‚Äôt call <code>.await</code> on <code>count_to</code>.</p>
</li>
</ul>
<p><strong>Further exploration:</strong></p>
<ul>
<li>
<p>Why does <code>count_to</code> not (usually) get to 10? This is an example of async
cancellation. <code>tokio::spawn</code> returns a handle which can be awaited to wait
until it finishes.</p>
</li>
<li>
<p>Try <code>count_to(10).await</code> instead of spawning.</p>
</li>
<li>
<p>Try awaiting the task returned from <code>tokio::spawn</code>.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tasks-1"><a class="header" href="#tasks-1">Tasks</a></h1>
<p>Rust has a task system, which is a form of lightweight threading.</p>
<p>A task has a single top-level future which the executor polls to make progress.
That future may have one or more nested futures that its <code>poll</code> method polls,
corresponding loosely to a call stack. Concurrency within a task is possible by
polling multiple child futures, such as racing a timer and an I/O operation.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -&gt; io::Result&lt;()&gt; {
    let listener = TcpListener::bind(&quot;127.0.0.1:6142&quot;).await?;
	println!(&quot;listening on port 6142&quot;);

    loop {
        let (mut socket, addr) = listener.accept().await?;

        println!(&quot;connection from {addr:?}&quot;);

        tokio::spawn(async move {
            if let Err(e) = socket.write_all(b&quot;Who are you?\n&quot;).await {
                println!(&quot;socket error: {e:?}&quot;);
                return;
            }

            let mut buf = vec![0; 1024];
            let reply = match socket.read(&amp;mut buf).await {
                Ok(n) =&gt; {
                    let name = std::str::from_utf8(&amp;buf[..n]).unwrap().trim();
                    format!(&quot;Thanks for dialing in, {name}!\n&quot;)
                }
                Err(e) =&gt; {
                    println!(&quot;socket error: {e:?}&quot;);
                    return;
                }
            };

            if let Err(e) = socket.write_all(reply.as_bytes()).await {
                println!(&quot;socket error: {e:?}&quot;);
            }
        });
    }
}</code></pre></pre>
<details>
<p>Copy this example into your prepared <code>src/main.rs</code> and run it from there.</p>
<ul>
<li>
<p>Ask students to visualize what the state of the example server would be with a
few connected clients. What tasks exist? What are their Futures?</p>
</li>
<li>
<p>This is the first time we‚Äôve seen an <code>async</code> block. This is similar to a
closure, but does not take any arguments. Its return value is a Future,
similar to an <code>async fn</code>. </p>
</li>
<li>
<p>Refactor the async block into a function, and improve the error handling using <code>?</code>.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-channels"><a class="header" href="#async-channels">Async Channels</a></h1>
<p>Several crates have support for asynchronous channels. For instance <code>tokio</code>:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use tokio::sync::mpsc::{self, Receiver};

async fn ping_handler(mut input: Receiver&lt;()&gt;) {
    let mut count: usize = 0;

    while let Some(_) = input.recv().await {
        count += 1;
        println!(&quot;Received {count} pings so far.&quot;);
    }

    println!(&quot;ping_handler complete&quot;);
}

#[tokio::main]
async fn main() {
    let (sender, receiver) = mpsc::channel(32);
    let ping_handler_task = tokio::spawn(ping_handler(receiver));
    for i in 0..10 {
        sender.send(()).await.expect(&quot;Failed to send ping.&quot;);
        println!(&quot;Sent {} pings so far.&quot;, i + 1);
    }

    drop(sender);
    ping_handler_task.await.expect(&quot;Something went wrong in ping handler task.&quot;);
}</code></pre></pre>
<details>
<ul>
<li>
<p>Change the channel size to <code>3</code> and see how it affects the execution.</p>
</li>
<li>
<p>Overall, the interface is similar to the <code>sync</code> channels as seen in the
<a href="async/concurrency/channels.html">morning class</a>.</p>
</li>
<li>
<p>Try removing the <code>std::mem::drop</code> call. What happens? Why?</p>
</li>
<li>
<p>The <a href="https://docs.rs/flume/latest/flume/">Flume</a> crate has channels that
implement both <code>sync</code> and <code>async</code> <code>send</code> and <code>recv</code>. This can be convenient
for complex applications with both IO and heavy CPU processing tasks.</p>
</li>
<li>
<p>What makes working with <code>async</code> channels preferable is the ability to combine
them with other <code>future</code>s to combine them and create complex control flow.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="futures-control-flow"><a class="header" href="#futures-control-flow">Futures Control Flow</a></h1>
<p>Futures can be combined together to produce concurrent compute flow graphs. We
have already seen tasks, that function as independent threads of execution.</p>
<ul>
<li><a href="async/control-flow/join.html">Join</a></li>
<li><a href="async/control-flow/select.html">Select</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="join"><a class="header" href="#join">Join</a></h1>
<p>A join operation waits until all of a set of futures are ready, and
returns a collection of their results. This is similar to <code>Promise.all</code> in
JavaScript or <code>asyncio.gather</code> in Python.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use anyhow::Result;
use futures::future;
use reqwest;
use std::collections::HashMap;

async fn size_of_page(url: &amp;str) -&gt; Result&lt;usize&gt; {
    let resp = reqwest::get(url).await?;
    Ok(resp.text().await?.len())
}

#[tokio::main]
async fn main() {
    let urls: [&amp;str; 4] = [
        &quot;https://google.com&quot;,
        &quot;https://httpbin.org/ip&quot;,
        &quot;https://play.rust-lang.org/&quot;,
        &quot;BAD_URL&quot;,
    ];
    let futures_iter = urls.into_iter().map(size_of_page);
    let results = future::join_all(futures_iter).await;
    let page_sizes_dict: HashMap&lt;&amp;str, Result&lt;usize&gt;&gt; =
        urls.into_iter().zip(results.into_iter()).collect();
    println!(&quot;{:?}&quot;, page_sizes_dict);
}</code></pre></pre>
<details>
<p>Copy this example into your prepared <code>src/main.rs</code> and run it from there.</p>
<ul>
<li>
<p>For multiple futures of disjoint types, you can use <code>std::future::join!</code> but
you must know how many futures you will have at compile time. This is
currently in the <code>futures</code> crate, soon to be stabilised in <code>std::future</code>.</p>
</li>
<li>
<p>The risk of <code>join</code> is that one of the futures may never resolve, this would
cause your program to stall. </p>
</li>
<li>
<p>You can also combine <code>join_all</code> with <code>join!</code> for instance to join all requests
to an http service as well as a database query. Try adding a
<code>tokio::time::sleep</code> to the future, using <code>futures::join!</code>. This is not a
timeout (that requires <code>select!</code>, explained in the next chapter), but demonstrates <code>join!</code>.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="select"><a class="header" href="#select">Select</a></h1>
<p>A select operation waits until any of a set of futures is ready, and responds to
that future‚Äôs result. In JavaScript, this is similar to <code>Promise.race</code>. In
Python, it compares to <code>asyncio.wait(task_set, return_when=asyncio.FIRST_COMPLETED)</code>.</p>
<p>Similar to a match statement, the body of <code>select!</code> has a number of arms, each
of the form <code>pattern = future =&gt; statement</code>. When the <code>future</code> is ready, the
<code>statement</code> is executed with the variables in <code>pattern</code> bound to the <code>future</code>‚Äôs
result.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use tokio::sync::mpsc::{self, Receiver};
use tokio::time::{sleep, Duration};

#[derive(Debug, PartialEq)]
enum Animal {
    Cat { name: String },
    Dog { name: String },
}

async fn first_animal_to_finish_race(
    mut cat_rcv: Receiver&lt;String&gt;,
    mut dog_rcv: Receiver&lt;String&gt;,
) -&gt; Option&lt;Animal&gt; {
    tokio::select! {
        cat_name = cat_rcv.recv() =&gt; Some(Animal::Cat { name: cat_name? }),
        dog_name = dog_rcv.recv() =&gt; Some(Animal::Dog { name: dog_name? })
    }
}

#[tokio::main]
async fn main() {
    let (cat_sender, cat_receiver) = mpsc::channel(32);
    let (dog_sender, dog_receiver) = mpsc::channel(32);
    tokio::spawn(async move {
        sleep(Duration::from_millis(500)).await;
        cat_sender
            .send(String::from(&quot;Felix&quot;))
            .await
            .expect(&quot;Failed to send cat.&quot;);
    });
    tokio::spawn(async move {
        sleep(Duration::from_millis(50)).await;
        dog_sender
            .send(String::from(&quot;Rex&quot;))
            .await
            .expect(&quot;Failed to send dog.&quot;);
    });

    let winner = first_animal_to_finish_race(cat_receiver, dog_receiver)
        .await
        .expect(&quot;Failed to receive winner&quot;);

    println!(&quot;Winner is {winner:?}&quot;);
}</code></pre></pre>
<details>
<ul>
<li>
<p>In this example, we have a race between a cat and a dog.
<code>first_animal_to_finish_race</code> listens to both channels and will pick whichever
arrives first. Since the dog takes 50ms, it wins against the cat that
take 500ms seconds.</p>
</li>
<li>
<p>You can use <code>oneshot</code> channels in this example as the channels are supposed to
receive only one <code>send</code>.</p>
</li>
<li>
<p>Try adding a deadline to the race, demonstrating selecting different sorts of
futures.</p>
</li>
<li>
<p>Note that <code>select!</code> drops unmatched branches, which cancels their futures.
It is easiest to use when every execution of <code>select!</code> creates new futures.</p>
<ul>
<li>An alternative is to pass <code>&amp;mut future</code> instead of the future itself, but
this can lead to issues, further discussed in the pinning slide.</li>
</ul>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pitfalls-of-asyncawait"><a class="header" href="#pitfalls-of-asyncawait">Pitfalls of async/await</a></h1>
<p>Async / await provides convenient and efficient abstraction for concurrent asynchronous programming. However, the async/await model in Rust also comes with its share of pitfalls and footguns. We illustrate some of them in this chapter:</p>
<ul>
<li><a href="async/pitfalls/blocking-executor.html">Blocking the Executor</a></li>
<li><a href="async/pitfalls/pin.html">Pin</a></li>
<li><a href="async/pitfalls/async-traits.html">Async Traits</a></li>
<li><a href="async/pitfalls/cancellation.html">Cancellation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocking-the-executor"><a class="header" href="#blocking-the-executor">Blocking the executor</a></h1>
<p>Most async runtimes only allow IO tasks to run concurrently.
This means that CPU blocking tasks will block the executor and prevent other tasks from being executed.
An easy workaround is to use async equivalent methods where possible.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use futures::future::join_all;
use std::time::Instant;

async fn sleep_ms(start: &amp;Instant, id: u64, duration_ms: u64) {
    std::thread::sleep(std::time::Duration::from_millis(duration_ms));
    println!(
        &quot;future {id} slept for {duration_ms}ms, finished after {}ms&quot;,
        start.elapsed().as_millis()
    );
}

#[tokio::main(flavor = &quot;current_thread&quot;)]
async fn main() {
    let start = Instant::now();
    let sleep_futures = (1..=10).map(|t| sleep_ms(&amp;start, t, t * 10));
    join_all(sleep_futures).await;
}</code></pre></pre>
<details>
<ul>
<li>
<p>Run the code and see that the sleeps happen consecutively rather than
concurrently.</p>
</li>
<li>
<p>The <code>&quot;current_thread&quot;</code> flavor puts all tasks on a single thread. This makes the
effect more obvious, but the bug is still present in the multi-threaded
flavor.</p>
</li>
<li>
<p>Switch the <code>std::thread::sleep</code> to <code>tokio::time::sleep</code> and await its result.</p>
</li>
<li>
<p>Another fix would be to <code>tokio::task::spawn_blocking</code> which spawns an actual
thread and transforms its handle into a future without blocking the executor.</p>
</li>
<li>
<p>You should not think of tasks as OS threads. They do not map 1 to 1 and most
executors will allow many tasks to run on a single OS thread. This is
particularly problematic when interacting with other libraries via FFI, where
that library might depend on thread-local storage or map to specific OS
threads (e.g., CUDA). Prefer <code>tokio::task::spawn_blocking</code> in such situations.</p>
</li>
<li>
<p>Use sync mutexes with care. Holding a mutex over an <code>.await</code> may cause another
task to block, and that task may be running on the same thread.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pin"><a class="header" href="#pin">Pin</a></h1>
<p>When you await a future, all local variables (that would ordinarily be stored on
a stack frame) are instead stored in the Future for the current async block. If your
future has pointers to data on the stack, those pointers might get invalidated.
This is unsafe.</p>
<p>Therefore, you must guarantee that the addresses your future points to don‚Äôt
change. That is why we need to <code>pin</code> futures. Using the same future repeatedly
in a <code>select!</code> often leads to issues with pinned values.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use tokio::sync::{mpsc, oneshot};
use tokio::task::spawn;
use tokio::time::{sleep, Duration};

// A work item. In this case, just sleep for the given time and respond
// with a message on the `respond_on` channel.
#[derive(Debug)]
struct Work {
    input: u32,
    respond_on: oneshot::Sender&lt;u32&gt;,
}

// A worker which listens for work on a queue and performs it.
async fn worker(mut work_queue: mpsc::Receiver&lt;Work&gt;) {
    let mut iterations = 0;
    loop {
        tokio::select! {
            Some(work) = work_queue.recv() =&gt; {
                sleep(Duration::from_millis(10)).await; // Pretend to work.
                work.respond_on
                    .send(work.input * 1000)
                    .expect(&quot;failed to send response&quot;);
                iterations += 1;
            }
            // TODO: report number of iterations every 100ms
        }
    }
}

// A requester which requests work and waits for it to complete.
async fn do_work(work_queue: &amp;mpsc::Sender&lt;Work&gt;, input: u32) -&gt; u32 {
    let (tx, rx) = oneshot::channel();
    work_queue
        .send(Work {
            input,
            respond_on: tx,
        })
        .await
        .expect(&quot;failed to send on work queue&quot;);
    rx.await.expect(&quot;failed waiting for response&quot;)
}

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(10);
    spawn(worker(rx));
    for i in 0..100 {
        let resp = do_work(&amp;tx, i).await;
        println!(&quot;work result for iteration {i}: {resp}&quot;);
    }
}</code></pre></pre>
<details>
<ul>
<li>
<p>You may recognize this as an example of the actor pattern. Actors
typically call <code>select!</code> in a loop.</p>
</li>
<li>
<p>This serves as a summation of a few of the previous lessons, so take your time
with it.</p>
<ul>
<li>
<p>Naively add a <code>_ = sleep(Duration::from_millis(100)) =&gt; { println!(..) }</code>
to the <code>select!</code>. This will never execute. Why?</p>
</li>
<li>
<p>Instead, add a <code>timeout_fut</code> containing that future outside of the <code>loop</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut timeout_fut = sleep(Duration::from_millis(100));
loop {
    select! {
        ..,
        _ = timeout_fut =&gt; { println!(..); },
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>This still doesn‚Äôt work. Follow the compiler errors, adding <code>&amp;mut</code> to the
<code>timeout_fut</code> in the <code>select!</code> to work around the move, then using
<code>Box::pin</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));
loop {
    select! {
        ..,
        _ = &amp;mut timeout_fut =&gt; { println!(..); },
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>This compiles, but once the timeout expires it is <code>Poll::Ready</code> on every
iteration (a fused future would help with this). Update to reset
<code>timeout_fut</code> every time it expires.</p>
</li>
</ul>
</li>
<li>
<p>Box allocates on the heap. In some cases, <code>std::pin::pin!</code> (only recently
stabilized, with older code often using <code>tokio::pin!</code>) is also an option, but
that is difficult to use for a future that is reassigned.</p>
</li>
<li>
<p>Another alternative is to not use <code>pin</code> at all but spawn another task that will send to a <code>oneshot</code> channel every 100ms.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-traits"><a class="header" href="#async-traits">Async Traits</a></h1>
<p>Async methods in traits are not yet supported in the stable channel (<a href="https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html">An experimental feature exists in nightly and should be stabilized in the mid term.</a>)</p>
<p>The crate <a href="https://docs.rs/async-trait/latest/async_trait/">async_trait</a> provides a workaround through a macro:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use async_trait::async_trait;
use std::time::Instant;
use tokio::time::{sleep, Duration};

#[async_trait]
trait Sleeper {
    async fn sleep(&amp;self);
}

struct FixedSleeper {
    sleep_ms: u64,
}

#[async_trait]
impl Sleeper for FixedSleeper {
    async fn sleep(&amp;self) {
        sleep(Duration::from_millis(self.sleep_ms)).await;
    }
}

async fn run_all_sleepers_multiple_times(sleepers: Vec&lt;Box&lt;dyn Sleeper&gt;&gt;, n_times: usize) {
    for _ in 0..n_times {
        println!(&quot;running all sleepers..&quot;);
        for sleeper in &amp;sleepers {
            let start = Instant::now();
            sleeper.sleep().await;
            println!(&quot;slept for {}ms&quot;, start.elapsed().as_millis());
        }
    }
}

#[tokio::main]
async fn main() {
    let sleepers: Vec&lt;Box&lt;dyn Sleeper&gt;&gt; = vec![
        Box::new(FixedSleeper { sleep_ms: 50 }),
        Box::new(FixedSleeper { sleep_ms: 100 }),
    ];
    run_all_sleepers_multiple_times(sleepers, 5).await;
}</code></pre></pre>
<details>  
<ul>
<li>
<p><code>async_trait</code> is easy to use, but note that it‚Äôs using heap allocations to
achieve this. This heap allocation has performance overhead.</p>
</li>
<li>
<p>The challenges in language support for <code>async trait</code> are deep Rust and
probably not worth describing in-depth. Niko Matsakis did a good job of
explaining them in <a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">this
post</a>
if you are interested in digging deeper.</p>
</li>
<li>
<p>Try creating a new sleeper struct that will sleep for a random amount of time
and adding it to the Vec.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cancellation"><a class="header" href="#cancellation">Cancellation</a></h1>
<p>Dropping a future implies it can never be polled again. This is called <em>cancellation</em>
and it can occur at any <code>await</code> point. Care is needed to ensure the system works
correctly even when futures are cancelled. For example, it shouldn‚Äôt deadlock or
lose data.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::io::{self, ErrorKind};
use std::time::Duration;
use tokio::io::{AsyncReadExt, AsyncWriteExt, DuplexStream};

struct LinesReader {
    stream: DuplexStream,
}

impl LinesReader {
    fn new(stream: DuplexStream) -&gt; Self {
        Self { stream }
    }

    async fn next(&amp;mut self) -&gt; io::Result&lt;Option&lt;String&gt;&gt; {
        let mut bytes = Vec::new();
        let mut buf = [0];
        while self.stream.read(&amp;mut buf[..]).await? != 0 {
            bytes.push(buf[0]);
            if buf[0] == b'\n' {
                break;
            }
        }
        if bytes.is_empty() {
            return Ok(None)
        }
        let s = String::from_utf8(bytes)
            .map_err(|_| io::Error::new(ErrorKind::InvalidData, &quot;not UTF-8&quot;))?;
        Ok(Some(s))
    }
}

async fn slow_copy(source: String, mut dest: DuplexStream) -&gt; std::io::Result&lt;()&gt; {
    for b in source.bytes() {
        dest.write_u8(b).await?;
        tokio::time::sleep(Duration::from_millis(10)).await
    }
    Ok(())
}

#[tokio::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let (client, server) = tokio::io::duplex(5);
    let handle = tokio::spawn(slow_copy(&quot;hi\nthere\n&quot;.to_owned(), client));

    let mut lines = LinesReader::new(server);
    let mut interval = tokio::time::interval(Duration::from_millis(60));
    loop {
        tokio::select! {
            _ = interval.tick() =&gt; println!(&quot;tick!&quot;),
            line = lines.next() =&gt; if let Some(l) = line? {
                print!(&quot;{}&quot;, l)
            } else {
                break
            },
        }
    }
    handle.await.unwrap()?;
    Ok(())
}</code></pre></pre>
<details>
<ul>
<li>
<p>The compiler doesn‚Äôt help with cancellation-safety. You need to read API
documentation and consider what state your <code>async fn</code> holds.</p>
</li>
<li>
<p>Unlike <code>panic</code> and <code>?</code>, cancellation is part of normal control flow
(vs error-handling).</p>
</li>
<li>
<p>The example loses parts of the string.</p>
<ul>
<li>
<p>Whenever the <code>tick()</code> branch finishes first, <code>next()</code> and its <code>buf</code> are dropped.</p>
</li>
<li>
<p><code>LinesReader</code> can be made cancellation-safe by makeing <code>buf</code> part of the struct:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LinesReader {
    stream: DuplexStream,
    bytes: Vec&lt;u8&gt;,
    buf: [u8; 1],
}

impl LinesReader {
    fn new(stream: DuplexStream) -&gt; Self {
        Self { stream, bytes: Vec::new(), buf: [0] }
    }
    async fn next(&amp;mut self) -&gt; io::Result&lt;Option&lt;String&gt;&gt; {
        // prefix buf and bytes with self.
        // ...
        let raw = std::mem::take(&amp;mut self.bytes);
        let s = String::from_utf8(raw)
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/time/struct.Interval.html#method.tick"><code>Interval::tick</code></a>
is cancellation-safe because it keeps track of whether a tick has been ‚Äòdelivered‚Äô.</p>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncReadExt.html#method.read"><code>AsyncReadExt::read</code></a>
is cancellation-safe because it either returns or doesn‚Äôt read data.</p>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncBufReadExt.html#method.read_line"><code>AsyncBufReadExt::read_line</code></a>
is similar to the example and <em>isn‚Äôt</em> cancellation-safe. See its documentation
for details and alternatives.</p>
</li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises-4"><a class="header" href="#exercises-4">Exercises</a></h1>
<p>To practice your Async Rust skills, we have again two exercises for you:</p>
<ul>
<li>
<p>Dining philosophers: we already saw this problem in the morning. This time
you are going to implement it with Async Rust.</p>
</li>
<li>
<p>A Broadcast Chat Application: this is a larger project that allows you
experiment with more advanced Async Rust features.</p>
</li>
</ul>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/concurrency/solutions-afternoon.html">solutions</a> provided.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dining-philosophers---async"><a class="header" href="#dining-philosophers---async">Dining Philosophers - Async</a></h1>
<p>See <a href="exercises/concurrency/dining-philosophers.html">dining philosophers</a> for a description of the
problem.</p>
<p>As before, you will need a local
<a href="cargo/running-locally.html">Cargo installation</a> for this exercise. Copy
the code below to a file called <code>src/main.rs</code>, fill out the blanks, and test
that <code>cargo run</code> does not deadlock:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use std::sync::Arc;
use tokio::time;
use tokio::sync::mpsc::{self, Sender};
use tokio::sync::Mutex;

struct Fork;

struct Philosopher {
    name: String,
    // left_fork: ...
    // right_fork: ...
    // thoughts: ...
}

impl Philosopher {
    async fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name)).await
            .unwrap();
    }

    async fn eat(&amp;self) {
        // Pick up forks...
        println!(&quot;{} is eating...&quot;, &amp;self.name);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Thales&quot;, &quot;Pythagoras&quot;];

#[tokio::main]
async fn main() {
    // Create forks

    // Create philosophers

    // Make them think and eat

    // Output their thoughts
}</code></pre></pre>
<p>Since this time you are using Async Rust, you‚Äôll need a <code>tokio</code> dependency.
You can use the following <code>Cargo.toml</code>:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;dining-philosophers-async-dine&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
tokio = {version = &quot;1.26.0&quot;, features = [&quot;sync&quot;, &quot;time&quot;, &quot;macros&quot;, &quot;rt-multi-thread&quot;]}
</code></pre>
<p>Also note that this time you have to use the <code>Mutex</code> and the <code>mpsc</code> module
from the <code>tokio</code> crate.</p>
<details>
<ul>
<li>Can you make your implementation single-threaded? </li>
</ul>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="broadcast-chat-application"><a class="header" href="#broadcast-chat-application">Broadcast Chat Application</a></h1>
<p>In this exercise, we want to use our new knowledge to implement a broadcast
chat application. We have a chat server that the clients connect to and publish
their messages. The client reads user messages from the standard input, and
sends them to the server. The chat server broadcasts each message that it
receives to all the clients.</p>
<p>For this, we use <a href="https://docs.rs/tokio/latest/tokio/sync/broadcast/fn.channel.html">a broadcast channel</a> on the server, and
<a href="https://docs.rs/tokio-websockets/0.3.2/tokio_websockets/"><code>tokio_websockets</code></a> for the communication between the client and the
server.</p>
<p>Create a new Cargo project and add the following dependencies:</p>
<p><code>Cargo.toml</code>:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;chat-async&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
futures-util = &quot;0.3.28&quot;
http = &quot;0.2.9&quot;
tokio = { version = &quot;1.28.1&quot;, features = [&quot;full&quot;] }
tokio-websockets = &quot;0.3.2&quot;
</code></pre>
<h2 id="the-required-apis"><a class="header" href="#the-required-apis">The required APIs</a></h2>
<p>You are going to need the following functions from <code>tokio</code> and
<a href="https://docs.rs/tokio-websockets/0.3.2/tokio_websockets/"><code>tokio_websockets</code></a>. Spend a few minutes to familiarize yourself with the
API. </p>
<ul>
<li><a href="https://docs.rs/tokio-websockets/0.3.2/tokio_websockets/proto/struct.WebsocketStream.html#method.next">WebsocketStream::next()</a>: for asynchronously reading messages from a
Websocket Stream.</li>
<li><a href="https://docs.rs/futures-util/0.3.28/futures_util/sink/trait.SinkExt.html#method.send">SinkExt::send()</a> implemented by <code>WebsocketStream</code>: for asynchronously
sending messages on a Websocket Stream.</li>
<li><a href="https://docs.rs/tokio/latest/tokio/io/struct.Lines.html#method.next_line">Lines::next_line()</a>: for asynchronously reading user messages
from the standard input.</li>
<li><a href="https://docs.rs/tokio/latest/tokio/sync/broadcast/struct.Sender.html#method.subscribe">Sender::subscribe()</a>: for subscribing to a broadcast channel.</li>
</ul>
<h2 id="two-binaries"><a class="header" href="#two-binaries">Two binaries</a></h2>
<p>Normally in a Cargo project, you can have only one binary, and one
<code>src/main.rs</code> file. In this project, we need two binaries. One for the client,
and one for the server. You could potentially make them two separate Cargo
projects, but we are going to put them in a single Cargo project with two
binaries. For this to work, the client and the server code should go under
<code>src/bin</code> (see the <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">documentation</a>). </p>
<p>Copy the following server and client code into <code>src/bin/server.rs</code> and
<code>src/bin/client.rs</code>, respectively. Your task is to complete these files as
described below. </p>
<p><code>src/bin/server.rs</code>:</p>
<!-- File src/bin/server.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use futures_util::sink::SinkExt;
use std::error::Error;
use std::net::SocketAddr;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::broadcast::{channel, Sender};
use tokio_websockets::{Message, ServerBuilder, WebsocketStream};

async fn handle_connection(
    addr: SocketAddr,
    mut ws_stream: WebsocketStream&lt;TcpStream&gt;,
    bcast_tx: Sender&lt;String&gt;,
) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {

    // TODO: For a hint, see the description of the task below.

}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let (bcast_tx, _) = channel(16);

    let listener = TcpListener::bind(&quot;127.0.0.1:2000&quot;).await?;
    println!(&quot;listening on port 2000&quot;);

    loop {
        let (socket, addr) = listener.accept().await?;
        println!(&quot;New connection from {addr:?}&quot;);
        let bcast_tx = bcast_tx.clone();
        tokio::spawn(async move {
            // Wrap the raw TCP stream into a websocket.
            let ws_stream = ServerBuilder::new().accept(socket).await?;

            handle_connection(addr, ws_stream, bcast_tx).await
        });
    }
}</code></pre></pre>
<p><code>src/bin/client.rs</code>:</p>
<!-- File src/bin/client.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">use futures_util::SinkExt;
use http::Uri;
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio_websockets::{ClientBuilder, Message};

#[tokio::main]
async fn main() -&gt; Result&lt;(), tokio_websockets::Error&gt; {
    let mut ws_stream = ClientBuilder::from_uri(Uri::from_static(&quot;ws://127.0.0.1:2000&quot;))
        .connect()
        .await?;

    let stdin = tokio::io::stdin();
    let mut stdin = BufReader::new(stdin).lines();


    // TODO: For a hint, see the description of the task below.

}</code></pre></pre>
<h2 id="running-the-binaries"><a class="header" href="#running-the-binaries">Running the binaries</a></h2>
<p>Run the server with:</p>
<pre><code class="language-shell">cargo run --bin server
</code></pre>
<p>and the client with:</p>
<pre><code class="language-shell">cargo run --bin client
</code></pre>
<h2 id="tasks-2"><a class="header" href="#tasks-2">Tasks</a></h2>
<ul>
<li>Implement the <code>handle_connection</code> function in <code>src/bin/server.rs</code>.
<ul>
<li>Hint: Use <code>tokio::select!</code> for concurrently performing two tasks in a
continuous loop. One task receives messages from the client and broadcasts
them. The other sends messages received by the server to the client.</li>
</ul>
</li>
<li>Complete the main function in <code>src/bin/client.rs</code>.
<ul>
<li>Hint: As before, use <code>tokio::select!</code> in a continuous loop for concurrently
performing two tasks: (1) reading user messages from standard input and
sending them to the server, and (2) receiving messages from the server, and
displaying them for the user.</li>
</ul>
</li>
<li>Optional: Once you are done, change the code to broadcast messages to all
clients, but the sender of the message.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶ß‡¶®‡¶Ø‡¶¨‡¶æ‡¶¶"><a class="header" href="#‡¶ß‡¶®‡¶Ø‡¶¨‡¶æ‡¶¶">‡¶ß‡¶®‡ßç‡¶Ø‡¶¨‡¶æ‡¶¶!</a></h1>
<p>Comprehensive Rust ü¶Ä ‡¶ï‡ßã‡¶∞‡ßç‡¶∏‡¶ü‡¶ø ‡¶®‡ßá‡¶ì‡ßü‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶ß‡¶®‡ßç‡¶Ø‡¶¨‡¶æ‡¶¶! ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶Ü‡¶∂‡¶æ ‡¶ï‡¶∞‡¶ø ‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶ü‡¶ø ‡¶â‡¶™‡¶≠‡ßã‡¶ó ‡¶ï‡¶∞‡ßá‡¶õ‡ßá‡¶® ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ü‡¶ø
‡¶â‡¶™‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶õ‡¶ø‡¶≤‡ßã‡•§</p>
<p>We‚Äôve had a lot of fun putting the course together. The course is not perfect,
so if you spotted any mistakes or have ideas for improvements, please get in
<a href="https://github.com/google/comprehensive-rust/discussions">contact with us on
GitHub</a>. We would love
to hear from you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-rust-resources"><a class="header" href="#other-rust-resources">Other Rust Resources</a></h1>
<p>The Rust community has created a wealth of high-quality and free resources
online.</p>
<h2 id="‡¶Ö‡¶´‡¶ø‡¶∏‡¶ø‡¶Ø‡¶æ‡¶≤-‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡¶ü‡ßá‡¶∂‡¶®"><a class="header" href="#‡¶Ö‡¶´‡¶ø‡¶∏‡¶ø‡¶Ø‡¶æ‡¶≤-‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡¶ü‡ßá‡¶∂‡¶®">‡¶Ö‡¶´‡¶ø‡¶∏‡¶ø‡¶Ø‡¶º‡¶æ‡¶≤ ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶®</a></h2>
<p>The Rust project hosts many resources. These cover Rust in general:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a>: the
canonical free book about Rust. Covers the language in detail and includes a
few projects for people to build.</li>
<li><a href="https://doc.rust-lang.org/rust-by-example/">Rust By Example</a>: covers the Rust
syntax via a series of examples which showcase different constructs. Sometimes
includes small exercises where you are asked to expand on the code in the
examples.</li>
<li><a href="https://doc.rust-lang.org/std/">Rust Standard Library</a>: full documentation of
the standard library for Rust.</li>
<li><a href="https://doc.rust-lang.org/reference/">The Rust Reference</a>: an incomplete book
which describes the Rust grammar and memory model.</li>
</ul>
<p>More specialized guides hosted on the official Rust site:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/">The Rustonomicon</a>: covers unsafe Rust,
including working with raw pointers and interfacing with other languages
(FFI).</li>
<li><a href="https://rust-lang.github.io/async-book/">Asynchronous Programming in Rust</a>:
covers the new asynchronous programming model which was introduced after the
Rust Book was written.</li>
<li><a href="https://doc.rust-lang.org/stable/embedded-book/">The Embedded Rust Book</a>: an
introduction to using Rust on embedded devices without an operating system.</li>
</ul>
<h2 id="unofficial-learning-material"><a class="header" href="#unofficial-learning-material">Unofficial Learning Material</a></h2>
<p>A small selection of other guides and tutorial for Rust:</p>
<ul>
<li><a href="http://cliffle.com/p/dangerust/">Learn Rust the Dangerous Way</a>: covers Rust
from the perspective of low-level C programmers.</li>
<li><a href="https://docs.opentitan.org/doc/ug/rust_for_c/">Rust for Embedded C
Programmers</a>: covers Rust from
the perspective of developers who write firmware in C.</li>
<li><a href="https://overexact.com/rust-for-professionals/">Rust for professionals</a>:
covers the syntax of Rust using side-by-side comparisons with other languages
such as C, C++, Java, JavaScript, and Python.</li>
<li><a href="https://exercism.org/tracks/rust">Rust on Exercism</a>: 100+ exercises to help
you learn Rust.</li>
<li><a href="https://ferrous-systems.github.io/teaching-material/index.html">Ferrous Teaching
Material</a>: a
series of small presentations covering both basic and advanced part of the
Rust language. Other topics such as WebAssembly, and async/await are also
covered.</li>
<li><a href="https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/">Beginner‚Äôs Series to
Rust</a> and
<a href="https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/">Take your first steps with
Rust</a>: two
Rust guides aimed at new developers. The first is a set of 35 videos and the
second is a set of 11 modules which covers Rust syntax and basic constructs.</li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/">Learn Rust With Entirely Too Many Linked
Lists</a>: in-depth
exploration of Rust‚Äôs memory management rules, through implementing a few
different types of list structures.</li>
</ul>
<p>Please see the <a href="https://lborb.github.io/book/">Little Book of Rust Books</a> for
even more Rust books.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="credits"><a class="header" href="#credits">Credits</a></h1>
<p>The material here builds on top of the many great sources of Rust documentation.
See the page on <a href="other-resources.html">other resources</a> for a full list of useful
resources.</p>
<p>The material of Comprehensive Rust is licensed under the terms of the Apache 2.0
license, please see
<a href="https://github.com/google/comprehensive-rust/blob/main/LICENSE"><code>LICENSE</code></a> for
details.</p>
<h2 id="‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡ßá‡¶∞-‡¶Æ‡¶æ‡¶ß‡¶Ø‡¶Æ‡ßá-‡¶∞‡¶æ‡¶∏‡¶ü"><a class="header" href="#‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡ßá‡¶∞-‡¶Æ‡¶æ‡¶ß‡¶Ø‡¶Æ‡ßá-‡¶∞‡¶æ‡¶∏‡¶ü">‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá ‡¶∞‡¶æ‡¶∏‡ßç‡¶ü</a></h2>
<p>Some examples and exercises have been copied and adapted from <a href="https://doc.rust-lang.org/rust-by-example/">Rust by
Example</a>. Please see the
<code>third_party/rust-by-example/</code> directory for details, including the license
terms.</p>
<h2 id="‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®‡ßá-‡¶∞‡¶æ‡¶∏‡¶ü"><a class="header" href="#‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®‡ßá-‡¶∞‡¶æ‡¶∏‡¶ü">‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®‡ßá ‡¶∞‡¶æ‡¶∏‡ßç‡¶ü</a></h2>
<p>Some exercises have been copied and adapted from <a href="https://exercism.org/tracks/rust">Rust on
Exercism</a>. Please see the
<code>third_party/rust-on-exercism/</code> directory for details, including the license
terms.</p>
<h2 id="cxx"><a class="header" href="#cxx">CXX</a></h2>
<p>The <a href="android/interoperability/cpp.html">Interoperability with C++</a> section uses an
image from <a href="https://cxx.rs/">CXX</a>. Please see the <code>third_party/cxx/</code> directory
for details, including the license terms.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®‡¶∏‡¶Æ‡ßÇ‡¶π"><a class="header" href="#‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®‡¶∏‡¶Æ‡ßÇ‡¶π">‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®‡¶∏‡¶Æ‡ßÇ‡¶π</a></h1>
<p>‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®‡ßÄ‡¶∞ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® ‡¶è‡¶á ‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ‡¶ó‡ßÅ‡¶≤‡ßã‡¶§‡ßá ‡¶ñ‡ßÅ‡¶ú‡ßá ‡¶™‡¶æ‡¶¨‡ßá‡¶®‡•§</p>
<p>Feel free to ask questions about the solutions <a href="https://github.com/google/comprehensive-rust/discussions">on
GitHub</a>. Let us know
if you have a different or better solution than what is presented here.</p>
<blockquote>
<p><strong>Note:</strong> Please ignore the <code>// ANCHOR: label</code> and <code>// ANCHOR_END: label</code>
comments you see in the solutions. They are there to make it possible to
re-use parts of the solutions as the exercises.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‡¶™‡¶∞‡¶•‡¶Æ-‡¶¶‡¶ø‡¶®‡¶É-‡¶∏‡¶ï‡¶æ‡¶≤‡ßá‡¶∞-‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®-1"><a class="header" href="#‡¶™‡¶∞‡¶•‡¶Æ-‡¶¶‡¶ø‡¶®‡¶É-‡¶∏‡¶ï‡¶æ‡¶≤‡ßá‡¶∞-‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®-1">‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶¶‡¶ø‡¶®‡¶É ‡¶∏‡¶ï‡¶æ‡¶≤‡ßá‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶∂‡ßÄ‡¶≤‡¶®</a></h1>
<h2 id="arrays-and-for-loops-1"><a class="header" href="#arrays-and-for-loops-1">Arrays and <code>for</code> Loops</a></h2>
<p>(<a href="exercises/day-1/for-loops.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust edition2021">// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: transpose
fn transpose(matrix: [[i32; 3]; 3]) -&gt; [[i32; 3]; 3] {
    // ANCHOR_END: transpose
    let mut result = [[0; 3]; 3];
    for i in 0..3 {
        for j in 0..3 {
            result[j][i] = matrix[i][j];
        }
    }
    return result;
}

// ANCHOR: pretty_print
fn pretty_print(matrix: &amp;[[i32; 3]; 3]) {
    // ANCHOR_END: pretty_print
    for row in matrix {
        println!(&quot;{row:?}&quot;);
    }
}

// ANCHOR: tests
#[test]
fn test_transpose() {
    let matrix = [
        [101, 102, 103], //
        [201, 202, 203],
        [301, 302, 303],
    ];
    let transposed = transpose(matrix);
    assert_eq!(
        transposed,
        [
            [101, 201, 301], //
            [102, 202, 302],
            [103, 203, 303],
        ]
    );
}
// ANCHOR_END: tests

// ANCHOR: main
fn main() {
    let matrix = [
        [101, 102, 103], // &lt;-- the comment makes rustfmt add a newline
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!(&quot;matrix:&quot;);
    pretty_print(&amp;matrix);

    let transposed = transpose(matrix);
    println!(&quot;transposed:&quot;);
    pretty_print(&amp;transposed);
}</code></pre></pre>
<h3 id="bonus-question-1"><a class="header" href="#bonus-question-1">Bonus question</a></h3>
<p>It requires more advanced concepts. It might seem that we could use a slice-of-slices (<code>&amp;[&amp;[i32]]</code>) as the input type to transpose and thus make our function handle any size of matrix. However, this quickly breaks down: the return type cannot be <code>&amp;[&amp;[i32]]</code> since it needs to own the data you return.</p>
<p>You can attempt to use something like <code>Vec&lt;Vec&lt;i32&gt;&gt;</code>, but this doesn‚Äôt work out-of-the-box either: it‚Äôs hard to convert from <code>Vec&lt;Vec&lt;i32&gt;&gt;</code> to <code>&amp;[&amp;[i32]]</code> so now you cannot easily use <code>pretty_print</code> either.</p>
<p>Once we get to traits and generics, we‚Äôll be able to use the <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>std::convert::AsRef</code></a> trait to abstract over anything that can be referenced as a slice.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::convert::AsRef;
use std::fmt::Debug;

fn pretty_print&lt;T, Line, Matrix&gt;(matrix: Matrix)
where
    T: Debug,
    // A line references a slice of items
    Line: AsRef&lt;[T]&gt;,
    // A matrix references a slice of lines
    Matrix: AsRef&lt;[Line]&gt;
{
    for row in matrix.as_ref() {
        println!(&quot;{:?}&quot;, row.as_ref());
    }
}

fn main() {
    // &amp;[&amp;[i32]]
    pretty_print(&amp;[&amp;[1, 2, 3], &amp;[4, 5, 6], &amp;[7, 8, 9]]);
    // [[&amp;str; 2]; 2]
    pretty_print([[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]]);
    // Vec&lt;Vec&lt;i32&gt;&gt;
    pretty_print(vec![vec![1, 2], vec![3, 4]]);
}</code></pre></pre>
<p>In addition, the type itself would not enforce that the child slices are of the same length, so such variable could contain an invalid matrix.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-1-afternoon-exercises-1"><a class="header" href="#day-1-afternoon-exercises-1">Day 1 Afternoon Exercises</a></h1>
<h2 id="designing-a-library"><a class="header" href="#designing-a-library">Designing a Library</a></h2>
<p>(<a href="exercises/day-1/book-library.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust edition2021">// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: setup
struct Library {
    books: Vec&lt;Book&gt;,
}

struct Book {
    title: String,
    year: u16,
}

impl Book {
    // This is a constructor, used below.
    fn new(title: &amp;str, year: u16) -&gt; Book {
        Book {
            title: String::from(title),
            year,
        }
    }
}

// Implement the methods below. Update the `self` parameter to
// indicate the method's required level of ownership over the object:
//
// - `&amp;self` for shared read-only access,
// - `&amp;mut self` for unique and mutable access,
// - `self` for unique access by value.
impl Library {
    // ANCHOR_END: setup

    // ANCHOR: Library_new
    fn new() -&gt; Library {
        // ANCHOR_END: Library_new
        Library { books: Vec::new() }
    }

    // ANCHOR: Library_len
    //fn len(self) -&gt; usize {
    //    todo!(&quot;Return the length of `self.books`&quot;)
    //}
    // ANCHOR_END: Library_len
    fn len(&amp;self) -&gt; usize {
        self.books.len()
    }

    // ANCHOR: Library_is_empty
    //fn is_empty(self) -&gt; bool {
    //    todo!(&quot;Return `true` if `self.books` is empty&quot;)
    //}
    // ANCHOR_END: Library_is_empty
    fn is_empty(&amp;self) -&gt; bool {
        self.books.is_empty()
    }

    // ANCHOR: Library_add_book
    //fn add_book(self, book: Book) {
    //    todo!(&quot;Add a new book to `self.books`&quot;)
    //}
    // ANCHOR_END: Library_add_book
    fn add_book(&amp;mut self, book: Book) {
        self.books.push(book)
    }

    // ANCHOR: Library_print_books
    //fn print_books(self) {
    //    todo!(&quot;Iterate over `self.books` and each book's title and year&quot;)
    //}
    // ANCHOR_END: Library_print_books
    fn print_books(&amp;self) {
        for book in &amp;self.books {
            println!(&quot;{}, published in {}&quot;, book.title, book.year);
        }
    }

    // ANCHOR: Library_oldest_book
    //fn oldest_book(self) -&gt; Option&lt;&amp;Book&gt; {
    //    todo!(&quot;Return a reference to the oldest book (if any)&quot;)
    //}
    // ANCHOR_END: Library_oldest_book
    fn oldest_book(&amp;self) -&gt; Option&lt;&amp;Book&gt; {
        // Using a closure and a built-in method:
        // self.books.iter().min_by_key(|book| book.year)

        // Longer hand-written solution:
        let mut oldest: Option&lt;&amp;Book&gt; = None;
        for book in self.books.iter() {
            if oldest.is_none() || book.year &lt; oldest.unwrap().year {
                oldest = Some(book);
            }
        }

        oldest
    }
}

// ANCHOR: main
// This shows the desired behavior. Uncomment the code below and
// implement the missing methods. You will need to update the
// method signatures, including the &quot;self&quot; parameter! You may
// also need to update the variable bindings within main.
fn main() {
    let library = Library::new();

    //println!(&quot;The library is empty: library.is_empty() -&gt; {}&quot;, library.is_empty());
    //
    //library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    //library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));
    //
    //println!(&quot;The library is no longer empty: library.is_empty() -&gt; {}&quot;, library.is_empty());
    //
    //
    //library.print_books();
    //
    //match library.oldest_book() {
    //    Some(book) =&gt; println!(&quot;The oldest book is {}&quot;, book.title),
    //    None =&gt; println!(&quot;The library is empty!&quot;),
    //}
    //
    //println!(&quot;The library has {} books&quot;, library.len());
    //library.print_books();
}
// ANCHOR_END: main

#[test]
fn test_library_len() {
    let mut library = Library::new();
    assert_eq!(library.len(), 0);
    assert!(library.is_empty());

    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));
    assert_eq!(library.len(), 2);
    assert!(!library.is_empty());
}

#[test]
fn test_library_is_empty() {
    let mut library = Library::new();
    assert!(library.is_empty());

    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    assert!(!library.is_empty());
}

#[test]
fn test_library_print_books() {
    let mut library = Library::new();
    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));
    // We could try and capture stdout, but let us just call the
    // method to start with.
    library.print_books();
}

#[test]
fn test_library_oldest_book() {
    let mut library = Library::new();
    assert!(library.oldest_book().is_none());

    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    assert_eq!(
        library.oldest_book().map(|b| b.title.as_str()),
        Some(&quot;Lord of the Rings&quot;)
    );

    library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));
    assert_eq!(
        library.oldest_book().map(|b| b.title.as_str()),
        Some(&quot;Alice's Adventures in Wonderland&quot;)
    );
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-2-morning-exercises"><a class="header" href="#day-2-morning-exercises">Day 2 Morning Exercises</a></h1>
<h2 id="points-and-polygons"><a class="header" href="#points-and-polygons">Points and Polygons</a></h2>
<p>(<a href="exercises/day-2/points-polygons.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust edition2021">// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
// ANCHOR: Point
pub struct Point {
    // ANCHOR_END: Point
    x: i32,
    y: i32,
}

// ANCHOR: Point-impl
impl Point {
    // ANCHOR_END: Point-impl
    pub fn new(x: i32, y: i32) -&gt; Point {
        Point { x, y }
    }

    pub fn magnitude(self) -&gt; f64 {
        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()
    }

    pub fn dist(self, other: Point) -&gt; f64 {
        (self - other).magnitude()
    }
}

impl std::ops::Add for Point {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self::Output {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

impl std::ops::Sub for Point {
    type Output = Self;

    fn sub(self, other: Self) -&gt; Self::Output {
        Self {
            x: self.x - other.x,
            y: self.y - other.y,
        }
    }
}

// ANCHOR: Polygon
pub struct Polygon {
    // ANCHOR_END: Polygon
    points: Vec&lt;Point&gt;,
}

// ANCHOR: Polygon-impl
impl Polygon {
    // ANCHOR_END: Polygon-impl
    pub fn new() -&gt; Polygon {
        Polygon { points: Vec::new() }
    }

    pub fn add_point(&amp;mut self, point: Point) {
        self.points.push(point);
    }

    pub fn left_most_point(&amp;self) -&gt; Option&lt;Point&gt; {
        self.points.iter().min_by_key(|p| p.x).copied()
    }

    pub fn iter(&amp;self) -&gt; impl Iterator&lt;Item = &amp;Point&gt; {
        self.points.iter()
    }

    pub fn length(&amp;self) -&gt; f64 {
        if self.points.is_empty() {
            return 0.0;
        }

        let mut result = 0.0;
        let mut last_point = self.points[0];
        for point in &amp;self.points[1..] {
            result += last_point.dist(*point);
            last_point = *point;
        }
        result += last_point.dist(self.points[0]);
        result
        // Alternatively, Iterator::zip() lets us iterate over the points as pairs
        // but we need to pair each point with the next one, and the last point
        // with the first point. The zip() iterator is finished as soon as one of 
        // the source iterators is finished, a neat trick is to combine Iterator::cycle
        // with Iterator::skip to create the second iterator for the zip and using map 
        // and sum to calculate the total length.
    }
}

// ANCHOR: Circle
pub struct Circle {
    // ANCHOR_END: Circle
    center: Point,
    radius: i32,
}

// ANCHOR: Circle-impl
impl Circle {
    // ANCHOR_END: Circle-impl
    pub fn new(center: Point, radius: i32) -&gt; Circle {
        Circle { center, radius }
    }

    pub fn circumference(&amp;self) -&gt; f64 {
        2.0 * std::f64::consts::PI * f64::from(self.radius)
    }

    pub fn dist(&amp;self, other: &amp;Self) -&gt; f64 {
        self.center.dist(other.center)
    }
}

// ANCHOR: Shape
pub enum Shape {
    Polygon(Polygon),
    Circle(Circle),
}
// ANCHOR_END: Shape

impl From&lt;Polygon&gt; for Shape {
    fn from(poly: Polygon) -&gt; Self {
        Shape::Polygon(poly)
    }
}

impl From&lt;Circle&gt; for Shape {
    fn from(circle: Circle) -&gt; Self {
        Shape::Circle(circle)
    }
}

impl Shape {
    pub fn perimeter(&amp;self) -&gt; f64 {
        match self {
            Shape::Polygon(poly) =&gt; poly.length(),
            Shape::Circle(circle) =&gt; circle.circumference(),
        }
    }
}

// ANCHOR: unit-tests
#[cfg(test)]
mod tests {
    use super::*;

    fn round_two_digits(x: f64) -&gt; f64 {
        (x * 100.0).round() / 100.0
    }

    #[test]
    fn test_point_magnitude() {
        let p1 = Point::new(12, 13);
        assert_eq!(round_two_digits(p1.magnitude()), 17.69);
    }

    #[test]
    fn test_point_dist() {
        let p1 = Point::new(10, 10);
        let p2 = Point::new(14, 13);
        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);
    }

    #[test]
    fn test_point_add() {
        let p1 = Point::new(16, 16);
        let p2 = p1 + Point::new(-4, 3);
        assert_eq!(p2, Point::new(12, 19));
    }

    #[test]
    fn test_polygon_left_most_point() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);
        assert_eq!(poly.left_most_point(), Some(p1));
    }

    #[test]
    fn test_polygon_iter() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);

        let points = poly.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);
    }

    #[test]
    fn test_shape_perimeters() {
        let mut poly = Polygon::new();
        poly.add_point(Point::new(12, 13));
        poly.add_point(Point::new(17, 11));
        poly.add_point(Point::new(16, 16));
        let shapes = vec![
            Shape::from(poly),
            Shape::from(Circle::new(Point::new(10, 20), 5)),
        ];
        let perimeters = shapes
            .iter()
            .map(Shape::perimeter)
            .map(round_two_digits)
            .collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(perimeters, vec![15.48, 31.42]);
    }
}
// ANCHOR_END: unit-tests

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-2-afternoon-exercises-1"><a class="header" href="#day-2-afternoon-exercises-1">Day 2 Afternoon Exercises</a></h1>
<h2 id="luhn-algorithm-1"><a class="header" href="#luhn-algorithm-1">Luhn Algorithm</a></h2>
<p>(<a href="exercises/day-2/luhn.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust edition2021">// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: luhn
pub fn luhn(cc_number: &amp;str) -&gt; bool {
    // ANCHOR_END: luhn
    let mut digits_seen = 0;
    let mut sum = 0;
    for (i, ch) in cc_number.chars().rev().filter(|&amp;ch| ch != ' ').enumerate() {
        match ch.to_digit(10) {
            Some(d) =&gt; {
                sum += if i % 2 == 1 {
                    let dd = d * 2;
                    dd / 10 + dd % 10
                } else {
                    d
                };
                digits_seen += 1;
            }
            None =&gt; return false,
        }
    }

    if digits_seen &lt; 2 {
        return false;
    }

    sum % 10 == 0
}

fn main() {
    let cc_number = &quot;1234 5678 1234 5670&quot;;
    println!(
        &quot;Is {cc_number} a valid credit card number? {}&quot;,
        if luhn(cc_number) { &quot;yes&quot; } else { &quot;no&quot; }
    );
}

// ANCHOR: unit-tests
#[test]
fn test_non_digit_cc_number() {
    assert!(!luhn(&quot;foo&quot;));
}

#[test]
fn test_empty_cc_number() {
    assert!(!luhn(&quot;&quot;));
    assert!(!luhn(&quot; &quot;));
    assert!(!luhn(&quot;  &quot;));
    assert!(!luhn(&quot;    &quot;));
}

#[test]
fn test_single_digit_cc_number() {
    assert!(!luhn(&quot;0&quot;));
}

#[test]
fn test_two_digit_cc_number() {
    assert!(luhn(&quot; 0 0 &quot;));
}

#[test]
fn test_valid_cc_number() {
    assert!(luhn(&quot;4263 9826 4026 9299&quot;));
    assert!(luhn(&quot;4539 3195 0343 6467&quot;));
    assert!(luhn(&quot;7992 7398 713&quot;));
}

#[test]
fn test_invalid_cc_number() {
    assert!(!luhn(&quot;4223 9826 4026 9299&quot;));
    assert!(!luhn(&quot;4539 3195 0343 6476&quot;));
    assert!(!luhn(&quot;8273 1232 7352 0569&quot;));
}
// ANCHOR_END: unit-tests</code></pre></pre>
<h2 id="strings-and-iterators-1"><a class="header" href="#strings-and-iterators-1">Strings and Iterators</a></h2>
<p>(<a href="exercises/day-2/strings-iterators.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust edition2021">// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: prefix_matches
pub fn prefix_matches(prefix: &amp;str, request_path: &amp;str) -&gt; bool {
    // ANCHOR_END: prefix_matches

    let mut request_segments = request_path.split('/');

    for prefix_segment in prefix.split('/') {
        let Some(request_segment) = request_segments.next() else {
            return false;
        };
        if request_segment != prefix_segment &amp;&amp; prefix_segment != &quot;*&quot; {
            return false;
        }
    }
    true

    // Alternatively, Iterator::zip() lets us iterate simultaneously over prefix
    // and request segments. The zip() iterator is finished as soon as one of
    // the source iterators is finished, but we need to iterate over all request
    // segments. A neat trick that makes zip() work is to use map() and chain()
    // to produce an iterator that returns Some(str) for each pattern segments,
    // and then returns None indefinitely.
}

// ANCHOR: unit-tests
#[test]
fn test_matches_without_wildcard() {
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc-123&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc/books&quot;));

    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishersBooks&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/parent/publishers&quot;));
}

#[test]
fn test_matches_with_wildcard() {
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/bar/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books/book1&quot;
    ));

    assert!(!prefix_matches(&quot;/v1/publishers/*/books&quot;, &quot;/v1/publishers&quot;));
    assert!(!prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/booksByAuthor&quot;
    ));
}
// ANCHOR_END: unit-tests

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-3-morning-exercise"><a class="header" href="#day-3-morning-exercise">Day 3 Morning Exercise</a></h1>
<h2 id="a-simple-gui-library-1"><a class="header" href="#a-simple-gui-library-1">A Simple GUI Library</a></h2>
<p>(<a href="exercises/day-3/simple-gui.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust edition2021">// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: setup
pub trait Widget {
    /// Natural width of `self`.
    fn width(&amp;self) -&gt; usize;

    /// Draw the widget into a buffer.
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&amp;self) {
        let mut buffer = String::new();
        self.draw_into(&amp;mut buffer);
        println!(&quot;{buffer}&quot;);
    }
}

pub struct Label {
    label: String,
}

impl Label {
    fn new(label: &amp;str) -&gt; Label {
        Label {
            label: label.to_owned(),
        }
    }
}

pub struct Button {
    label: Label,
    callback: Box&lt;dyn FnMut()&gt;,
}

impl Button {
    fn new(label: &amp;str, callback: Box&lt;dyn FnMut()&gt;) -&gt; Button {
        Button {
            label: Label::new(label),
            callback,
        }
    }
}

pub struct Window {
    title: String,
    widgets: Vec&lt;Box&lt;dyn Widget&gt;&gt;,
}

impl Window {
    fn new(title: &amp;str) -&gt; Window {
        Window {
            title: title.to_owned(),
            widgets: Vec::new(),
        }
    }

    fn add_widget(&amp;mut self, widget: Box&lt;dyn Widget&gt;) {
        self.widgets.push(widget);
    }

    fn inner_width(&amp;self) -&gt; usize {
        std::cmp::max(
            self.title.chars().count(),
            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),
        )
    }
}

// ANCHOR_END: setup

// ANCHOR: Window-width
impl Widget for Window {
    fn width(&amp;self) -&gt; usize {
        // ANCHOR_END: Window-width
        // Add 4 paddings for borders
        self.inner_width() + 4
    }

    // ANCHOR: Window-draw_into
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        // ANCHOR_END: Window-draw_into
        let mut inner = String::new();
        for widget in &amp;self.widgets {
            widget.draw_into(&amp;mut inner);
        }

        let inner_width = self.inner_width();

        // TODO: after learning about error handling, you can change
        // draw_into to return Result&lt;(), std::fmt::Error&gt;. Then use
        // the ?-operator here instead of .unwrap().
        writeln!(buffer, &quot;+-{:-&lt;inner_width$}-+&quot;, &quot;&quot;).unwrap();
        writeln!(buffer, &quot;| {:^inner_width$} |&quot;, &amp;self.title).unwrap();
        writeln!(buffer, &quot;+={:=&lt;inner_width$}=+&quot;, &quot;&quot;).unwrap();
        for line in inner.lines() {
            writeln!(buffer, &quot;| {:inner_width$} |&quot;, line).unwrap();
        }
        writeln!(buffer, &quot;+-{:-&lt;inner_width$}-+&quot;, &quot;&quot;).unwrap();
    }
}

// ANCHOR: Button-width
impl Widget for Button {
    fn width(&amp;self) -&gt; usize {
        // ANCHOR_END: Button-width
        self.label.width() + 8 // add a bit of padding
    }

    // ANCHOR: Button-draw_into
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        // ANCHOR_END: Button-draw_into
        let width = self.width();
        let mut label = String::new();
        self.label.draw_into(&amp;mut label);

        writeln!(buffer, &quot;+{:-&lt;width$}+&quot;, &quot;&quot;).unwrap();
        for line in label.lines() {
            writeln!(buffer, &quot;|{:^width$}|&quot;, &amp;line).unwrap();
        }
        writeln!(buffer, &quot;+{:-&lt;width$}+&quot;, &quot;&quot;).unwrap();
    }
}

// ANCHOR: Label-width
impl Widget for Label {
    fn width(&amp;self) -&gt; usize {
        // ANCHOR_END: Label-width
        self.label
            .lines()
            .map(|line| line.chars().count())
            .max()
            .unwrap_or(0)
    }

    // ANCHOR: Label-draw_into
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        // ANCHOR_END: Label-draw_into
        writeln!(buffer, &quot;{}&quot;, &amp;self.label).unwrap();
    }
}

// ANCHOR: main
fn main() {
    let mut window = Window::new(&quot;Rust GUI Demo 1.23&quot;);
    window.add_widget(Box::new(Label::new(&quot;This is a small text GUI demo.&quot;)));
    window.add_widget(Box::new(Button::new(
        &quot;Click me!&quot;,
        Box::new(|| println!(&quot;You clicked the button!&quot;)),
    )));
    window.draw();
}
// ANCHOR_END: main</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-3-afternoon-exercises-1"><a class="header" href="#day-3-afternoon-exercises-1">Day 3 Afternoon Exercises</a></h1>
<h2 id="safe-ffi-wrapper-1"><a class="header" href="#safe-ffi-wrapper-1">Safe FFI Wrapper</a></h2>
<p>(<a href="exercises/day-3/safe-ffi-wrapper.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust edition2021">// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: ffi
mod ffi {
    use std::os::raw::{c_char, c_int};
    #[cfg(not(target_os = &quot;macos&quot;))]
    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    // Layout according to the Linux man page for readdir(3), where ino_t and
    // off_t are resolved according to the definitions in
    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.
    #[cfg(not(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_ulong,
        pub d_off: c_long,
        pub d_reclen: c_ushort,
        pub d_type: c_uchar,
        pub d_name: [c_char; 256],
    }

    // Layout according to the macOS man page for dir(5).
    #[cfg(all(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_fileno: u64,
        pub d_seekoff: u64,
        pub d_reclen: u16,
        pub d_namlen: u16,
        pub d_type: u8,
        pub d_name: [c_char; 1024],
    }

    extern &quot;C&quot; {
        pub fn opendir(s: *const c_char) -&gt; *mut DIR;

        #[cfg(not(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;)))]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        // See https://github.com/rust-lang/libc/issues/414 and the section on
        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).
        //
        // &quot;Platforms that existed before these updates were available&quot; refers
        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and PowerPC.
        #[cfg(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;))]
        #[link_name = &quot;readdir$INODE64&quot;]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        pub fn closedir(s: *mut DIR) -&gt; c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}
// ANCHOR_END: ffi

// ANCHOR: DirectoryIterator
impl DirectoryIterator {
    fn new(path: &amp;str) -&gt; Result&lt;DirectoryIterator, String&gt; {
        // Call opendir and return a Ok value if that worked,
        // otherwise return Err with a message.
        // ANCHOR_END: DirectoryIterator
        let path = CString::new(path).map_err(|err| format!(&quot;Invalid path: {err}&quot;))?;
        // SAFETY: path.as_ptr() cannot be NULL.
        let dir = unsafe { ffi::opendir(path.as_ptr()) };
        if dir.is_null() {
            Err(format!(&quot;Could not open {:?}&quot;, path))
        } else {
            Ok(DirectoryIterator { path, dir })
        }
    }
}

// ANCHOR: Iterator
impl Iterator for DirectoryIterator {
    type Item = OsString;
    fn next(&amp;mut self) -&gt; Option&lt;OsString&gt; {
        // Keep calling readdir until we get a NULL pointer back.
        // ANCHOR_END: Iterator
        // SAFETY: self.dir is never NULL.
        let dirent = unsafe { ffi::readdir(self.dir) };
        if dirent.is_null() {
            // We have reached the end of the directory.
            return None;
        }
        // SAFETY: dirent is not NULL and dirent.d_name is NUL
        // terminated.
        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };
        let os_str = OsStr::from_bytes(d_name.to_bytes());
        Some(os_str.to_owned())
    }
}

// ANCHOR: Drop
impl Drop for DirectoryIterator {
    fn drop(&amp;mut self) {
        // Call closedir as needed.
        // ANCHOR_END: Drop
        if !self.dir.is_null() {
            // SAFETY: self.dir is not NULL.
            if unsafe { ffi::closedir(self.dir) } != 0 {
                panic!(&quot;Could not close {:?}&quot;, self.path);
            }
        }
    }
}

// ANCHOR: main
fn main() -&gt; Result&lt;(), String&gt; {
    let iter = DirectoryIterator::new(&quot;.&quot;)?;
    println!(&quot;files: {:#?}&quot;, iter.collect::&lt;Vec&lt;_&gt;&gt;());
    Ok(())
}
// ANCHOR_END: main

#[cfg(test)]
mod tests {
    use super::*;
    use std::error::Error;

    #[test]
    fn test_nonexisting_directory() {
        let iter = DirectoryIterator::new(&quot;no-such-directory&quot;);
        assert!(iter.is_err());
    }

    #[test]
    fn test_empty_directory() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        let tmp = tempfile::TempDir::new()?;
        let iter = DirectoryIterator::new(
            tmp.path().to_str().ok_or(&quot;Non UTF-8 character in path&quot;)?,
        )?;
        let mut entries = iter.collect::&lt;Vec&lt;_&gt;&gt;();
        entries.sort();
        assert_eq!(entries, &amp;[&quot;.&quot;, &quot;..&quot;]);
        Ok(())
    }

    #[test]
    fn test_nonempty_directory() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        let tmp = tempfile::TempDir::new()?;
        std::fs::write(tmp.path().join(&quot;foo.txt&quot;), &quot;The Foo Diaries\n&quot;)?;
        std::fs::write(tmp.path().join(&quot;bar.png&quot;), &quot;&lt;PNG&gt;\n&quot;)?;
        std::fs::write(tmp.path().join(&quot;crab.rs&quot;), &quot;//! Crab\n&quot;)?;
        let iter = DirectoryIterator::new(
            tmp.path().to_str().ok_or(&quot;Non UTF-8 character in path&quot;)?,
        )?;
        let mut entries = iter.collect::&lt;Vec&lt;_&gt;&gt;();
        entries.sort();
        assert_eq!(entries, &amp;[&quot;.&quot;, &quot;..&quot;, &quot;bar.png&quot;, &quot;crab.rs&quot;, &quot;foo.txt&quot;]);
        Ok(())
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bare-metal-rust-morning-exercise"><a class="header" href="#bare-metal-rust-morning-exercise">Bare Metal Rust Morning Exercise</a></h1>
<h2 id="compass-1"><a class="header" href="#compass-1">Compass</a></h2>
<p>(<a href="exercises/bare-metal/compass.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: top
#![no_main]
#![no_std]

extern crate panic_halt as _;

use core::fmt::Write;
use cortex_m_rt::entry;
// ANCHOR_END: top
use core::cmp::{max, min};
use lsm303agr::{AccelOutputDataRate, Lsm303agr, MagOutputDataRate};
use microbit::display::blocking::Display;
use microbit::hal::prelude::*;
use microbit::hal::twim::Twim;
use microbit::hal::uarte::{Baudrate, Parity, Uarte};
use microbit::hal::Timer;
use microbit::pac::twim0::frequency::FREQUENCY_A;
use microbit::Board;

const COMPASS_SCALE: i32 = 30000;
const ACCELEROMETER_SCALE: i32 = 700;

// ANCHOR: main
#[entry]
fn main() -&gt; ! {
    let board = Board::take().unwrap();

    // Configure serial port.
    let mut serial = Uarte::new(
        board.UARTE0,
        board.uart.into(),
        Parity::EXCLUDED,
        Baudrate::BAUD115200,
    );

    // Set up the I2C controller and Inertial Measurement Unit.
    // ANCHOR_END: main
    writeln!(serial, &quot;Setting up IMU...&quot;).unwrap();
    let i2c = Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100);
    let mut imu = Lsm303agr::new_with_i2c(i2c);
    imu.init().unwrap();
    imu.set_mag_odr(MagOutputDataRate::Hz50).unwrap();
    imu.set_accel_odr(AccelOutputDataRate::Hz50).unwrap();
    let mut imu = imu.into_mag_continuous().ok().unwrap();

    // Set up display and timer.
    let mut timer = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);

    let mut mode = Mode::Compass;
    let mut button_pressed = false;

    // ANCHOR: loop
    writeln!(serial, &quot;Ready.&quot;).unwrap();

    loop {
        // Read compass data and log it to the serial port.
        // ANCHOR_END: loop
        while !(imu.mag_status().unwrap().xyz_new_data
            &amp;&amp; imu.accel_status().unwrap().xyz_new_data)
        {}
        let compass_reading = imu.mag_data().unwrap();
        let accelerometer_reading = imu.accel_data().unwrap();
        writeln!(
            serial,
            &quot;{},{},{}\t{},{},{}&quot;,
            compass_reading.x,
            compass_reading.y,
            compass_reading.z,
            accelerometer_reading.x,
            accelerometer_reading.y,
            accelerometer_reading.z,
        )
        .unwrap();

        let mut image = [[0; 5]; 5];
        let (x, y) = match mode {
            Mode::Compass =&gt; (
                scale(-compass_reading.x, -COMPASS_SCALE, COMPASS_SCALE, 0, 4) as usize,
                scale(compass_reading.y, -COMPASS_SCALE, COMPASS_SCALE, 0, 4) as usize,
            ),
            Mode::Accelerometer =&gt; (
                scale(
                    accelerometer_reading.x,
                    -ACCELEROMETER_SCALE,
                    ACCELEROMETER_SCALE,
                    0,
                    4,
                ) as usize,
                scale(
                    -accelerometer_reading.y,
                    -ACCELEROMETER_SCALE,
                    ACCELEROMETER_SCALE,
                    0,
                    4,
                ) as usize,
            ),
        };
        image[y][x] = 255;
        display.show(&amp;mut timer, image, 100);

        // If button A is pressed, switch to the next mode and briefly blink all LEDs on.
        if board.buttons.button_a.is_low().unwrap() {
            if !button_pressed {
                mode = mode.next();
                display.show(&amp;mut timer, [[255; 5]; 5], 200);
            }
            button_pressed = true;
        } else {
            button_pressed = false;
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
enum Mode {
    Compass,
    Accelerometer,
}

impl Mode {
    fn next(self) -&gt; Self {
        match self {
            Self::Compass =&gt; Self::Accelerometer,
            Self::Accelerometer =&gt; Self::Compass,
        }
    }
}

fn scale(value: i32, min_in: i32, max_in: i32, min_out: i32, max_out: i32) -&gt; i32 {
    let range_in = max_in - min_in;
    let range_out = max_out - min_out;
    cap(
        min_out + range_out * (value - min_in) / range_in,
        min_out,
        max_out,
    )
}

fn cap(value: i32, min_value: i32, max_value: i32) -&gt; i32 {
    max(min_value, min(value, max_value))
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bare-metal-rust-afternoon"><a class="header" href="#bare-metal-rust-afternoon">Bare Metal Rust Afternoon</a></h1>
<h2 id="rtc-driver-1"><a class="header" href="#rtc-driver-1">RTC driver</a></h2>
<p>(<a href="exercises/bare-metal/rtc.html">back to exercise</a>)</p>
<p><code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: top
#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;
// ANCHOR_END: top
mod pl031;

use crate::pl031::Rtc;
use arm_gic::gicv3::{IntId, Trigger};
use arm_gic::{irq_enable, wfi};
use chrono::{TimeZone, Utc};
use core::hint::spin_loop;
// ANCHOR: imports
use crate::pl011::Uart;
use arm_gic::gicv3::GicV3;
use core::panic::PanicInfo;
use log::{error, info, trace, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base addresses of the GICv3.
const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;
const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;
// ANCHOR_END: imports

/// Base address of the PL031 RTC.
const PL031_BASE_ADDRESS: *mut u32 = 0x901_0000 as _;
/// The IRQ used by the PL031 RTC.
const PL031_IRQ: IntId = IntId::spi(2);

// ANCHOR: main
#[no_mangle]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,
    // and nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!(&quot;main({:#x}, {:#x}, {:#x}, {:#x})&quot;, x0, x1, x2, x3);

    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base
    // addresses of a GICv3 distributor and redistributor respectively, and
    // nothing else accesses those address ranges.
    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };
    gic.setup();
    // ANCHOR_END: main

    // Safe because `PL031_BASE_ADDRESS` is the base address of a PL031 device,
    // and nothing else accesses that address range.
    let mut rtc = unsafe { Rtc::new(PL031_BASE_ADDRESS) };
    let timestamp = rtc.read();
    let time = Utc.timestamp_opt(timestamp.into(), 0).unwrap();
    info!(&quot;RTC: {time}&quot;);

    GicV3::set_priority_mask(0xff);
    gic.set_interrupt_priority(PL031_IRQ, 0x80);
    gic.set_trigger(PL031_IRQ, Trigger::Level);
    irq_enable();
    gic.enable_interrupt(PL031_IRQ, true);

    // Wait for 3 seconds, without interrupts.
    let target = timestamp + 3;
    rtc.set_match(target);
    info!(
        &quot;Waiting for {}&quot;,
        Utc.timestamp_opt(target.into(), 0).unwrap()
    );
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    while !rtc.matched() {
        spin_loop();
    }
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    info!(&quot;Finished waiting&quot;);

    // Wait another 3 seconds for an interrupt.
    let target = timestamp + 6;
    info!(
        &quot;Waiting for {}&quot;,
        Utc.timestamp_opt(target.into(), 0).unwrap()
    );
    rtc.set_match(target);
    rtc.clear_interrupt();
    rtc.enable_interrupt(true);
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    while !rtc.interrupt_pending() {
        wfi();
    }
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    info!(&quot;Finished waiting&quot;);

    // ANCHOR: main_end
    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!(&quot;{info}&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}
// ANCHOR_END: main_end</code></pre></pre>
<p><code>pl031.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use core::ptr::{addr_of, addr_of_mut};

#[repr(C, align(4))]
struct Registers {
    /// Data register
    dr: u32,
    /// Match register
    mr: u32,
    /// Load register
    lr: u32,
    /// Control register
    cr: u8,
    _reserved0: [u8; 3],
    /// Interrupt Mask Set or Clear register
    imsc: u8,
    _reserved1: [u8; 3],
    /// Raw Interrupt Status
    ris: u8,
    _reserved2: [u8; 3],
    /// Masked Interrupt Status
    mis: u8,
    _reserved3: [u8; 3],
    /// Interrupt Clear Register
    icr: u8,
    _reserved4: [u8; 3],
}

/// Driver for a PL031 real-time clock.
#[derive(Debug)]
pub struct Rtc {
    registers: *mut Registers,
}

impl Rtc {
    /// Constructs a new instance of the RTC driver for a PL031 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the MMIO control registers of a
    /// PL031 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self {
            registers: base_address as *mut Registers,
        }
    }

    /// Reads the current RTC value.
    pub fn read(&amp;self) -&gt; u32 {
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        unsafe { addr_of!((*self.registers).dr).read_volatile() }
    }

    /// Writes a match value. When the RTC value matches this then an interrupt
    /// will be generated (if it is enabled).
    pub fn set_match(&amp;mut self, value: u32) {
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        unsafe { addr_of_mut!((*self.registers).mr).write_volatile(value) }
    }

    /// Returns whether the match register matches the RTC value, whether or not
    /// the interrupt is enabled.
    pub fn matched(&amp;self) -&gt; bool {
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        let ris = unsafe { addr_of!((*self.registers).ris).read_volatile() };
        (ris &amp; 0x01) != 0
    }

    /// Returns whether there is currently an interrupt pending.
    ///
    /// This should be true if and only if `matched` returns true and the
    /// interrupt is masked.
    pub fn interrupt_pending(&amp;self) -&gt; bool {
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        let ris = unsafe { addr_of!((*self.registers).mis).read_volatile() };
        (ris &amp; 0x01) != 0
    }

    /// Sets or clears the interrupt mask.
    ///
    /// When the mask is true the interrupt is enabled; when it is false the
    /// interrupt is disabled.
    pub fn enable_interrupt(&amp;mut self, mask: bool) {
        let imsc = if mask { 0x01 } else { 0x00 };
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        unsafe { addr_of_mut!((*self.registers).imsc).write_volatile(imsc) }
    }

    /// Clears a pending interrupt, if any.
    pub fn clear_interrupt(&amp;mut self) {
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        unsafe { addr_of_mut!((*self.registers).icr).write_volatile(0x01) }
    }
}

// Safe because it just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Rtc {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency-morning-exercise"><a class="header" href="#concurrency-morning-exercise">Concurrency Morning Exercise</a></h1>
<h2 id="dining-philosophers-1"><a class="header" href="#dining-philosophers-1">Dining Philosophers</a></h2>
<p>(<a href="exercises/concurrency/dining-philosophers.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust edition2021">// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: Philosopher
use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::Duration;

struct Fork;

struct Philosopher {
    name: String,
    // ANCHOR_END: Philosopher
    left_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    right_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    thoughts: mpsc::SyncSender&lt;String&gt;,
}

// ANCHOR: Philosopher-think
impl Philosopher {
    fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .unwrap();
    }
    // ANCHOR_END: Philosopher-think

    // ANCHOR: Philosopher-eat
    fn eat(&amp;self) {
        // ANCHOR_END: Philosopher-eat
        println!(&quot;{} is trying to eat&quot;, &amp;self.name);
        let left = self.left_fork.lock().unwrap();
        let right = self.right_fork.lock().unwrap();

        // ANCHOR: Philosopher-eat-end
        println!(&quot;{} is eating...&quot;, &amp;self.name);
        thread::sleep(Duration::from_millis(10));
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Thales&quot;, &quot;Pythagoras&quot;];

fn main() {
    // ANCHOR_END: Philosopher-eat-end
    let (tx, rx) = mpsc::sync_channel(10);

    let forks = (0..PHILOSOPHERS.len())
        .map(|_| Arc::new(Mutex::new(Fork)))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    for i in 0..forks.len() {
        let tx = tx.clone();
        let mut left_fork = Arc::clone(&amp;forks[i]);
        let mut right_fork = Arc::clone(&amp;forks[(i + 1) % forks.len()]);

        // To avoid a deadlock, we have to break the symmetry
        // somewhere. This will swap the forks without deinitializing
        // either of them.
        if i == forks.len() - 1 {
            std::mem::swap(&amp;mut left_fork, &amp;mut right_fork);
        }

        let philosopher = Philosopher {
            name: PHILOSOPHERS[i].to_string(),
            thoughts: tx,
            left_fork,
            right_fork,
        };

        thread::spawn(move || {
            for _ in 0..100 {
                philosopher.eat();
                philosopher.think();
            }
        });
    }

    drop(tx);
    for thought in rx {
        println!(&quot;{thought}&quot;);
    }
}</code></pre></pre>
<h2 id="link-checker"><a class="header" href="#link-checker">Link Checker</a></h2>
<p>(<a href="exercises/concurrency/link-checker.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::{sync::Arc, sync::Mutex, sync::mpsc, thread};

// ANCHOR: setup
use reqwest::{blocking::Client, Url};
use scraper::{Html, Selector};
use thiserror::Error;

#[derive(Error, Debug)]
enum Error {
    #[error(&quot;request error: {0}&quot;)]
    ReqwestError(#[from] reqwest::Error),
    #[error(&quot;bad http response: {0}&quot;)]
    BadResponse(String),
}
// ANCHOR_END: setup

// ANCHOR: visit_page
#[derive(Debug)]
struct CrawlCommand {
    url: Url,
    extract_links: bool,
}

fn visit_page(client: &amp;Client, command: &amp;CrawlCommand) -&gt; Result&lt;Vec&lt;Url&gt;, Error&gt; {
    println!(&quot;Checking {:#}&quot;, command.url);
    let response = client.get(command.url.clone()).send()?;
    if !response.status().is_success() {
        return Err(Error::BadResponse(response.status().to_string()));
    }

    let mut link_urls = Vec::new();
    if !command.extract_links {
        return Ok(link_urls);
    }

    let base_url = response.url().to_owned();
    let body_text = response.text()?;
    let document = Html::parse_document(&amp;body_text);

    let selector = Selector::parse(&quot;a&quot;).unwrap();
    let href_values = document
        .select(&amp;selector)
        .filter_map(|element| element.value().attr(&quot;href&quot;));
    for href in href_values {
        match base_url.join(href) {
            Ok(link_url) =&gt; {
                link_urls.push(link_url);
            }
            Err(err) =&gt; {
                println!(&quot;On {base_url:#}: ignored unparsable {href:?}: {err}&quot;);
            }
        }
    }
    Ok(link_urls)
}
// ANCHOR_END: visit_page

struct CrawlState {
    domain: String,
    visited_pages: std::collections::HashSet&lt;String&gt;,
}

impl CrawlState {
    fn new(start_url: &amp;Url) -&gt; CrawlState {
        let mut visited_pages = std::collections::HashSet::new();
        visited_pages.insert(start_url.as_str().to_string());
        CrawlState {
            domain: start_url.domain().unwrap().to_string(),
            visited_pages,
        }
    }

    /// Determine whether links within the given page should be extracted.
    fn should_extract_links(&amp;self, url: &amp;Url) -&gt; bool {
        let Some(url_domain) = url.domain() else {
            return false;
        };
        url_domain == self.domain
    }

    /// Mark the given page as visited, returning true if it had already
    /// been visited.
    fn mark_visited(&amp;mut self, url: &amp;Url) -&gt; bool {
        self.visited_pages.insert(url.as_str().to_string())
    }
}

type CrawlResult = Result&lt;Vec&lt;Url&gt;, (Url, Error)&gt;;
fn spawn_crawler_threads(
    command_receiver: mpsc::Receiver&lt;CrawlCommand&gt;,
    result_sender: mpsc::Sender&lt;CrawlResult&gt;,
    thread_count: u32,
) {
    let command_receiver = Arc::new(Mutex::new(command_receiver));

    for _ in 0..thread_count {
        let result_sender = result_sender.clone();
        let command_receiver = command_receiver.clone();
        thread::spawn(move || {
            let client = Client::new();
            loop {
                let command_result = {
                    let receiver_guard = command_receiver.lock().unwrap();
                    receiver_guard.recv()
                };
                let Ok(crawl_command) = command_result else {
                    // The sender got dropped. No more commands coming in.
                    break;
                };
                let crawl_result = match visit_page(&amp;client, &amp;crawl_command) {
                    Ok(link_urls) =&gt; Ok(link_urls),
                    Err(error) =&gt; Err((crawl_command.url, error)),
                };
                result_sender.send(crawl_result).unwrap();
            }
        });
    }
}

fn control_crawl(
    start_url: Url,
    command_sender: mpsc::Sender&lt;CrawlCommand&gt;,
    result_receiver: mpsc::Receiver&lt;CrawlResult&gt;,
) -&gt; Vec&lt;Url&gt; {
    let mut crawl_state = CrawlState::new(&amp;start_url);
    let start_command = CrawlCommand { url: start_url, extract_links: true };
    command_sender.send(start_command).unwrap();
    let mut pending_urls = 1;

    let mut bad_urls = Vec::new();
    while pending_urls &gt; 0 {
        let crawl_result = result_receiver.recv().unwrap();
        pending_urls -= 1;

        match crawl_result {
            Ok(link_urls) =&gt; {
                for url in link_urls {
                    if crawl_state.mark_visited(&amp;url) {
                        let extract_links = crawl_state.should_extract_links(&amp;url);
                        let crawl_command = CrawlCommand { url, extract_links };
                        command_sender.send(crawl_command).unwrap();
                        pending_urls += 1;
                    }
                }
            }
            Err((url, error)) =&gt; {
                bad_urls.push(url);
                println!(&quot;Got crawling error: {:#}&quot;, error);
                continue;
            }
        }
    }
    bad_urls
}

fn check_links(start_url: Url) -&gt; Vec&lt;Url&gt; {
    let (result_sender, result_receiver) = mpsc::channel::&lt;CrawlResult&gt;();
    let (command_sender, command_receiver) = mpsc::channel::&lt;CrawlCommand&gt;();
    spawn_crawler_threads(command_receiver, result_sender, 16);
    control_crawl(start_url, command_sender, result_receiver)
}

fn main() {
    let start_url = reqwest::Url::parse(&quot;https://www.google.org&quot;).unwrap();
    let bad_urls = check_links(start_url);
    println!(&quot;Bad URLs: {:#?}&quot;, bad_urls);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency-afternoon-exercise"><a class="header" href="#concurrency-afternoon-exercise">Concurrency Afternoon Exercise</a></h1>
<h2 id="dining-philosophers---async-1"><a class="header" href="#dining-philosophers---async-1">Dining Philosophers - Async</a></h2>
<p>(<a href="exercises/concurrency/dining-philosophers-async.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: Philosopher
use std::sync::Arc;
use tokio::time;
use tokio::sync::mpsc::{self, Sender};
use tokio::sync::Mutex;

struct Fork;

struct Philosopher {
    name: String,
    // ANCHOR_END: Philosopher
    left_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    right_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    thoughts: Sender&lt;String&gt;,
}

// ANCHOR: Philosopher-think
impl Philosopher {
    async fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name)).await
            .unwrap();
    }
    // ANCHOR_END: Philosopher-think

    // ANCHOR: Philosopher-eat
    async fn eat(&amp;self) {
        // Pick up forks...
        // ANCHOR_END: Philosopher-eat
        let _first_lock = self.left_fork.lock().await;
        // Add a delay before picking the second fork to allow the execution
        // to transfer to another task
        time::sleep(time::Duration::from_millis(1)).await;
        let _second_lock = self.right_fork.lock().await;

        // ANCHOR: Philosopher-eat-body
        println!(&quot;{} is eating...&quot;, &amp;self.name);
        time::sleep(time::Duration::from_millis(5)).await;
        // ANCHOR_END: Philosopher-eat-body

        // The locks are dropped here
        // ANCHOR: Philosopher-eat-end
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Thales&quot;, &quot;Pythagoras&quot;];

#[tokio::main]
async fn main() {
    // ANCHOR_END: Philosopher-eat-end
    // Create forks
    let mut forks = vec![];
    (0..PHILOSOPHERS.len()).for_each(|_| forks.push(Arc::new(Mutex::new(Fork))));

    // Create philosophers
    let (philosophers, mut rx) = {
        let mut philosophers = vec![];
        let (tx, rx) = mpsc::channel(10);
        for (i, name) in PHILOSOPHERS.iter().enumerate() {
            let left_fork = Arc::clone(&amp;forks[i]);
            let right_fork = Arc::clone(&amp;forks[(i + 1) % PHILOSOPHERS.len()]);
            // To avoid a deadlock, we have to break the symmetry
            // somewhere. This will swap the forks without deinitializing
            // either of them.
            if i  == 0 {
                std::mem::swap(&amp;mut left_fork, &amp;mut right_fork);
            }
            philosophers.push(Philosopher {
                name: name.to_string(),
                left_fork,
                right_fork,
                thoughts: tx.clone(),
            });
        }
        (philosophers, rx)
        // tx is dropped here, so we don't need to explicitly drop it later
    };

    // Make them think and eat
    for phil in philosophers {
        tokio::spawn(async move {
            for _ in 0..100 {
                phil.think().await;
                phil.eat().await;
            }
        });

    }

    // Output their thoughts
    while let Some(thought) = rx.recv().await {
        println!(&quot;Here is a thought: {thought}&quot;);
    }
}</code></pre></pre>
<h2 id="broadcast-chat-application-1"><a class="header" href="#broadcast-chat-application-1">Broadcast Chat Application</a></h2>
<p>(<a href="exercises/concurrency/chat-app.html">back to exercise</a>)</p>
<p><code>src/bin/server.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: setup
use futures_util::sink::SinkExt;
use std::error::Error;
use std::net::SocketAddr;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::broadcast::{channel, Sender};
use tokio_websockets::{Message, ServerBuilder, WebsocketStream};
// ANCHOR_END: setup

// ANCHOR: handle_connection
async fn handle_connection(
    addr: SocketAddr,
    mut ws_stream: WebsocketStream&lt;TcpStream&gt;,
    bcast_tx: Sender&lt;String&gt;,
) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    // ANCHOR_END: handle_connection

    ws_stream
        .send(Message::text(&quot;Welcome to chat! Type a message&quot;.into()))
        .await?;
    let mut bcast_rx = bcast_tx.subscribe();

    // A continuous loop for concurrently performing two tasks: (1) receiving
    // messages from `ws_stream` and broadcasting them, and (2) receiving
    // messages on `bcast_rx` and sending them to the client.
    loop {
        tokio::select! {
            incoming = ws_stream.next() =&gt; {
                match incoming {
                    Some(Ok(msg)) =&gt; {
                        let msg = msg.as_text()?;
                        println!(&quot;From client {addr:?} {msg:?}&quot;);
                        bcast_tx.send(msg.into())?;
                    }
                    Some(Err(err)) =&gt; return Err(err.into()),
                    None =&gt; return Ok(()),
                }
            }
            msg = bcast_rx.recv() =&gt; {
                ws_stream.send(Message::text(msg?)).await?;
            }
        }
    }
    // ANCHOR: main
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let (bcast_tx, _) = channel(16);

    let listener = TcpListener::bind(&quot;127.0.0.1:2000&quot;).await?;
    println!(&quot;listening on port 2000&quot;);

    loop {
        let (socket, addr) = listener.accept().await?;
        println!(&quot;New connection from {addr:?}&quot;);
        let bcast_tx = bcast_tx.clone();
        tokio::spawn(async move {
            // Wrap the raw TCP stream into a websocket.
            let ws_stream = ServerBuilder::new().accept(socket).await?;

            handle_connection(addr, ws_stream, bcast_tx).await
        });
    }
}
// ANCHOR_END: main</code></pre></pre>
<p><code>src/bin/client.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021">// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: setup
use futures_util::SinkExt;
use http::Uri;
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio_websockets::{ClientBuilder, Message};

#[tokio::main]
async fn main() -&gt; Result&lt;(), tokio_websockets::Error&gt; {
    let mut ws_stream = ClientBuilder::from_uri(Uri::from_static(&quot;ws://127.0.0.1:2000&quot;))
        .connect()
        .await?;

    let stdin = tokio::io::stdin();
    let mut stdin = BufReader::new(stdin).lines();

    // ANCHOR_END: setup
    // Continuous loop for concurrently sending and receiving messages.
    loop {
        tokio::select! {
            incoming = ws_stream.next() =&gt; {
                match incoming {
                    Some(Ok(msg)) =&gt; println!(&quot;From server: {}&quot;, msg.as_text()?),
                    Some(Err(err)) =&gt; return Err(err.into()),
                    None =&gt; return Ok(()),
                }
            }
            res = stdin.next_line() =&gt; {
                match res {
                    Ok(None) =&gt; return Ok(()),
                    Ok(Some(line)) =&gt; ws_stream.send(Message::text(line.to_string())).await?,
                    Err(err) =&gt; return Err(err.into()),
                }
            }

        }
    }
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="speaker-notes.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>

<!-- google.github.io/comprehensive-rust/bn/print.html  08:58:01 GMT -->
</html>
